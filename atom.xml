<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>洛竹的博客</title>
  
  <subtitle>真理无穷，一寸欢喜。</subtitle>
  <link href="https://youngjuning.js.org/atom.xml" rel="self"/>
  
  <link href="https://youngjuning.js.org/"/>
  <updated>2023-03-07T10:29:44.644Z</updated>
  <id>https://youngjuning.js.org/</id>
  
  <author>
    <name>洛竹</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>React 面试必知必会</title>
    <link href="https://youngjuning.js.org/react-interview/"/>
    <id>https://youngjuning.js.org/react-interview/</id>
    <published>2023-03-06T11:30:00.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-核心"><a href="#React-核心" class="headerlink" title="React 核心"></a>React 核心</h1><h2 id="1-什么是-React？"><a href="#1-什么是-React？" class="headerlink" title="1. 什么是 React？"></a>1. 什么是 React？</h2><p>React 是一个<strong>开源前端 JavaScript 库</strong>，用于构建用户界面，尤其是单页应用程序。它用于处理 Web 和移动应用程序的视图层。React 是由 Facebook 的软件工程师 <a href="https://github.com/jordwalke">乔丹·沃克</a> 创建的。React 于 2011 年在 Facebook 的 News Feed 上首次发布，2012 年首次在 Instagram 发布。</p><h2 id="2-React-的主要特性是什么？"><a href="#2-React-的主要特性是什么？" class="headerlink" title="2. React 的主要特性是什么？"></a>2. React 的主要特性是什么？</h2><p>React 的主要特性是:</p><ul><li>考虑到 DOM 操作内存开销大，React 使用<strong>虚拟 DOM（VirtualDOM）</strong> 替代了真实 DOM（RealDOM）</li><li>支持<strong>服务端渲染</strong></li><li>遵循<strong>单向</strong>数据流或数据绑定</li><li>使用<strong>可复用&#x2F;可组合</strong>的 UI 组件来进行视图开发</li></ul><h2 id="3-什么是-JSX？"><a href="#3-什么是-JSX？" class="headerlink" title="3. 什么是 JSX？"></a>3. 什么是 JSX？</h2><p>JSX 是 ECMAScript 的类似 XML 的语法扩展（缩写是 JavaScript XML）。实际上，它只是为 <code>React.createElement()</code> 函数提供语法糖，为我们提供了在 JavaScript 中使用类 HTML 模板语法的能力。</p><p>下面的示例中，<code>&lt;h1&gt;</code> 标签内的文本会作为 JavaScript 函数（<code>React.createElement()</code>）的返回值返回给 render 函数：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#x27;Welcome to React world!&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-元素（Element）和组件（Component）的区别是什么？"><a href="#4-元素（Element）和组件（Component）的区别是什么？" class="headerlink" title="4. 元素（Element）和组件（Component）的区别是什么？"></a>4. 元素（Element）和组件（Component）的区别是什么？</h2><p>元素是一个普通的对象，它描述了你希望以 DOM 节点或其他组件的形式出现在屏幕上的内容。元素可以在其 props 中包含其他 元素。创建一个 React 元素开销很小。一旦创建了元素，就永远不会对其进行修改。</p><p>React Element 的对象表示如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;login-btn&#x27;</span> &#125;, <span class="string">&#x27;Login&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面的 <code>React.createElement()</code> 函数会返回一个如下的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Login&#x27;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;login-btn&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，它会使用 <code>ReactDOM.render()</code> 将元素渲染到 DOM：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-btn&quot;</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而<strong>组件</strong>可以用几种不同的方式声明。它可以是带有 <code>render()</code> 方法的类。或者，你可以简单地将其定义为一个函数。无论哪种情况，它都将 props 作为输入，并返回 JSX 树作为输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">&#123; onLogin &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">login-btn</span>&#x27;&#125; <span class="attr">onClick</span>=<span class="string">&#123;onLogin&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Login</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后将 JSX 编译成 <code>React.createElement()</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">&#123; onLogin &#125;</span>) =&gt;</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;login-btn&#x27;</span>, <span class="attr">onClick</span>: onLogin &#125;, <span class="string">&#x27;Login&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="5-如何在-React-中创建组件？"><a href="#5-如何在-React-中创建组件？" class="headerlink" title="5. 如何在 React 中创建组件？"></a>5. 如何在 React 中创建组件？</h2><p>这里有两种可以用方式来创建一个组件：</p><ol><li><strong>函数组件：</strong> 这是创建组件最简单的方式。它们是纯 JavaScript 函数，接受 props 对象作为第一个参数并返回 React 元素：</li></ol><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">&#123; message &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Hello, $&#123;message&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>类组件：</strong> 你也可以使用 ES6 的 class 语法来定义一个组件。上面的函数组件可以被改写为：</li></ol><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Hello, $&#123;this.props.message&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-何时选择类组件或函数组件"><a href="#6-何时选择类组件或函数组件" class="headerlink" title="6. 何时选择类组件或函数组件"></a>6. 何时选择类组件或函数组件</h2><p>如果一个组件需要状态或者生命周期方法，则使用类组件，否则使用函数组件。</p><p>然而，从 React 16.8 引入 Hooks 后，你可以在函数组件中使用之前只在类组件中有的特性，比如状态和生命周期方法。</p><h2 id="7-Pure-Components-是什么？"><a href="#7-Pure-Components-是什么？" class="headerlink" title="7. Pure Components 是什么？"></a>7. Pure Components 是什么？</h2><p><code>React.PureComponent</code> 与 <code>React.Component</code> 几乎完全相同，不同之处在于它为你处理了 <code>shouldComponentUpdate()</code> 方法。当 props 和 state 改变时，PureComponent 将对 props 和 state 进行浅表比较。另一方面，Component 初始不会将当前 props 和 state 与 nextPorps 和 nextState 进行比较。因此，每当调用 <code>shouldComponentUpdate</code> 时，组件将默认重新渲染。</p><h2 id="8-React-中的-state-是什么？"><a href="#8-React-中的-state-是什么？" class="headerlink" title="8. React 中的 state 是什么？"></a>8. React 中的 state 是什么？</h2><p>组件的状态是一个对象，其中包含一些在组件的生命周期中可能会发生变化的信息。我们应该始终尝试使状态尽可能简单，并最大程度减少有状态组件的数量。</p><p>让我们来创建一个带有 message 状态的 user 组件：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Welcome to React world&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.state.message&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8472c6438dfe48068002c5fdf1fbf098~tplv-k3u1fbpfcp-zoom-1.image" alt="state"></p><p>状态类似于 Props，但它是私有的，并由组件完全控制。也就是说除了拥有和设置它的组件之外，其他任何组件都无法访问它。</p><h2 id="9-React-中的-props-是什么"><a href="#9-React-中的-props-是什么" class="headerlink" title="9. React 中的 props 是什么"></a>9. React 中的 props 是什么</h2><p>Props 是组件的输入。它们是单个值或包含一组值的对象，这些对象在创建时会使用类似于 HTML 标签属性的命名约定传递给组件。它们是从父组件传递到子组件的数据。</p><p>React 中 props 的主要目的是提供以下组件功能：</p><ol><li>将自定义数据传递到你的组件。</li><li>触发状态更改。</li><li>通过组件的 <code>render()</code> 方法中的 <code>this.props.reactProp</code> 使用。</li></ol><p>举个例子，让我们创建一个带有 <code>reactProp</code> 属性的元素：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Element</span> reactProp=&#123;<span class="string">&#x27;1&#x27;</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>然后，这个 <code>reactProp</code>（或你想出的任何名称）成为附加到 React 的本地 props 对象的属性，该对象最初已经存在于使用 React 库创建的所有组件上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.<span class="property">reactProp</span>;</span><br></pre></td></tr></table></figure><h2 id="10-state-和-props-的区别是什么？"><a href="#10-state-和-props-的区别是什么？" class="headerlink" title="10. state 和 props 的区别是什么？"></a>10. state 和 props 的区别是什么？</h2><p>props 和 state 都是普通的 JavaScript 对象。尽管它们两者都拥有影响渲染输出的信息，但它们在组件层面的功能却有所不同。将 props 传递给组件类似于传递参数给函数，而 state 则类似于函数中声明的变量一样在组件内进行管理。</p><h2 id="11-为什么我们不能直接更新状态？"><a href="#11-为什么我们不能直接更新状态？" class="headerlink" title="11. 为什么我们不能直接更新状态？"></a>11. 为什么我们不能直接更新状态？</h2><p>如果你尝试直接更新状态，React 组件并不会重新渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误❌</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">message</span> = <span class="string">&#x27;Hello world&#x27;</span>;</span><br></pre></td></tr></table></figure><p>正确的做法是使用 <code>setState()</code> 方法。它会计划一个对组件状态对象的更新。当状态更改时，组件通过重新渲染进行响应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确✅</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;Hello World&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>你可以使用构造函数或者最新的 javascript class 字段声明语法直接将其分配给状态对象。</p></blockquote><h2 id="12-回调函数作为-setState-的参数的目的是什么？"><a href="#12-回调函数作为-setState-的参数的目的是什么？" class="headerlink" title="12. 回调函数作为 setState() 的参数的目的是什么？"></a>12. 回调函数作为 <code>setState()</code> 的参数的目的是什么？</h2><p>setState 完成并重新渲染组件后，将调用回调函数。由于 setState() 是异步的，因此回调函数可用于任何后续操作。</p><blockquote><p><strong>注意：</strong>我们建议使用生命周期方法而不是这个回调函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setState</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;, <span class="function">() =&gt;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The name has updated and component re-rendered&#x27;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="13-HTML-和-React-的事件处理有什么不同？"><a href="#13-HTML-和-React-的事件处理有什么不同？" class="headerlink" title="13. HTML 和 React 的事件处理有什么不同？"></a>13. HTML 和 React 的事件处理有什么不同？</h2><p>下面是一些 HTML 和 React 的事件处理的主要不同：</p><ol><li>在 HTML 中，事件名应该是全小写的：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;activateLasers()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而在 React 中事件名遵循小驼峰 格式：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 HTML 中，你应该返回 <code>false</code> 来阻止默认行为：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;console.log(&quot;The link was clicked.&quot;); return false;&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 React 中你必须明确地调用 <code>preventDefault()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The link was clicked.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 HTML 中，你调用函数时需要加上 <code>()</code>：</li></ol><p>然后在 React 中你不应该在函数名后带上 <code>()</code>。（比如前面示例中的 <code>activateLasers</code> 函数）</p><h2 id="14-如何在-JSX-回调函数中绑定方法或事件处理器"><a href="#14-如何在-JSX-回调函数中绑定方法或事件处理器" class="headerlink" title="14. 如何在 JSX 回调函数中绑定方法或事件处理器"></a>14. 如何在 JSX 回调函数中绑定方法或事件处理器</h2><p>这里有 3 个方法做到这一点：</p><ol><li><strong>在构造器中绑定：</strong> 在 JavaScript 类中，默认情况下不绑定方法。同样的事情也适用于定义为类方法的 React 事件处理器。通常我们将它们绑定在构造函数中。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>类的公共字段语法：</strong> 如果你不喜欢使用绑定的方式，也可以使用类的公共字段语法来正确绑定回调：</li></ol><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is:&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>&#125;&gt;&#123;<span class="string">&#x27;Click me&#x27;</span>&#125;&lt;/button&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>箭头函数作为回调：</strong> 你可以直接在回调中使用箭头函数</li></ol><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function"><span class="params">event</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">handleClick</span>(event)&#125;&gt;&#123;<span class="string">&#x27;Click me&#x27;</span>&#125;&lt;/button&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 如果回调作为 prop 传递给子组件，这些组件可能会触发额外的重渲染。在这些场景中，考虑到性能因素，最佳的选择是使用 <code>.bind()</code> 或类的公共字段语法。</p></blockquote><h2 id="15-如何传递参数给事件处理器或回调？"><a href="#15-如何传递参数给事件处理器或回调？" class="headerlink" title="15. 如何传递参数给事件处理器或回调？"></a>15. 如何传递参数给事件处理器或回调？</h2><p>你可以使用一个箭头函数来包裹一个事件处理器并传递参数：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">handleClick</span>(id)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>这等价于调用 <code>.bind</code> 函数：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>, id)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>除了这两种办法，你也可以传递参数给一个箭头函数：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="title function_">handleClick</span>(id)&#125; /&gt;;</span><br><span class="line">handleClick = <span class="function"><span class="params">id</span> =&gt;</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, your ticket number is&#x27;</span>, id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="16-React-中的合成事件是什么？"><a href="#16-React-中的合成事件是什么？" class="headerlink" title="16. React 中的合成事件是什么？"></a>16. React 中的合成事件是什么？</h2><p><code>SyntheticEvent</code> 是基于浏览器本地事件的跨浏览器包装。它的 API 与浏览器的本地事件相同，包括 <code>stopPropagation()</code> 和 <code>preventDefault()</code>，但事件在所有浏览器中的表现均一致。</p><h2 id="17-什么是内联条件表达式？"><a href="#17-什么是内联条件表达式？" class="headerlink" title="17. 什么是内联条件表达式？"></a>17. 什么是内联条件表达式？</h2><p>你可以使用 JS 可用的 <code>if</code> 语句或三元表达式来有条件地渲染表达式。 除了这些方法之外，还可以通过将所有表达式括在花括号中然后在其后跟 JS 逻辑运算符 <code>&amp;&amp;</code> 来将任何表达式嵌入 JSX。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;<span class="title class_">Hello</span>!&lt;/h1&gt;;</span><br><span class="line">&#123;</span><br><span class="line">  messages.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; !isLogin ? (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>You have &#123;messages.length&#125; unread messages.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  ) : (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>You don&#x27;t have unread messages.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="18-什么是-key-prop？在元素数组中使用它的好处是什么？"><a href="#18-什么是-key-prop？在元素数组中使用它的好处是什么？" class="headerlink" title="18. 什么是 key prop？在元素数组中使用它的好处是什么？"></a>18. 什么是 <code>key</code> prop？在元素数组中使用它的好处是什么？</h2><p><code>key</code> 是当你创建一个元素数组时应该包含的一个特殊的字符串属性。<code>key</code> prop 会帮助 React 识别具体哪一项被修改、添加或被移除。</p><p>通常，我们将数据中的 ID 用作 <code>key</code>：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.<span class="title function_">map</span>(<span class="function"><span class="params">todo</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;todo.id&#125;</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>如果呈现的项目没有稳定的 ID，退而求其次，我们可以将 <code>index</code> 作为 <code>key</code>：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.<span class="title function_">map</span>(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index.toString()&#125;</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">));</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>如果列表项可能改变，不建议使用 <code>indexes</code> 作为 <code>keys</code>。这可能会对性能产生负面影响，并可能导致组件状态出现问题。</li><li>如果你将列表项提取为单独的组件，则在列表组件上应用 <code>keys</code> 而不是 <code>li</code> 标签。</li><li>如果列表项中不存在 <code>key</code> prop，则控制台中将出现警告消息。</li></ol><h2 id="19-refs-有什么用？"><a href="#19-refs-有什么用？" class="headerlink" title="19. refs 有什么用？"></a>19. refs 有什么用？</h2><p>refs 用于返回对该元素的引用。在大多数情况下，应避免使用它们，但是，当你需要直接访问 DOM 元素或组件的实例时，它们会很有用。</p><h2 id="20-如何创建-refs？"><a href="#20-如何创建-refs？" class="headerlink" title="20. 如何创建 refs？"></a>20. 如何创建 refs？</h2><p>这里有两种方式</p><p>1.这是最近添加的方法。使用 <code>React.createRef()</code> 方法创建 refs，并通过 ref 属性附加到 React 元素。为了在整个组件中使用 refs，只需将 ref 分配给构造函数中的 instance 属性。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>无论 React 版本如何，你都可以使用 ref 回调方法。例如，搜索栏组件的输入元素的访问方式如下。</li></ol><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SearchBar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">txtSearch</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">term</span>: <span class="string">&#x27;&#x27;</span> &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setInputSearchRef</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">txtSearch</span> = e;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">onInputChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">term</span>: <span class="variable language_">this</span>.<span class="property">txtSearch</span>.<span class="property">value</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;this.state.term&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;this.onInputChange.bind(this)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">ref</span>=<span class="string">&#123;this.setInputSearchRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你也可以使用闭包在函数组件中使用 refs。</p><blockquote><p><strong>注意：</strong> 你也可以使用内联 ref 回调，即使这不是推荐的方法</p></blockquote><h2 id="21-refs-转发是什么？"><a href="#21-refs-转发是什么？" class="headerlink" title="21. refs 转发是什么？"></a>21. refs 转发是什么？</h2><p><em>Ref 转发</em> 是让某些组件可以使用它们接收的 <code>ref</code> 的特性，这些组件还可以进一步将其传递给子组件。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ButtonElement</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">className</span>=<span class="string">&quot;CustomButton&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create ref to the DOM button:</span></span><br><span class="line"><span class="keyword">const</span> ref = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ButtonElement</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span>&gt;</span>&#123;&#x27;Forward Ref&#x27;&#125;<span class="tag">&lt;/<span class="name">ButtonElement</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure><h2 id="22-refs-回调和-findDOMNode-哪个是首选项？"><a href="#22-refs-回调和-findDOMNode-哪个是首选项？" class="headerlink" title="22. refs 回调和 findDOMNode() 哪个是首选项？"></a>22. refs 回调和 <code>findDOMNode()</code> 哪个是首选项？</h2><p>最好使用 refs 回调 而不是 <code>findDOMNode()</code> API。因为 <code>findDOMNode()</code> 将来会阻止对 React 的某些改进。</p><p>使用 <code>findDOMNode</code> 的“传统”方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">findDOMNode</span>(<span class="variable language_">this</span>).<span class="title function_">scrollIntoView</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐的方式是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span> = <span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">current</span>.<span class="title function_">scrollIntoView</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.node&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="23-为什么-Strings-Refs-被遗弃了？"><a href="#23-为什么-Strings-Refs-被遗弃了？" class="headerlink" title="23. 为什么 Strings Refs 被遗弃了？"></a>23. 为什么 Strings Refs 被遗弃了？</h2><p>如果你以前使用过 React，那么你可能会熟悉一个较旧的 API，其中的<code>ref</code> 属性是一个字符串，例如 <code>ref = &#123;textInput&#39;&#125;</code>，并且 DOM 节点作为<code>this.refs.textInput</code> 访问。我们建议你不要这样做，因为 String 引用有以下问题，并且被认为是旧版的。字符串引用已经在 <strong>React v16 中被删除</strong>。</p><ol><li><p>他们迫使 React 跟踪当前正在执行的组件。这是有问题的，因为它使 React 模块成为有状态的，并因此在打包 React 模块时冲突而引起奇怪的错误。</p></li><li><p>它们是“不可组合的” — 如果库在传递的子项上放置了引用，则用户不能在其上放置其他引用。回调引用完全可以组合。</p></li><li><p>他们不能和静态分析工具配合（比如 Flow）。Flow 无法猜测出框架 <code>this.refs</code> 上出现的字符串引用及其类型（可能不同）。 回调引用对静态分析更友好。</p></li><li><p>它无法像大多数人期望的那样使用“渲染回调”模式（例如）</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  renderRow = <span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// This won&#x27;t work. Ref will get attached to DataTable rather than MyComponent:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;</span>&#x27;<span class="attr">input-</span>&#x27; + <span class="attr">index</span>&#125; /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This would work though! Callback refs are awesome.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;input</span> =&gt;</span> (this[&#x27;input-&#x27; + index] = input)&#125; /&gt;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">DataTable</span> <span class="attr">data</span>=<span class="string">&#123;this.props.data&#125;</span> <span class="attr">renderRow</span>=<span class="string">&#123;this.renderRow&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="24-虚拟-DOM-是什么？"><a href="#24-虚拟-DOM-是什么？" class="headerlink" title="24. 虚拟 DOM 是什么？"></a>24. 虚拟 DOM 是什么？</h2><p>_Virtual DOM_（VDOM）是<em>Real DOM</em>的内存表示形式。 UI 的表示形式保留在内存中，并与“真实” DOM 同步。 这是在调用渲染函数和在屏幕上显示元素之间发生的一步。 这整个过程称为 <a href="https://zh-hans.reactjs.org/docs/reconciliation.html">协调</a>。</p><h2 id="25-虚拟-DOM-原理"><a href="#25-虚拟-DOM-原理" class="headerlink" title="25. 虚拟 DOM 原理"></a>25. 虚拟 DOM 原理</h2><p>虚拟 DOM 工作原理只有三个简单的步骤。</p><ol><li>无论何时任何基础数据发生更改，整个 UI 都将以虚拟 DOM 表现形式重新呈现。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f8a99a43f7049feb7806a1bd54e5929~tplv-k3u1fbpfcp-zoom-1.image" alt="vdom"></p><ol start="2"><li>然后，计算先前的 DOM 表现形式与新的 DOM 表现形式之间的差异。</li></ol><p><img src="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom2.png" alt="vdom2"></p><ol start="3"><li>一旦完成计算，将只会更新内容真正改变的那部分真是 DOM。</li></ol><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461ba77627524f96b2bf270c1935b969~tplv-k3u1fbpfcp-zoom-1.image" alt="vdom3"></p><h2 id="26-Shadow-DOM-和-Virtual-DOM-有什么区别？"><a href="#26-Shadow-DOM-和-Virtual-DOM-有什么区别？" class="headerlink" title="26. Shadow DOM 和 Virtual DOM 有什么区别？"></a>26. Shadow DOM 和 Virtual DOM 有什么区别？</h2><p>Shadow DOM 是一种浏览器技术，主要用于确定 web components 中的变量和 CSS。Virtual DOM 是由浏览器 API 之上的 JavaScript 库实现的概念。</p><h2 id="27-React-Fiber-是什么"><a href="#27-React-Fiber-是什么" class="headerlink" title="27. React Fiber 是什么?"></a>27. React Fiber 是什么?</h2><p>Fiber 是 React v16 中新的 <a href="https://zh-hans.reactjs.org/docs/reconciliation.html">协调</a> 引擎或核心算法的重新实现。React Fiber 的目标是提高其在动画、布局、手势、暂停、中止或重用工作的能力，以及为不同类型的更新分配优先级等方面的适用性和新的并发原语。</p><h2 id="28-React-Fiber-的主要设计目的是什么？"><a href="#28-React-Fiber-的主要设计目的是什么？" class="headerlink" title="28. React Fiber 的主要设计目的是什么？"></a>28. React Fiber 的主要设计目的是什么？</h2><p>React Fiber 的目标是提高其对动画、布局和手势等领域的适用性。它的 headline 功能是<strong>增量渲染</strong>：能够将渲染工作拆分为多个块并将其分布到多个帧中。</p><h2 id="29-受控组件是什么？"><a href="#29-受控组件是什么？" class="headerlink" title="29. 受控组件是什么？"></a>29. 受控组件是什么？</h2><p>在用户输入后能够控制表单中输入元素的组件被称为“受控组件”，比如每一个状态概念都将有一个相关的处理函数</p><p>例如下面的例子中，为了将名字转换为全大写，我们使用 <code>handleChange</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>.<span class="title function_">toUpperCase</span>()&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="30-非受控组件是什么？"><a href="#30-非受控组件是什么？" class="headerlink" title="30. 非受控组件是什么？"></a>30. 非受控组件是什么？</h2><p>非受控组件是那些把状态维护在其内部的组件，当你想要获得当前值时需要使用 ref 查询 DOM。这有一点像传统的 HTML。</p><p>在下面的 <code>UserProfile</code> 组件中，<code>name</code> 输入被使用 <code>ref</code> 获取：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserProfile</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;A name was submitted: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;&#x27;Name:&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.input&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="31-createElement-和-cloneElement-的区别是什么？"><a href="#31-createElement-和-cloneElement-的区别是什么？" class="headerlink" title="31. createElement 和 cloneElement 的区别是什么？"></a>31. createElement 和 cloneElement 的区别是什么？</h2><p>JSX 元素将被转换为 <code>React.createElement()</code> 函数以创建 React 元素，这些元素将用于 UI 的对象表示。而 <code>cloneElement</code> 用于克隆元素并将新的 <code>props</code> 传递给它。</p><p><strong>课后扩展：</strong></p><ul><li><a href="https://zh-hans.reactjs.org/docs/react-api.html">React 顶层 API</a></li></ul><h2 id="32-React-中的状态提升是什么？"><a href="#32-React-中的状态提升是什么？" class="headerlink" title="32. React 中的状态提升是什么？"></a>32. React 中的状态提升是什么？</h2><p>当多个组件需要共享相同的变化数据时，建议将共享状态提升到它们最接近的共同祖先。这意味着，如果两个子组件共享来自其父组件的相同数据，则将状态移到父组件，而不是在两个子组件中都保持内部状态。</p><h2 id="33-组件生命周期有哪些不同阶段？"><a href="#33-组件生命周期有哪些不同阶段？" class="headerlink" title="33. 组件生命周期有哪些不同阶段？"></a>33. 组件生命周期有哪些不同阶段？</h2><p>组件生命周期具有三个不同的生命周期阶段。</p><ol><li><strong>Mounting：</strong> 组件已准备好安装在浏览器 DOM 中。这个阶段涵盖了生命周期方法 <code>constructor()</code>、<code>getDerivedStateFromProps()</code>、 <code>render()</code> 和 <code>componentDidMount()</code> 的初始化。</li><li><strong>Updating：</strong> 在此阶段，组件以两种方式进行更新，即发送新 <code>props</code> 和从 <code>setState()</code> 或 <code>forceUpdate()</code> 更新状态。此阶段涵盖了<code>getDerivedStateFromProps()</code>，<code>shouldComponentUpdate()</code>，<code>render()</code> 、<code>getSnapshotBeforeUpdate()</code> 和 <code>componentDidUpdate()</code> 生命周期方法。</li><li><strong>Unmounting：</strong> 在最后一个阶段，不再需要该组件并从浏览器 DOM 上卸载该组件。 这个阶段包括 <code>componentWillUnmount()</code> 生命周期方法。</li></ol><p>值得一提的是，在将更改应用于 DOM 时，React 内部具有阶段性概念。 它们分开如下</p><ol><li><strong>Render：</strong> 该组件将渲染而没有任何副作用。这适用于 Pure 组件，在此阶段，React 可以暂停、中止或重新启动渲染。</li><li><strong>Pre-commit：</strong> 在组件将更改实际应用于 DOM 之前，有一段时间可以让 React 通过 <code>getSnapshotBeforeUpdate()</code> 从 DOM 中读取内容。</li><li><strong>Commit：</strong> React 与 DOM 一起工作并分别执行最终的生命周期：<code>componentDidMount()</code> 用于安装，<code>componentDidUpdate()</code> 用于更新，以及 <code>componentWillUnmount()</code> 用于卸载。</li></ol><p>React 16.3+ (或者 <a href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">在线交互版本</a>)</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fac807b8490c4c11a9630a9f29e467d3~tplv-k3u1fbpfcp-zoom-1.image"></p><p>React 16.3 之前的版本：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33a918a89bdd49c08e80732f5f6af367~tplv-k3u1fbpfcp-zoom-1.image" alt="phases 16.2"></p><h2 id="34-React-生命周期有哪些？"><a href="#34-React-生命周期有哪些？" class="headerlink" title="34. React 生命周期有哪些？"></a>34. React 生命周期有哪些？</h2><p>React 16.3 以前的版本：</p><ul><li><strong>componentWillMount：</strong> 在渲染之前执行，用于根组件中的应用程序级别配置。</li><li><strong>componentDidMount：</strong> 在首次渲染之后执行，所有 AJAX 请求，DOM 或状态更新以及设置事件侦听器都应在此执行。</li><li><strong>componentWillReceiveProps：</strong> 在特定属性更新以触发状态转换时执行。</li><li><strong>shouldComponentUpdate：</strong> 确定是否要更新组件。默认情况下，它返回 <code>true</code>。如果你确定在状态或属性更新后不需要渲染组件，则可以返回 <code>false</code> 值。这是提高性能的好地方，因为如果组件收到新的 <code>props</code>，它可以防止重新渲染。</li><li><strong>componentWillUpdate：</strong> 当有属性或状态改变被<code>shouldComponentUpdate()</code> 确认并返回 <code>true</code> 时，在重新渲染组件之前执行。</li><li><strong>componentDidUpdate：</strong> 通常，它用于响应属性或状态更改来更新 DOM。</li><li><strong>componentWillUnmount：</strong> 它将用于取消任何传出的网络请求，或删除与该组件关联的所有事件侦听器。</li></ul><p>React 16.3+ 版本</p><ul><li><strong>getDerivedStateFromProps：</strong> 在调用 <code>render()</code> 之前被调用，并且在每次渲染中都会被调用。对于需要派生状态的罕见用例，这是存在的。<a href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">如果您需要派生状态</a> 值得一读。</li><li><strong>componentDidMount：</strong> 在首次渲染之后执行，并且所有 AJAX 请求、DOM 或状态更新以及设置事件侦听器都应在此发生。</li><li><strong>shouldComponentUpdate：</strong> 确定是否将更新组件。默认情况下，它返回 <code>true</code>。如果你确定在状态或属性更新后不需要渲染组件，则可以返回 <code>false</code>值。这是提高性能的好地方，因为如果组件接收到新的属性，它可以防止重新渲染。</li><li><strong>getSnapshotBeforeUpdate：</strong> 在将呈现的输出提交给 DOM 之前立即执行。此方法返回的任何值都将传递到 <code>componentDidUpdate()</code> 中。 这对于从 DOM（即滚动位置）捕获信息很有用。</li><li><strong>componentDidUpdate：</strong> 通常，它用于响应属性或状态更改来更新 DOM。如果 <code>shouldComponentUpdate()</code> 返回 <code>false</code>，则不会触发。</li><li><strong>componentWillUnmount：</strong> 它将用于取消任何传出的网络请求，或删除与该组件关联的所有事件侦听器。</li></ul><h2 id="35-高阶组件是什么"><a href="#35-高阶组件是什么" class="headerlink" title="35. 高阶组件是什么"></a>35. 高阶组件是什么</h2><p>高阶组件（HOC）是接收组件并返回新组件的函数。基本上，这是从 React 的组成性质衍生出来的一种模式。</p><p>我们称它们为纯组件，因为它们可以接受任何动态提供的子组件，但是它们不会修改或复制其输入组件中的任何行为。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">higherOrderComponent</span>(<span class="title class_">WrappedComponent</span>);</span><br></pre></td></tr></table></figure><p>HOC 可以用到很多场景中：</p><ol><li>代码重用，逻辑和引导程序抽象。</li><li>渲染劫持。</li><li>状态抽象和操纵。</li><li>props 操作。</li></ol><h2 id="36-如何为-HOC-组件-创建-props-代理？"><a href="#36-如何为-HOC-组件-创建-props-代理？" class="headerlink" title="36. 如何为 HOC 组件 创建 props 代理？"></a>36. 如何为 HOC 组件 创建 props 代理？</h2><p>您可以使用属性代理模式添加或编辑传递给组件的属性，如下所示：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;New Header&#x27;</span>,</span><br><span class="line">        <span class="attr">footer</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">showFeatureX</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">showFeatureY</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>课后扩展：</strong></p><ul><li><a href="https://juejin.cn/post/6844903641074106381">react 高阶组件的代理模式</a></li></ul><h2 id="37-context-是什么？"><a href="#37-context-是什么？" class="headerlink" title="37. context 是什么？"></a>37. context 是什么？</h2><p><code>Context</code> 提供了一种通过组件树传递数据的方法，而不需要一层一层手动传递属性。</p><p>例如，需要由许多组件在应用程序中访问经过身份验证的用户，本地设置首选项，UI 主题等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Provider</span>, <span class="title class_">Consumer</span> &#125; = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultValue);</span><br></pre></td></tr></table></figure><h2 id="38-什么是-children-属性？"><a href="#38-什么是-children-属性？" class="headerlink" title="38. 什么是 children 属性？"></a>38. 什么是 children 属性？</h2><p><code>Children</code> 是一个 prop（<code>this.props.children</code>），允许你将组件作为数据传递给其他组件，就像你使用的任何其他 prop 一样。放置在组件的开始标记和结束标记之间的组件树将作为 <code>children</code> 道具传递给该组件。</p><p>React API 中有许多方法可作为该属性。其中包括 <code>React.Children.map</code>、<code>React.Children.forEach</code>，<code>React.Children.count</code>、<code>React.Children.only</code> 和 <code>React.Children.toArray</code>。</p><p>children 的简单用法如下所示：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyDiv</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyDiv</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#x27;Hello&#x27;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#x27;World&#x27;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">MyDiv</span>&gt;</span></span>,</span><br><span class="line">  node,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="39-React-中如何写注释？"><a href="#39-React-中如何写注释？" class="headerlink" title="39. React 中如何写注释？"></a>39. React 中如何写注释？</h2><p>React JSX 中的注释和 JavaScript 的多行注释很像，但是用大括号括起来。</p><p><strong>单行注释：</strong></p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;<span class="comment">/* 这里是单行注释 */</span>&#125;</span><br><span class="line">  &#123;<span class="string">`Welcome <span class="subst">$&#123;user&#125;</span>, let&#x27;s play React`</span>&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p><strong>多行注释：</strong></p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;<span class="comment">/* Multi-line comments for more than</span></span><br><span class="line"><span class="comment">   one line */</span>&#125;</span><br><span class="line">  &#123;<span class="string">`Welcome <span class="subst">$&#123;user&#125;</span>, let&#x27;s play React`</span>&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><h2 id="40-在-constructor-中给-super-函数传递-props-的目的是什么？"><a href="#40-在-constructor-中给-super-函数传递-props-的目的是什么？" class="headerlink" title="40. 在 constructor 中给 super 函数传递 props 的目的是什么？"></a>40. 在 constructor 中给 <code>super</code> 函数传递 props 的目的是什么？</h2><p>一个子类构造器在 <code>super()</code> 方法调用之前是无法拿到 <code>this</code> 引用的。这同样也适用于 ES6 中的 sub-classes。调用 <code>super()</code> 时传递 props 的主要是为了在子类的构造器中访问 <code>this.props</code>。</p><p><strong>传递 props：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>); <span class="comment">// 打印 &#123; name: &#x27;John&#x27;, age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不传递 props：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>); <span class="comment">// 打印 undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是 props 参数依然可以访问</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props); <span class="comment">// 打印 &#123; name: &#x27;John&#x27;, age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在 constructor 之外没有影响</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>); <span class="comment">// 打印 &#123; name: &#x27;John&#x27;, age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码片段揭示了 <code>this.props</code> 仅在构造函数中有所不同。在构造函数外部表现将是相同的。</p><p>更多信息可以参考 <a href="https://overreacted.io/zh-hans/why-do-we-write-super-props/">为什么我们要写 super(props) ？</a></p><p>大多数场景中，我们建议使用受控组件来代替表单组件。</p><h2 id="41-协调（reconciliation）是什么？"><a href="#41-协调（reconciliation）是什么？" class="headerlink" title="41. 协调（reconciliation）是什么？"></a>41. 协调（reconciliation）是什么？</h2><p>当一个组件的 props 或 state 发生变化时，React 通过比较新返回的元素和之前渲染的元素来决定是否有必要进行实际的 DOM 更新。当它们不相等时，React 将更新 DOM。这个过程被称为 _协调（reconciliation）_。</p><h2 id="42-如何用一个动态键名来设置状态？"><a href="#42-如何用一个动态键名来设置状态？" class="headerlink" title="42. 如何用一个动态键名来设置状态？"></a>42. 如何用一个动态键名来设置状态？</h2><p>如果你使用 ES6 或 Babel 转码器来转换你的 JSX 代码，那么你可以用计算属性命名完成。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleInputChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; [event.<span class="property">target</span>.<span class="property">id</span>]: event.<span class="property">target</span>.<span class="property">value</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="43-每次组件渲染时，函数被调用的常见错误是什么？"><a href="#43-每次组件渲染时，函数被调用的常见错误是什么？" class="headerlink" title="43. 每次组件渲染时，函数被调用的常见错误是什么？"></a>43. 每次组件渲染时，函数被调用的常见错误是什么？</h2><p>你需要确保在传递函数作为参数时，没有调用该函数。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 错误❌： handleClick 被调用而不是作为引用被传入</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick()&#125;</span>&gt;</span>&#123;&#x27;Click Me&#x27;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>取而代之的是传递函数本身，不加圆括号。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 正确：handleClick 是作为一个引用传递的!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;&#x27;Click Me&#x27;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="44-lazy-函数是否支持命名导出？"><a href="#44-lazy-函数是否支持命名导出？" class="headerlink" title="44. lazy 函数是否支持命名导出？"></a>44. lazy 函数是否支持命名导出？</h2><p>不，目前 <code>React.lazy</code> 函数只支持默认出口。如果你想导入被命名导出的模块，你可以创建一个中间模块，将其作为默认出口。这也保证了摇树的工作，不会拉取未使用的组件。</p><p>让我们来看看一个导出多个命名组件的组件文件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MoreComponents.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SomeComponent</span> = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">UnusedComponent</span> = <span class="comment">/* ... */</span>;</span><br></pre></td></tr></table></figure><p>并在一个中间文件 <code>IntermediateComponent.js</code> 中重新导出 <code>MoreComponents.js</code> 组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntermediateComponent.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">SomeComponent</span> <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./MoreComponents.js&#x27;</span>;</span><br></pre></td></tr></table></figure><p>现在你可以使用下面的 lazy 函数导入该模块。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; lazy &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SomeComponent</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./IntermediateComponent.js&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="45-为什么-React-使用-className-而不是-class-属性？"><a href="#45-为什么-React-使用-className-而不是-class-属性？" class="headerlink" title="45. 为什么 React 使用 className 而不是 class 属性？"></a>45. 为什么 React 使用 <code>className</code> 而不是 <code>class</code> 属性？</h2><p><code>class</code> 是 JavaScript 的一个关键字，而 JSX 是 JavaScript 的一个扩展。这就是为什么 React 使用 <code>className</code> 而不是 <code>class</code> 的主要原因。传递一个字符串作为 <code>className</code> prop。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">menu</span> <span class="attr">navigation-menu</span>&#x27;&#125;&gt;</span>&#123;&#x27;Menu&#x27;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="46-片段（fragments）是什么？"><a href="#46-片段（fragments）是什么？" class="headerlink" title="46. 片段（fragments）是什么？"></a>46. 片段（fragments）是什么？</h2><p>这是 React 中常见的模式，用于一个组件返回多个元素。片段让你可以对一个 children 的列表进行分组，而无需在 DOM 中添加额外的节点。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildA</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildB</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildC</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里还有一个短语法可以用，但是很多工具不支持：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildA</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildB</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildC</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="47-为什么片段（fragments）比-div-容器要好？"><a href="#47-为什么片段（fragments）比-div-容器要好？" class="headerlink" title="47. 为什么片段（fragments）比 div 容器要好？"></a>47. 为什么片段（fragments）比 div 容器要好？</h2><ol><li>片段的速度更快一些，并且由于没有创建额外的 DOM 节点而使用更少的内存。这只有在非常大和深的树上才会体现出真正的好处。</li><li>一些 CSS 机制，如 Flexbox 和 CSS Grid 有一个特殊的父子关系，在中间添加 div 会使其难以保持所需的布局。</li><li>DOM 检查器不那么杂乱。</li></ol><h2 id="48-什么是-React-中的传递门（Portal）？"><a href="#48-什么是-React-中的传递门（Portal）？" class="headerlink" title="48. 什么是 React 中的传递门（Portal）？"></a>48. 什么是 React 中的传递门（Portal）？</h2><p>传递门是一种推荐的方式，可以将子节点渲染到父组件的 DOM 层次结构之外的 DOM 节点中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(child, container);</span><br></pre></td></tr></table></figure><p>第一个参数是任何可渲染的 React children，比如一个元素、字符串或片段。第二个参数是一个 DOM 元素。</p><h2 id="49-什么是无状态组件"><a href="#49-什么是无状态组件" class="headerlink" title="49. 什么是无状态组件?"></a>49. 什么是无状态组件?</h2><p>如果行为是独立于其状态的，那么它可以是一个无状态组件。你可以使用函数或类来创建无状态组件。但除非你需要在你的组件中使用生命周期钩子，否则你应该选择函数组件。如果你决定在这里使用函数组件，会有很多好处；它们易于编写、理解和测试，速度稍快，而且你可以完全避免使用 <code>this</code> 关键字。</p><h2 id="50-什么是状态组件"><a href="#50-什么是状态组件" class="headerlink" title="50. 什么是状态组件?"></a>50. 什么是状态组件?</h2><p>如果一个组件的行为依赖于该组件的状态（state），那么它可以被称为有状态的组件。这些有状态的组件总是类组件，并且有一个在构造器（<code>constructor</code>）中被初始化的状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 也可以使用类字段语法</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>React 16.8 更新：</strong></p><p>Hooks 让你在不写类的情况下使用状态和其他 React 功能。</p><p>等效的函数组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// JSX</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="51-如何在-React-中对-props-进行验证？"><a href="#51-如何在-React-中对-props-进行验证？" class="headerlink" title="51. 如何在 React 中对 props 进行验证？"></a>51. 如何在 React 中对 props 进行验证？</h2><p>当应用程序运行在开发模式时，React 会自动检查我们在组件上设置的所有 props，以确保它们具有正确的类型。如果类型不正确，React 会在控制台生成警告信息。由于对性能的影响，它在生产模式中被禁用。必需 props 是用 <code>isRequired</code> 定义的。</p><p>预定义的 props 类型集合。</p><ol><li><code>PropTypes.number</code></li><li><code>PropTypes.string</code></li><li><code>PropTypes.array</code></li><li><code>PropTypes.object</code></li><li><code>PropTypes.func</code></li><li><code>PropTypes.node</code></li><li><code>PropTypes.element</code></li><li><code>PropTypes.bool</code></li><li><code>PropTypes.symbol</code></li><li><code>PropTypes.any</code></li></ol><p>我们可以为 <code>User</code> 组件定义 <code>propTypes</code>，如下所示。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequired</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Welcome, $&#123;this.props.name&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;`Age, $&#123;this.props.age&#125;`&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：在 React v15.5 中，<code>PropTypes</code> 被从 <code>React.PropTypes</code> 移到 <code>prop-types</code>库中。</p></blockquote><p>等效的函数式组件：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Welcome, $&#123;this.props.name&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;`Age, $&#123;this.props.age&#125;`&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">User</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequired</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="52-React-的优势是什么？"><a href="#52-React-的优势是什么？" class="headerlink" title="52. React 的优势是什么？"></a>52. React 的优势是什么？</h2><p>以下是 React的 主要优势。</p><ol><li>通过虚拟 DOM 提高应用程序的性能。</li><li>JSX 使代码易于阅读和编写。</li><li>它在客户端和服务器端都能进行渲染（SSR）。</li><li>易于与框架（Angular, Backbone）集成，因为它只是一个视图库。</li><li>使用 Jest 等工具容易编写单元和集成测试。</li></ol><h2 id="53-React-的局限性是什么？"><a href="#53-React-的局限性是什么？" class="headerlink" title="53. React 的局限性是什么？"></a>53. React 的局限性是什么？</h2><p>除了优点之外，React 也有一些限制。</p><ol><li>React 只是一个视图库，不是一个完整的框架。</li><li>对于刚接触网络开发的初学者来说，有一个学习曲线。</li><li>将 React 整合到传统的 MVC 框架中需要一些额外的配置。</li><li>代码的复杂性随着内联模板和 JSX 的增加而增加。</li><li>太多的小组件导致了过度工程化或模板化。</li></ol><h2 id="54-什么是-React-v16-中的错误边界（Error-Boundary）？"><a href="#54-什么是-React-v16-中的错误边界（Error-Boundary）？" class="headerlink" title="54. 什么是 React v16 中的错误边界（Error Boundary）？"></a>54. 什么是 React v16 中的错误边界（Error Boundary）？</h2><p>错误边界是指在其子组件树的任何地方捕获 JavaScript 错误的组件，记录这些错误，并显示一个后备 UI ，而不是崩溃的组件树。</p><p>如果一个类组件定义了一个新的生命周期方法 <code>componentDidCatch(error, info)</code> 或 <code>static getDerivedStateFromError()</code> ，它就成为一个错误边界。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="comment">// 你也可以把错误记录到一个错误报告服务中去</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, info)。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新状态，以便下次渲染时显示回退的用户界面。</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// 你可以渲染任何自定义的回退用户界面</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#x27;Something went wrong.&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后把它作为一个普通的组件使用。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ErrorBoundary</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyWidget</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">ErrorBoundary</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="55-React-v15-中是如何处理错误边界的？"><a href="#55-React-v15-中是如何处理错误边界的？" class="headerlink" title="55. React v15 中是如何处理错误边界的？"></a>55. React v15 中是如何处理错误边界的？</h2><p>React v15 使用 <code>unstable_handleError</code> 方法为错误边界提供了非常基本的支持。在 React v16 中，它已经被重新命名为 <code>componentDidCatch</code>。</p><h2 id="56-静态类型检查的推荐方式是什么？"><a href="#56-静态类型检查的推荐方式是什么？" class="headerlink" title="56. 静态类型检查的推荐方式是什么？"></a>56. 静态类型检查的推荐方式是什么？</h2><p>通常我们使用 PropTypes 库（<code>React.PropTypes</code> 从 React v15.5 开始转移到 <code>prop-types</code> 包）来进行 React 应用中的类型检查。对于大型代码库，建议使用静态类型检查器，如 Flow 或 TypeScript，在编译时进行类型检查并提供自动补全功能。</p><h2 id="57-react-dom-包有什么用？"><a href="#57-react-dom-包有什么用？" class="headerlink" title="57. react-dom 包有什么用？"></a>57. <code>react-dom</code> 包有什么用？</h2><p><code>react-dom</code> 包提供了 DOM 特定的方法，可以在你的应用程序的顶层使用。大多数组件不需要使用此模块。这个包的一些方法是：</p><ol><li><code>render()</code></li><li><code>hydrate()</code></li><li><code>unmountComponentAtNode()</code></li><li><code>findDOMNode()</code></li><li><code>createPortal()</code></li></ol><h2 id="58-react-dom-的-render-方法的目的是什么？"><a href="#58-react-dom-的-render-方法的目的是什么？" class="headerlink" title="58. react-dom 的 render 方法的目的是什么？"></a>58. <code>react-dom</code> 的 render 方法的目的是什么？</h2><p>此方法用于将 React 元素渲染到提供的容器中的 DOM 中，并返回对组件的引用。如果 React 元素之前已渲染到容器中，它将对其执行更新，并且仅在必要时更改 DOM 以反映最新更改。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(element, container[, callback])</span><br></pre></td></tr></table></figure><p>如果提供了可选的回调，它将在组件渲染或更新后执行。</p><h2 id="59-什么是-ReactDOMServer？"><a href="#59-什么是-ReactDOMServer？" class="headerlink" title="59. 什么是 ReactDOMServer？"></a>59. 什么是 ReactDOMServer？</h2><p><code>ReactDOMServer</code> 对象使你能够将组件呈现为静态标记（通常用于节点服务器）。该对象主要用于服务器端渲染（SSR）。以下方法可用于服务器和浏览器环境：</p><ol><li><code>renderToString()</code></li><li><code>renderToStaticMarkup()</code></li></ol><p>例如，你通常运行基于 Node 的 Web 服务器（如 Express、Hapi 或 Koa），然后调用 <code>renderToString</code> 将根组件渲染为字符串，然后将其作为响应发送。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Express</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyPage</span> <span class="keyword">from</span> <span class="string">&#x27;./MyPage&#x27;</span>;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&#x27;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&#x27;&lt;div id=&quot;content&quot;&gt;&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="title function_">renderToString</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">MyPage</span> /&gt;</span></span>));</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&#x27;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="60-如何在-React-中使用-innerHTML？"><a href="#60-如何在-React-中使用-innerHTML？" class="headerlink" title="60. 如何在 React 中使用 innerHTML？"></a>60. 如何在 React 中使用 innerHTML？</h2><p><code>dangerouslySetInnerHTML</code> 属性是 React 在浏览器 DOM 中使用 <code>innerHTML</code> 的替代品。就像 <code>innerHTML</code> 一样，考虑到跨站点脚本 (XSS) 攻击，使用此属性是有风险的。你只需要传递一个 <code>__html</code> 对象作为键和 HTML 文本作为值。</p><p>在这个例子中，MyComponent 使用 <code>dangerouslySetInnerHTML</code> 属性来设置 HTML 标记：</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMarkup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">__html</span>: <span class="string">&#x27;First &amp;middot; Second&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;createMarkup()&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="61-如何在-React-使用样式？"><a href="#61-如何在-React-使用样式？" class="headerlink" title="61. 如何在 React 使用样式？"></a>61. 如何在 React 使用样式？</h2><p><code>style</code> 属性接受一个小驼峰命名法属性的 JavaScript 对象，而不是一个 CSS 字符串。这与 DOM 风格的 JavaScript 属性一致，更有效率，并能防止 XSS 安全漏洞。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divStyle = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">  <span class="attr">backgroundImage</span>: <span class="string">`url(<span class="subst">$&#123;imgUrl&#125;</span>)`</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HelloWorldComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;divStyle&#125;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>样式键名是符合驼峰命名法的，以便与在 JavaScript 中访问 DOM 节点的属性相一致（例如 <code>node.style.backgroundImage</code>）。</p><h2 id="62-事件在-React-中有何不同？"><a href="#62-事件在-React-中有何不同？" class="headerlink" title="62. 事件在 React 中有何不同？"></a>62. 事件在 React 中有何不同？</h2><p>Handling events in React elements has some syntactic differences:</p><p>在 React 元素上处理事件有一些语法上的不同：</p><ol><li>React 事件处理程序使用小驼峰命名，而不是小写。</li><li>使用 JSX，你传递一个函数作为事件处理程序，而不是一个字符串。</li></ol><h2 id="63-如果你在构造函数中使用-setState-，会发生什么？"><a href="#63-如果你在构造函数中使用-setState-，会发生什么？" class="headerlink" title="63. 如果你在构造函数中使用 setState()，会发生什么？"></a>63. 如果你在构造函数中使用 <code>setState()</code>，会发生什么？</h2><p>当你使用 <code>setState()</code> 时，除了分配给对象的状态外，React 还重新渲染组件和它的所有子组件。你会得到这样的错误：只能更新一个已挂载或正在挂载的组件。所以我们需要使用 <code>this.state</code> 来初始化构造函数中的变量。</p><h2 id="64-索引作为键的影响是什么？"><a href="#64-索引作为键的影响是什么？" class="headerlink" title="64. 索引作为键的影响是什么？"></a>64. 索引作为键的影响是什么？</h2><p>键应该是稳定的、可预测的和唯一的，这样 React 就可以跟踪元素。</p><p>在下面的代码片段中，每个元素的键都是基于索引的，而不是与被表示的数据相联系。这限制了 React 可以做的优化。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos.<span class="title function_">map</span>(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Todo</span> &#123;<span class="attr">...todo</span>&#125; <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> /&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用元素数据作为唯一键，假设 <code>todo.id</code> 在这个列表中是唯一的，并且是稳定的，React 将能够对元素进行重新排序，而不需要像以前那样重新计算它们。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos.<span class="title function_">map</span>(<span class="function"><span class="params">todo</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Todo</span> &#123;<span class="attr">...todo</span>&#125; <span class="attr">key</span>=<span class="string">&#123;todo.id&#125;</span> /&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="65-在-componentWillMount-方法中使用-setState-真的好吗"><a href="#65-在-componentWillMount-方法中使用-setState-真的好吗" class="headerlink" title="65. 在 componentWillMount() 方法中使用 setState 真的好吗?"></a>65. 在 <code>componentWillMount()</code> 方法中使用 <code>setState</code> 真的好吗?</h2><p>是的，在 <code>componentWillMount()</code> 方法中使用 <code>setState()</code> 是安全的。但同时，建议避免在<code>componentWillMount()</code> 生命周期方法中进行异步初始化。<code>componentWillMount()</code> 在挂载发生前立即被调用。它在 <code>render()</code> 之前被调用，因此在这个方法中设置状态不会触发重新渲染。避免在这个方法中引入任何副作用或订阅。我们需要确保组件初始化的异步调用发生在 <code>componentDidMount()</code> 而不是 <code>componentWillMount()</code>。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  axios.<span class="title function_">get</span>(<span class="string">`api/todos`</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">messages</span>: [...result.<span class="property">data</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="66-如果你在初始状态下使用-props，会发生什么？"><a href="#66-如果你在初始状态下使用-props，会发生什么？" class="headerlink" title="66. 如果你在初始状态下使用 props，会发生什么？"></a>66. 如果你在初始状态下使用 props，会发生什么？</h2><p>如果组件上的 props 被改变而组件没有被刷新，新的 props 值将永远不会被显示，因为构造函数永远不会更新组件的当前状态。来自 props 的状态初始化只在组件第一次被创建时运行。</p><p>下面这个组件就不会显示更新的输入值。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">records</span>: [],</span><br><span class="line">      <span class="attr">inputValue</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">inputValue</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.inputValue&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 render 方法中使用 props 将更新数值。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">record</span>: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.inputValue&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="67-你如何有条件地渲染组件？"><a href="#67-你如何有条件地渲染组件？" class="headerlink" title="67. 你如何有条件地渲染组件？"></a>67. 你如何有条件地渲染组件？</h2><p>在某些情况下，你想根据一些状态来渲染不同的组件。JSX 不渲染 <code>false</code> 或 <code>undefined</code>，所以你可以使用条件性短路来渲染你的组件的某一部分，只有当某个条件为真时。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params">&#123; name, address &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;address &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;address&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>如果你需要一个 <code>if-else</code> 条件，则使用三元运算符。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params">&#123; name, address &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;address ? <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;address&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> : <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#x27;Address is not available&#x27;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="68-为什么我们在-DOM-元素上传递-props-时需要谨慎？"><a href="#68-为什么我们在-DOM-元素上传递-props-时需要谨慎？" class="headerlink" title="68. 为什么我们在 DOM 元素上传递 props 时需要谨慎？"></a>68. 为什么我们在 DOM 元素上传递 props 时需要谨慎？</h2><p>当我们传递 props 时，我们会遇到添加未知的 HTML 属性的风险，这是一个不好的做法。相反，我们可以使用带有 <code>...rest</code> 操作符的 prop 解构，所以它将只添加需要的 prop。</p><p>比如说。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentA</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ComponentB</span> <span class="attr">isDisplay</span>=<span class="string">&#123;true&#125;</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">componentStyle</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentB</span> = (<span class="params">&#123; isDisplay, ...domProps &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &#123;<span class="attr">...domProps</span>&#125;&gt;</span>&#123;&#x27;ComponentB&#x27;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="69-如何在-React-中使用装饰器？"><a href="#69-如何在-React-中使用装饰器？" class="headerlink" title="69. 如何在 React 中使用装饰器？"></a>69. 如何在 React 中使用装饰器？</h2><p>你可以对你的类组件进行装饰，这与将组件传入一个函数是一样的。<strong>装饰器</strong>是修改组件功能的灵活和可读的方式。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_">setTitle</span>(<span class="string">&#x27;Profile&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Profile</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">title 是一个字符串，将被设置为文档标题。WrappedComponent 是我们的装饰器在以下情况下会收到的东西直接放在一个组件类上面时，我们的装饰器会收到这样的信息，如上面的例子所示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">setTitle</span> = title =&gt; <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 装饰器是一个没有进入 ES7 的功能，但目前是一个第二阶段的建议。</p><h2 id="70-如何-memo-化一个组件？"><a href="#70-如何-memo-化一个组件？" class="headerlink" title="70. 如何 memo 化一个组件？"></a>70. 如何 memo 化一个组件？</h2><p>有一些可用的缓存库，可以用于函数组件。</p><p>例如，<code>moize</code> 库可以在另一个组件中对组件进行 memo 化。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moize <span class="keyword">from</span> <span class="string">&#x27;moize&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Component</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Component&#x27;</span>; <span class="comment">// 本模块导出一个非 memo 组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MemoizedFoo</span> = moize.<span class="title function_">react</span>(<span class="title class_">Component</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Consumer</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#x27;I will memoize the following entry:&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">MemoizedFoo</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>更新：</strong> 从 React v16.6.0 开始，我们有一个 <code>React.memo</code>。它提供了一个更高阶的组件，除非 props 发生变化，否则会将组件缓存。要使用它，只需在使用前用 <code>React.memo</code> 包住组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MemoComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="keyword">function</span> <span class="title function_">MemoComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">/* render using props */</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">MyFunctionComponent</span>);</span><br></pre></td></tr></table></figure><h2 id="71-你如何实现服务器端渲染或SSR？"><a href="#71-你如何实现服务器端渲染或SSR？" class="headerlink" title="71. 你如何实现服务器端渲染或SSR？"></a>71. 你如何实现服务器端渲染或SSR？</h2><p>React 已经具备了在 Nod e服务器上处理渲染的能力。有一个特殊版本的 DOM 渲染器，它与客户端的模式相同。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOMServer</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOMServer</span>.<span class="title function_">renderToString</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>)。</span><br></pre></td></tr></table></figure><p>这个方法将把常规的 HTML 输出为一个字符串，然后可以作为服务器响应的一部分放在页面主体内。在客户端，React 检测到预渲染的内容，并无缝地衔接该内容。</p><h2 id="72-如何在-React-中启用生产模式？"><a href="#72-如何在-React-中启用生产模式？" class="headerlink" title="72. 如何在 React 中启用生产模式？"></a>72. 如何在 React 中启用生产模式？</h2><p>你应该使用 Webpack 的 <code>DefinePlugin</code> 方法来设置 <code>NODE_ENV</code> 为 <code>production</code>，通过它来剥离诸如 propType 验证和额外警告的东西。除此之外，如果你对代码进行最小化处理，例如 Uglify 的无效代码消除法，剥离出只用于开发的代码和注释，这将极大地减少你的包的大小。</p><h2 id="73-什么是-CRA-以及它的好处？"><a href="#73-什么是-CRA-以及它的好处？" class="headerlink" title="73. 什么是 CRA 以及它的好处？"></a>73. 什么是 CRA 以及它的好处？</h2><p><code>create-react-app</code> CLI 工具允许你快速创建和运行React应用程序，无需配置步骤。</p><p>让我们使用 CRA 创建 Todo 应用程序。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g create-react-app</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建新项目</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">create-react-app todo-app</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> todo-app</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建、测试、运行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm run build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm run <span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm start</span></span><br></pre></td></tr></table></figure><p>它包括我们建立一个 React 应用程序所需要的一切。</p><ol><li>支持 React、JSX、ES6 和 Flow 语法。</li><li>超越 ES6 的语言额外功能，如对象传播操作者。</li><li>自动前缀的 CSS，所以你不需要 <code>-webkit-</code> 或其他前缀。</li><li>一个快速的交互式单元测试运行器，内置支持覆盖率报告。</li><li>一个实时的开发服务器，对常见的错误发出警告。</li><li>一个构建脚本，用于捆绑 JS、CSS 和图片，并提供哈希和源码图。</li></ol><h2 id="74-安装中的生命周期方法的顺序是什么？"><a href="#74-安装中的生命周期方法的顺序是什么？" class="headerlink" title="74. 安装中的生命周期方法的顺序是什么？"></a>74. 安装中的生命周期方法的顺序是什么？</h2><p>当一个组件的实例被创建并插入到 DOM 中时，生命周期方法按以下顺序被调用。</p><ol><li><code>constructor()</code></li><li><code>static getDerivedStateFromProps()</code></li><li><code>render()</code></li><li><code>componentDidMount()</code></li></ol><h2 id="75-在-React-v16-中，有哪些生命周期方法将被废弃？"><a href="#75-在-React-v16-中，有哪些生命周期方法将被废弃？" class="headerlink" title="75. 在 React v16 中，有哪些生命周期方法将被废弃？"></a>75. 在 React v16 中，有哪些生命周期方法将被废弃？</h2><p>以下生命周期方法将是不安全的编码做法，在异步渲染中会出现更多问题。</p><ol><li><code>componentWillMount()</code></li><li><code>componentWillReceiveProps()</code></li><li><code>componentWillUpdate()</code></li></ol><p>从 React v16.3 开始，这些方法被别名为 <code>UNSAFE_</code> 前缀，未加前缀的版本将在 React v17 中被移除。</p><h2 id="76-getDerivedStateFromProps-生命周期方法的目的是什么？"><a href="#76-getDerivedStateFromProps-生命周期方法的目的是什么？" class="headerlink" title="76. getDerivedStateFromProps() 生命周期方法的目的是什么？"></a>76. <code>getDerivedStateFromProps()</code> 生命周期方法的目的是什么？</h2><p>新的静态的 <code>getDerivedStateFromProps()</code> 生命周期方法在一个组件实例化后以及重新渲染前被调用。它可以返回一个对象来更新状态，也可以返回 <code>null</code> 来表示新的 props 不需要任何状态更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">props, state</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个生命周期方法与 <code>componentDidUpdate()</code> 一起涵盖了 <code>componentWillReceiveProps()</code> 的所有用例。</p><h2 id="77-getSnapshotBeforeUpdate-生命周期方法的目的是什么？"><a href="#77-getSnapshotBeforeUpdate-生命周期方法的目的是什么？" class="headerlink" title="77. getSnapshotBeforeUpdate() 生命周期方法的目的是什么？"></a>77. <code>getSnapshotBeforeUpdate()</code> 生命周期方法的目的是什么？</h2><p>新的 <code>getSnapshotBeforeUpdate()</code> 生命周期方法会在 DOM 更新前被调用。这个方法的返回值将作为第三个参数传递给 <code>componentDidUpdate()</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个生命周期方法与 <code>componentDidUpdate()</code> 一起涵盖了 <code>componentWillUpdate()</code> 的所有用例。</p><h2 id="78-Hooks-是否取代了渲染-props-和高阶组件？"><a href="#78-Hooks-是否取代了渲染-props-和高阶组件？" class="headerlink" title="78. Hooks 是否取代了渲染 props 和高阶组件？"></a>78. Hooks 是否取代了渲染 props 和高阶组件？</h2><p>渲染 props 和高阶组件都只渲染一个 children，但在大多数情况下，Hooks 是一种更简单的方式，通过减少树中的嵌套来达到这个目的。</p><h2 id="79-推荐用什么方式来命名组件？"><a href="#79-推荐用什么方式来命名组件？" class="headerlink" title="79. 推荐用什么方式来命名组件？"></a>79. 推荐用什么方式来命名组件？</h2><p>建议通过引用来命名组件，而不是使用 <code>displayName</code>。</p><p>使用 <code>displayName</code> 来命名组件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="attr">displayName</span>: <span class="string">&#x27;TodoApp&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>推荐的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">TodoApp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="80-建议在组件类中方法的排序是什么？"><a href="#80-建议在组件类中方法的排序是什么？" class="headerlink" title="80. 建议在组件类中方法的排序是什么？"></a>80. 建议在组件类中方法的排序是什么？</h2><p>建议从安装到渲染阶段的方法的排序。</p><ol><li><code>static</code> 方法</li><li><code>constructor()</code></li><li><code>getChildContext()</code></li><li><code>componentWillMount()</code></li><li><code>componentDidMount()</code></li><li><code>componentWillReceiveProps()</code></li><li><code>shouldComponentUpdate()</code></li><li><code>componentWillUpdate()</code></li><li><code>componentDidUpdate()</code></li><li><code>componentWillUnmount()</code></li><li>点击处理程序或事件处理程序，如 <code>onClickSubmit()</code> 或 <code>onChangeDescription()</code></li><li>渲染的 getter 方法，如 <code>getSelectReason()</code> 或 <code>getFooterContent()</code></li><li>可选的渲染方法，如 <code>renderNavigation()</code> 或 <code>renderProfilePicture()</code></li><li>render()</li></ol><h2 id="81-什么是切换组件？"><a href="#81-什么是切换组件？" class="headerlink" title="81. 什么是切换组件？"></a>81. 什么是切换组件？</h2><p>切换组件是一个渲染许多组件中的一个组件。我们需要使用对象来将 props 值映射到组件。</p><p>例如，一个切换组件可以根据 <code>page</code> props 显示不同的页面。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">HomePage</span> <span class="keyword">from</span> <span class="string">&#x27;./HomePage&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AboutPage</span> <span class="keyword">from</span> <span class="string">&#x27;./AboutPage&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ServicesPage</span> <span class="keyword">from</span> <span class="string">&#x27;./ServicesPage&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ContactPage</span> <span class="keyword">from</span> <span class="string">&#x27;./ContactPage&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PAGES</span> = &#123;</span><br><span class="line">  <span class="attr">home</span>: <span class="title class_">HomePage</span>,</span><br><span class="line">  <span class="attr">about</span>: <span class="title class_">AboutPage</span>,</span><br><span class="line">  <span class="attr">services</span>: <span class="title class_">ServicesPage</span>,</span><br><span class="line">  <span class="attr">contact</span>: <span class="title class_">ContactPage</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Page</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Handler</span> = <span class="variable constant_">PAGES</span>[props.<span class="property">page</span>] || <span class="title class_">ContactPage</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Handler</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PAGES 对象的键可以在 props 类型中使用，以捕捉开发时间错误。</span></span><br><span class="line"><span class="title class_">Page</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">page</span>: <span class="title class_">PropTypes</span>.<span class="title function_">oneOf</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable constant_">PAGES</span>)).<span class="property">isRequired</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="82-为什么我们需要向-setState-传递一个函数？"><a href="#82-为什么我们需要向-setState-传递一个函数？" class="headerlink" title="82. 为什么我们需要向 setState() 传递一个函数？"></a>82. 为什么我们需要向 <code>setState()</code> 传递一个函数？</h2><p>这背后的原因是，<code>setState()</code> 是一个异步操作。出于性能的考虑，React 会对状态变化进行批处理，所以在调用 <code>setState()</code> 后，状态可能不会立即发生变化。这意味着你在调用 <code>setState()</code> 时不应该依赖当前的状态，因为你不能确定这个状态会是什么。解决办法是将一个函数传递给 <code>setState()</code>，并将之前的状态作为参数。通过这样做，你可以避免由于 <code>setState()</code> 的异步性而导致用户在访问时获得旧的状态值的问题。</p><p>假设初始计数值为 0。在连续三次递增操作后，该值将只递增一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 this.state.count === 0</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="comment">// this.state.count === 1，而不是 3</span></span><br></pre></td></tr></table></figure><p>如果我们给 <code>setState()</code> 传递一个函数，计数就会被正确地递增。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">count</span>: prevState.<span class="property">count</span> + props.<span class="property">increment</span>,</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// this.state.count === 3</span></span><br></pre></td></tr></table></figure><h2 id="83-为什么在-setState-中首选函数而不是对象？"><a href="#83-为什么在-setState-中首选函数而不是对象？" class="headerlink" title="83. 为什么在 setState() 中首选函数而不是对象？"></a>83. 为什么在 <code>setState()</code> 中首选函数而不是对象？</h2><p>React 可以将多个 <code>setState()</code> 的调用批量化为一次更新，以提高性能。因为 <code>this.props</code> 和 <code>this.state</code> 可能被异步更新，你不应该依赖它们的值来计算下一个状态。</p><p>这个计数器的例子将无法按预期更新。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误❌</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">increment</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>首选的方法是用函数而不是对象调用 <code>setState()</code>。该函数将接收先前的状态作为第一个参数，并将应用更新时的 props 作为第二个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确✅</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: prevState.<span class="property">counter</span> + props.<span class="property">increment</span>,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2 id="84-React-中的严格模式是什么？"><a href="#84-React-中的严格模式是什么？" class="headerlink" title="84. React 中的严格模式是什么？"></a>84. React 中的严格模式是什么？</h2><p><code>React.StrictMode</code> 是一个有用的组件，用于暴露应用程序中的潜在问题。就像 <code>&lt;Fragment&gt;</code>，<code>&lt;StrictMode&gt;</code>不会渲染任何额外的 DOM 元素。它为其后代激活了额外的检查和警告。这些检查只适用于开发模式。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ExampleApplication</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">ComponentOne</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">ComponentTwo</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的例子中，严格模式检查只适用于 <code>&lt;ComponentOne&gt;</code> 和 <code>&lt;ComponentTwo&gt;</code> 组件。</p><h2 id="85-为什么-isMounted-是一个反模式，正确的解决方案是什么？"><a href="#85-为什么-isMounted-是一个反模式，正确的解决方案是什么？" class="headerlink" title="85. 为什么 isMounted() 是一个反模式，正确的解决方案是什么？"></a>85. 为什么 <code>isMounted()</code> 是一个反模式，正确的解决方案是什么？</h2><p><code>isMounted()</code> 的主要用例是避免在组件被卸载后调用 <code>setState()</code>，因为它会发出警告。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isMounted</span>()) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在调用 <code>setState()</code> 之前检查 <code>isMounted()</code> 确实可以消除警告，但这也违背了警告的目的。使用 <code>isMounted()</code> 是一种代码异味，因为你检查的唯一原因是你认为你可能在组件卸载后还持有一个引用。</p><p>一个最佳的解决方案是找到在组件卸载后可能调用 <code>setState()</code> 的地方，并修复它们。这种情况通常是由于回调引起的，当一个组件在等待一些数据时，在数据到达之前被卸载。理想情况下，任何回调都应该在 <code>componentWillUnmount()</code> 中取消（在解除挂载之前）。</p><blockquote><p>代码异味 (Code smell)：程序开发领域，代码中的任何可能导致深层次问题的症状都可以叫做代码异味。 通常，在对代码做简短的反馈迭代时，代码异味会暴露出一些深层次的问题，这里的反馈迭代，是指以一种小范围的、可控的方式重构代码。</p></blockquote><h2 id="86-React-中支持哪些指针事件？"><a href="#86-React-中支持哪些指针事件？" class="headerlink" title="86. React 中支持哪些指针事件？"></a>86. React 中支持哪些指针事件？</h2><p>指针事件提供了一个处理所有输入事件的统一方法。在过去，我们有一个鼠标和各自的事件监听器来处理它们，但现在我们有许多设备与拥有鼠标不相关，如带有触摸表面的手机或笔。我们需要记住，这些事件只能在支持 Pointer Events 规范的浏览器中工作。</p><p>以下事件类型现在在 React DOM 中可用。</p><ol><li><code>onPointerDown</code></li><li><code>onPointerMove</code></li><li><code>onPointerUp</code></li><li><code>onPointerCancel</code></li><li><code>onGotPointerCapture</code></li><li><code>onLostPointerCapture</code></li><li><code>onPointerEnter</code></li><li><code>onPointerLeave</code></li><li><code>onPointerOver</code></li><li><code>onPointerOut</code></li></ol><h2 id="87-为什么组件名称要以大写字母开头？"><a href="#87-为什么组件名称要以大写字母开头？" class="headerlink" title="87. 为什么组件名称要以大写字母开头？"></a>87. 为什么组件名称要以大写字母开头？</h2><p>如果你使用 JSX 渲染你的组件，该组件的名称必须以大写字母开头，否则 React 将抛出一个错误，即未识别的标签。这个惯例是因为只有 HTML 元素和 SVG 标签可以以小写字母开头。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 掘金不止，代码不停</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可以定义名称以小写字母开头的组件类，但当它被导入时，它应该是大写字母。在这里，小写就可以了。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myComponent;</span><br></pre></td></tr></table></figure><p>而当导入另一个文件时，它应该以大写字母开始。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent&#x27;</span>;</span><br></pre></td></tr></table></figure><h3 id="关于-React-组件的命名，有哪些例外情况？"><a href="#关于-React-组件的命名，有哪些例外情况？" class="headerlink" title="关于 React 组件的命名，有哪些例外情况？"></a>关于 React 组件的命名，有哪些例外情况？</h3><p>组件名称应以大写字母开头，但这一惯例也有少数例外。带点的小写标签名（属性访问器）仍被认为是有效的组件名。</p><p>例如，下面的标签可以被编译成一个有效的组件。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">obj.component</span> /&gt;</span></span> <span class="comment">// `React.createElement(obj.component)`</span></span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="88-React-v16-中支持自定义-DOM-属性吗？"><a href="#88-React-v16-中支持自定义-DOM-属性吗？" class="headerlink" title="88. React v16 中支持自定义 DOM 属性吗？"></a>88. React v16 中支持自定义 DOM 属性吗？</h2><p>是的，在过去，React 习惯于忽略未知的 DOM 属性。如果你写的 JSX 有一个 React 不认识的属性，React 会直接跳过它。</p><p>例如，让我们看一下下面的属性。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div mycustomattribute=&#123;<span class="string">&#x27;something&#x27;</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>用 React v15 渲染一个空的 div 到 DOM 上。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>在 React v16 中，任何未知的属性最终都会出现在 DOM 中。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">mycustomattribute</span>=<span class="string">&quot;something&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>这对于提供浏览器特定的非标准属性，尝试新的 DOM API，以及与有主见的第三方库集成是非常有用的。</p><h2 id="89-constructor-和-getInitialState-的区别是什么？"><a href="#89-constructor-和-getInitialState-的区别是什么？" class="headerlink" title="89. constructor 和 getInitialState 的区别是什么？"></a>89. constructor 和 getInitialState 的区别是什么？</h2><p>当使用 ES6 类时，你应该在构造函数中初始化状态，而当使用 <code>React.createClass()</code> 时，应该在 <code>getInitialState()</code> 方法中初始化状态。</p><p><strong>使用 ES6 类：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="comment">/* 初始化状态 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>React.createClass()</code>：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="title function_">getInitialState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">/* 初始化状态 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> <code>React.createClass()</code> 在 React v16 中已被废弃并删除。请使用普通的 JavaScript 类来代替。</p><h2 id="90-你能在不调用-setState-的情况下强制一个组件重新渲染吗？"><a href="#90-你能在不调用-setState-的情况下强制一个组件重新渲染吗？" class="headerlink" title="90. 你能在不调用 setState 的情况下强制一个组件重新渲染吗？"></a>90. 你能在不调用 setState 的情况下强制一个组件重新渲染吗？</h2><p>默认情况下，当你的组件的状态或 props 改变时，你的组件会重新渲染。如果你的 <code>render()</code> 方法依赖于其他数据，你可以通过调用 <code>forceUpdate()</code> 告诉 React 该组件需要重新渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.<span class="title function_">forceUpdate</span>(callback);</span><br></pre></td></tr></table></figure><p>建议避免使用 <code>forceUpdate()</code>，只在 <code>render()</code> 中读取<code>this.props</code> 和 <code>this.state</code>。</p><h2 id="91-在-React-中使用-ES6-类的，super-和-super-props-之间有什么区别？"><a href="#91-在-React-中使用-ES6-类的，super-和-super-props-之间有什么区别？" class="headerlink" title="91. 在  React 中使用 ES6 类的，super() 和 super(props) 之间有什么区别？"></a>91. 在  React 中使用 ES6 类的，<code>super()</code> 和 <code>super(props)</code> 之间有什么区别？</h2><p>当你想在 <code>constructor()</code> 中访问 <code>this.props</code> 时，你应该把 props 传给 <code>super()</code> 方法。</p><p><strong>使用 <code>super(props)</code>：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>); <span class="comment">// &#123; name: &#x27;John&#x27;, ... &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 <code>super()</code>：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>constructor()</code> 之外，两者都会显示相同的 <code>this.props</code> 的值。</p><h2 id="92-如何在-JSX-内循环？"><a href="#92-如何在-JSX-内循环？" class="headerlink" title="92. 如何在 JSX 内循环？"></a>92. 如何在 JSX 内循环？</h2><p>你可以简单地使用 <code>Array.prototype.map</code> 与 ES6 箭头函数语法。</p><p>例如，对象的 <code>items</code> 数组被映射成组件的数组。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;tbody&gt;</span><br><span class="line">  &#123;items.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span> <span class="attr">name</span>=<span class="string">&#123;item.name&#125;</span> /&gt;</span></span></span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;/tbody&gt;</span><br></pre></td></tr></table></figure><p>但你不能用 <code>for</code> 循环来迭代。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;tbody&gt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">key</span>=<span class="string">&#123;items[i].id&#125;</span> <span class="attr">name</span>=<span class="string">&#123;items[i].name&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/tbody&gt;</span><br></pre></td></tr></table></figure><p>这是因为 JSX 标签被转换为函数调用，而且你不能在表达式中使用语句。这可能会改变，因为 <code>do</code> 表达式是第一阶段的建议。</p><h2 id="93-你如何在属性引号中访问-props？"><a href="#93-你如何在属性引号中访问-props？" class="headerlink" title="93. 你如何在属性引号中访问 props？"></a>93. 你如何在属性引号中访问 props？</h2><p>React（或 JSX）不支持属性值内的变量插值。下面的表示方法就不能用了。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img className=<span class="string">&quot;image&quot;</span> src=<span class="string">&quot;images/&#123;this.props.image&#125;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>但你可以把任何 JS 表达式放在大括号内作为整个属性值。所以下面的表达式是有效的。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img className=<span class="string">&quot;image&quot;</span> src=&#123;<span class="string">&#x27;images/&#x27;</span> + <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">image</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>使用模板字符串也可以。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img className=<span class="string">&quot;image&quot;</span> src=&#123;<span class="string">`images/<span class="subst">$&#123;<span class="variable language_">this</span>.props.image&#125;</span>`</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><h2 id="94-什么是带-shape-的-React-原型数组？"><a href="#94-什么是带-shape-的-React-原型数组？" class="headerlink" title="94. 什么是带 shape 的 React 原型数组？"></a>94. 什么是带 shape 的 React 原型数组？</h2><p>如果你想把一个对象数组传递给一个具有特定 shape 的组件，那么使用 <code>React.PropTypes.shape()</code> 作为 <code>React.PropTypes.arrayOf()</code> 的一个参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactComponent</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">arrayWithShape</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">arrayOf</span>(</span><br><span class="line">    <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">shape</span>(&#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">      <span class="attr">fontSize</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequired</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ).<span class="property">isRequired</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="95-如何有条件地应用类属性？"><a href="#95-如何有条件地应用类属性？" class="headerlink" title="95. 如何有条件地应用类属性？"></a>95. 如何有条件地应用类属性？</h2><p>你不应该在引号内使用大括号，因为它将被计算为一个字符串。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;btn-panel &#123;this.props.visible ? &#x27;show&#x27; : &#x27;hidden&#x27;&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure><p>相反，你需要把大括号移到外面（别忘了在类名之间包括空格）。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&#123;<span class="string">&#x27;btn-panel &#x27;</span> + (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">visible</span> ? <span class="string">&#x27;show&#x27;</span> : <span class="string">&#x27;hidden&#x27;</span>)&#125;&gt;</span><br></pre></td></tr></table></figure><p>模板字符串也可以使用。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&#123;<span class="string">`btn-panel <span class="subst">$&#123;<span class="variable language_">this</span>.props.visible ? <span class="string">&#x27;show&#x27;</span> : <span class="string">&#x27;hidden&#x27;</span>&#125;</span>`</span>&#125;&gt;</span><br></pre></td></tr></table></figure><h2 id="96-React-和-ReactDOM-之间有什么区别？"><a href="#96-React-和-ReactDOM-之间有什么区别？" class="headerlink" title="96. React 和 ReactDOM 之间有什么区别？"></a>96. React 和 ReactDOM 之间有什么区别？</h2><p><code>react</code> 包包含 <code>React.createElement()</code>、<code>React.Component</code>、<code>React.Children</code>, 以及其他与元素和组件类相关的帮助函数。你可以把这些看作是你构建组件所需要的同构或通用助手。<code>react-dom</code> 包包含 <code>ReactDOM.render()</code>，在 <code>react-dom/server</code> 中，我们有 <code>ReactDOMServer.renderToString()</code> 和 <code>ReactDOMServer.renderToStaticMarkup()</code> 的服务器端渲染支持。</p><h2 id="97-为什么-ReactDOM-要从-React-中分离出来？"><a href="#97-为什么-ReactDOM-要从-React-中分离出来？" class="headerlink" title="97. 为什么 ReactDOM 要从 React 中分离出来？"></a>97. 为什么 ReactDOM 要从 React 中分离出来？</h2><p>React 团队致力于将所有与 DOM 相关的功能提取到一个单独的库中，称为 ReactDOM。React v0.14 是第一个分割库的版本。通过查看一些包，<code>react-native</code>、<code>react-art</code>、<code>react-canvas</code>和 <code>react-three</code>，已经很清楚，React 的优秀和本质与浏览器或 DOM 无关。</p><p>为了建立更多 React 可以渲染的环境，React 团队计划将主 React 包分成两个：<code>react</code> 和 <code>react-dom</code>。这就为编写可以在网络版 React 和 React Native 之间共享的组件铺平了道路。</p><h2 id="98-如何使用-React-label-元素？"><a href="#98-如何使用-React-label-元素？" class="headerlink" title="98. 如何使用 React label 元素？"></a>98. 如何使用 React label 元素？</h2><p>如果你试图用标准的 <code>for</code> 属性渲染一个绑定在文本输入上的 <code>&lt;label&gt;</code> 元素，那么它产生的 HTML 会缺少该属性，并在控制台打印出警告。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=&#123;<span class="string">&#x27;user&#x27;</span>&#125;&gt;&#123;<span class="string">&#x27;User&#x27;</span>&#125;&lt;/label&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#123;</span>&#x27;<span class="attr">text</span>&#x27;&#125; <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">user</span>&#x27;&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure><p>由于 <code>for</code> 在 JavaScript 中是一个保留关键字，我们可以使用 <code>htmlFor</code> 代替。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;label htmlFor=&#123;<span class="string">&#x27;user&#x27;</span>&#125;&gt;&#123;<span class="string">&#x27;User&#x27;</span>&#125;&lt;/label&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#123;</span>&#x27;<span class="attr">text</span>&#x27;&#125; <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">user</span>&#x27;&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="99-如何组合多个内联样式对象？"><a href="#99-如何组合多个内联样式对象？" class="headerlink" title="99. 如何组合多个内联样式对象？"></a>99. 如何组合多个内联样式对象？</h2><p>你可以在常规 React 中使用展开语法。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button style=&#123;&#123; ...styles.<span class="property">panel</span>.<span class="property">button</span>, ...styles.<span class="property">panel</span>.<span class="property">submitButton</span> &#125;&#125;&gt;</span><br><span class="line">  &#123;<span class="string">&#x27;Submit&#x27;</span>&#125;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><p>如果你使用的是 React Native，那么你可以使用数组符号。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button style=&#123;[styles.<span class="property">panel</span>.<span class="property">button</span>, styles.<span class="property">panel</span>.<span class="property">submitButton</span>]&#125;&gt;</span><br><span class="line">  &#123;<span class="string">&#x27;Submit&#x27;</span>&#125;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure><h2 id="100-如何在浏览器调整大小时重新渲染视图？"><a href="#100-如何在浏览器调整大小时重新渲染视图？" class="headerlink" title="100. 如何在浏览器调整大小时重新渲染视图？"></a>100. 如何在浏览器调整大小时重新渲染视图？</h2><p>你可以在 <code>componentDidMount()</code> 中监听 <code>resize</code> 事件，然后更新尺寸（<code>width</code> 和 <code>height</code>）。你应该在 <code>componentWillUnmount()</code> 方法中移除监听器。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowDimensions</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">updateDimensions</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="variable language_">this</span>.<span class="property">updateDimensions</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="variable language_">this</span>.<span class="property">updateDimensions</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateDimensions = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">width</span>: <span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="attr">height</span>: <span class="variable language_">window</span>.<span class="property">innerHeight</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.width&#125; x &#123;this.state.height&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="101-setState-和-replaceState-方法之间的区别是什么？"><a href="#101-setState-和-replaceState-方法之间的区别是什么？" class="headerlink" title="101. setState() 和 replaceState() 方法之间的区别是什么？"></a>101. <code>setState()</code> 和 <code>replaceState()</code> 方法之间的区别是什么？</h2><p>当你使用 <code>setState()</code> 时，当前和之前的状态被合并。 <code>replaceState()</code> 抛出当前的状态，只用你提供的内容来替换它。通常 <code>setState()</code> 会被使用，除非你真的因为某些原因需要删除所有之前的键。你也可以在 <code>setState()</code> 中把状态设置为 <code>false</code>&#x2F;<code>null</code>，而不是使用 <code>replaceState()</code>。</p><h2 id="102-如何监听状态变化？"><a href="#102-如何监听状态变化？" class="headerlink" title="102. 如何监听状态变化？"></a>102. 如何监听状态变化？</h2><p>当状态发生变化时，<code>componentDidUpdate</code> 生命周期方法将被调用。你可以将提供的状态和 props 值与当前的状态和 props 进行比较，以确定是否有意义的变化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(object prevProps, object prevState)</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 以前的 ReactJS 版本也使用 <code>componentWillUpdate(object nextProps, object nextState)</code> 监听状态改变。在最新的版本中，它已被弃用。</p><h2 id="103-在-React-状态下，删除数组元素的推荐方法是什么？"><a href="#103-在-React-状态下，删除数组元素的推荐方法是什么？" class="headerlink" title="103. 在 React 状态下，删除数组元素的推荐方法是什么？"></a>103. 在 React 状态下，删除数组元素的推荐方法是什么？</h2><p>更好的方法是使用 <code>Array.prototype.filter()</code> 方法。</p><p>例如，让我们创建一个 <code>removeItem()</code> 方法来更新状态。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">removeItem</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">data</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, i</span>) =&gt;</span> i !== index)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="104-有没有可能在不渲染-HTML-的情况下使用-React-呢？"><a href="#104-有没有可能在不渲染-HTML-的情况下使用-React-呢？" class="headerlink" title="104. 有没有可能在不渲染 HTML 的情况下使用 React 呢？"></a>104. 有没有可能在不渲染 HTML 的情况下使用 React 呢？</h2><p>在最新版本（&gt;&#x3D;16.2）中可以实现。以下是可用选项。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span><span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回 <code>undefined</code> 是不行的。</p><h2 id="105-如何用-React-打印漂亮的-JSON？"><a href="#105-如何用-React-打印漂亮的-JSON？" class="headerlink" title="105. 如何用 React 打印漂亮的 JSON？"></a>105. 如何用 React 打印漂亮的 JSON？</h2><p>我们可以使用 <code>&lt;pre&gt;</code> 标签，这样可以保留 <code>JSON.stringify()</code> 的格式。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">42</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;JSON.stringify(data, null, 2)&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">User</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="106-为什么你不能在-React-中更新-props？"><a href="#106-为什么你不能在-React-中更新-props？" class="headerlink" title="106. 为什么你不能在 React 中更新 props？"></a>106. 为什么你不能在 React 中更新 props？</h2><p>React 的理念是，props 应该是<strong>不可变的</strong>和<strong>自上而下</strong>的。这意味着父组件可以向子组件发送任何 props 值，但子组件不能修改收到的 props。</p><h2 id="107-如何在页面加载时聚焦一个输入框？"><a href="#107-如何在页面加载时聚焦一个输入框？" class="headerlink" title="107. 如何在页面加载时聚焦一个输入框？"></a>107. 如何在页面加载时聚焦一个输入框？</h2><p>你可以通过为 <code>input</code> 元素创建 ref 并在 <code>componentDidMount()</code> 中使用它。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nameInput</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">nameInput</span>.<span class="title function_">focus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">defaultValue</span>=<span class="string">&#123;</span>&quot;<span class="attr">Won</span>&#x27;<span class="attr">t</span> <span class="attr">focus</span>&quot;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;input</span> =&gt;</span> (this.nameInput = input)&#125;</span></span><br><span class="line"><span class="language-xml">          defaultValue=&#123;&#x27;Will focus&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>));</span><br></pre></td></tr></table></figure><h2 id="108-更新状态中的对象的方式有哪些？"><a href="#108-更新状态中的对象的方式有哪些？" class="headerlink" title="108. 更新状态中的对象的方式有哪些？"></a>108. 更新状态中的对象的方式有哪些？</h2><ol><li><strong>合并状态和对象后调用 <code>setState()</code>：</strong></li></ol><ul><li>使用 <code>Object.assign()</code> 创建对象的拷贝：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">user</span>, &#123; <span class="attr">age</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; user &#125;);</span><br></pre></td></tr></table></figure><ul><li>使用展开操作符：</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; ...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">user</span>, <span class="attr">age</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; user &#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>调用 <code>setState()</code> 时传入函数：</strong></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">user</span>: &#123;</span><br><span class="line">    ...prevState.<span class="property">user</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">42</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2 id="109-我们如何在浏览器中查看运行时的-React-的版本？"><a href="#109-我们如何在浏览器中查看运行时的-React-的版本？" class="headerlink" title="109. 我们如何在浏览器中查看运行时的 React 的版本？"></a>109. 我们如何在浏览器中查看运行时的 React 的版本？</h2><p>你可以使用 <code>React.version</code> 来获取版本。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">REACT_VERSION</span> = <span class="title class_">React</span>.<span class="property">version</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;`React version: $&#123;REACT_VERSION&#125;`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="110-在-create-react-app-中包含-polyfills-的方法是什么？"><a href="#110-在-create-react-app-中包含-polyfills-的方法是什么？" class="headerlink" title="110. 在 create-react-app 中包含 polyfills 的方法是什么？"></a>110. 在 <code>create-react-app</code> 中包含 polyfills 的方法是什么？</h2><p>有一些方法可以在 create-react-app 中包含 polyfills。</p><ol><li><strong>手动从 <code>core-js</code> 引入：</strong></li></ol><p>创建一个名为（类似）<code>polyfills.js</code> 的文件并将其导入根 <code>index.js</code> 文件。运行 <code>npm install core-js</code> 或 <code>yarn add core-js</code> 并导入你所需要的特定功能。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js/fn/array/find&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js/fn/array/includes&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js/fn/number/is-nan&#x27;</span>;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>使用 Polyfill 服务：</strong></li></ol><p>使用 polyfill.io CDN，通过在 <code>index.html</code> 中添加这一行来检索自定义的、针对浏览器的 polyfills。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.polyfill.io/v2/polyfill.min.js?features=default,Array.prototype.includes&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在上面的脚本中，我们必须明确请求 <code>Array.prototype.includes</code> 功能，因为它不包括在默认功能集中。</p><h2 id="111-如何在-create-react-app-中使用-https-而不是-http？"><a href="#111-如何在-create-react-app-中使用-https-而不是-http？" class="headerlink" title="111. 如何在 create-react-app 中使用 https 而不是 http？"></a>111. 如何在 create-react-app 中使用 https 而不是 http？</h2><p>你只需要是用 <code>HTTPS=true</code> 配置。你可以编辑 <code>package.json</code> scripts 部分：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set HTTPS=true &amp;&amp; react-scripts start&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>或者运行 <code>set HTTPS=true &amp;&amp; npm start</code></p><h2 id="112-如何避免在-create-react-app-中使用相对路径导入？"><a href="#112-如何避免在-create-react-app-中使用相对路径导入？" class="headerlink" title="112. 如何避免在 create-react-app 中使用相对路径导入？"></a>112. 如何避免在 create-react-app 中使用相对路径导入？</h2><p>在项目里根目录创建一个叫 <code>.env</code> 的文件并写入导入的路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_PATH=src/app</span><br></pre></td></tr></table></figure><p>然后重启调试服务器。现在你应该能够在 <code>src/app</code> 目录下不使用相对路径导入任何东西。</p><h2 id="113-如何在-React-Router-中添加-Google-Analytics？"><a href="#113-如何在-React-Router-中添加-Google-Analytics？" class="headerlink" title="113. 如何在 React Router 中添加 Google Analytics？"></a>113. 如何在 React Router 中添加 Google Analytics？</h2><p>在 <code>history</code> 对象上添加一个监听器，以记录每个页面的浏览。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">listen</span>(<span class="keyword">function</span>(<span class="params">location</span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">ga</span>(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;page&#x27;</span>, location.<span class="property">pathname</span> + location.<span class="property">search</span>);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">ga</span>(<span class="string">&#x27;send&#x27;</span>, <span class="string">&#x27;pageview&#x27;</span>, location.<span class="property">pathname</span> + location.<span class="property">search</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="114-如何每秒更新一次组件？"><a href="#114-如何每秒更新一次组件？" class="headerlink" title="114. 如何每秒更新一次组件？"></a>114. 如何每秒更新一次组件？</h2><p>你需要使用 <code>setInterval()</code> 来触发变化，但你也需要在组件卸载时清除计时器以防止错误和内存泄漏。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">interval</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">time</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>() &#125;), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">interval</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="115-如何在-React-中对内联样式使用-CSS-厂商前缀？"><a href="#115-如何在-React-中对内联样式使用-CSS-厂商前缀？" class="headerlink" title="115. 如何在 React 中对内联样式使用 CSS 厂商前缀？"></a>115. 如何在 React 中对内联样式使用 CSS 厂商前缀？</h2><p>React 不会自动应用 CSS 厂商前缀。你需要手动添加 CSS 厂商前缀。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  style=&#123;&#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="string">&#x27;rotate(90deg)&#x27;</span>,</span><br><span class="line">    <span class="title class_">WebkitTransform</span>: <span class="string">&#x27;rotate(90deg)&#x27;</span>, <span class="comment">// 注意大写 &#x27;W&#x27;</span></span><br><span class="line">    <span class="attr">msTransform</span>: <span class="string">&#x27;rotate(90deg)&#x27;</span>, <span class="comment">// &#x27;ms&#x27; 是全小写</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><h2 id="116-如何使用-React-和-ES6-导入和导出组件？"><a href="#116-如何使用-React-和-ES6-导入和导出组件？" class="headerlink" title="116. 如何使用 React 和 ES6 导入和导出组件？"></a>116. 如何使用 React 和 ES6 导入和导出组件？</h2><p>你应该使用默认值来导出组件</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">User</span> <span class="keyword">from</span> <span class="string">&#x27;user&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyProfile</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">User</span> <span class="attr">type</span>=<span class="string">&quot;customer&quot;</span>&gt;</span>//...<span class="tag">&lt;/<span class="name">User</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了导出指定符，MyProfile 将成为成员并导出到这个模块，同样可以在其他组件中导入而不提及名称。</p><h2 id="117-为什么组件构造器只会被调用一次？"><a href="#117-为什么组件构造器只会被调用一次？" class="headerlink" title="117. 为什么组件构造器只会被调用一次？"></a>117. 为什么组件构造器只会被调用一次？</h2><p>React 的 reconciliation（协调） 算法假定，在没有任何相反信息的情况下，如果一个自定义组件在随后的渲染中出现在相同的地方，它就是之前的那个组件，所以 React 重用之前的实例而不是创建一个新的。</p><h2 id="118-如何在-React-中定义常量？"><a href="#118-如何在-React-中定义常量？" class="headerlink" title="118. 如何在 React 中定义常量？"></a>118. 如何在 React 中定义常量？</h2><p>你可以使用 ES7 的 <code>静态</code> 字段来定义常量。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">DEFAULT_PAGINATION</span> = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态字段是类字段第三阶段提案的一部分。</p><h2 id="119-如何在-React-中以编程方式触发点击事件？"><a href="#119-如何在-React-中以编程方式触发点击事件？" class="headerlink" title="119. 如何在 React 中以编程方式触发点击事件？"></a>119. 如何在 React 中以编程方式触发点击事件？</h2><p>你可以使用 ref props 通过回调获得对底层 <code>HTMLInputElement</code> 对象的引用，将该引用存储为类属性，然后使用该引用从事件处理程序中使用 <code>HTMLElement.click</code> 方法触发点击。</p><p>这可以分两步进行。</p><ol><li>在 render 方法中创建 ref：</li></ol><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123;<span class="function"><span class="params">input</span> =&gt;</span> (<span class="variable language_">this</span>.<span class="property">inputElement</span> = input)&#125; /&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在你的事件处理程序中应用点击事件。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">inputElement</span>.<span class="title function_">click</span>();</span><br></pre></td></tr></table></figure><h2 id="120-有可能在纯-React-中使用-async-x2F-await-吗？"><a href="#120-有可能在纯-React-中使用-async-x2F-await-吗？" class="headerlink" title="120. 有可能在纯 React 中使用 async&#x2F;await 吗？"></a>120. 有可能在纯 React 中使用 async&#x2F;await 吗？</h2><p>如果你想在 React 中使用 <code>async</code>&#x2F;<code>await</code>，你将需要 Babel 和 <a href="https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator">transform-async-to-generator</a> 插件。React Native 已经包含了 Babel 和一系列的转换功能。</p><h2 id="121-React-的常见文件夹结构是什么？"><a href="#121-React-的常见文件夹结构是什么？" class="headerlink" title="121. React 的常见文件夹结构是什么？"></a>121. React 的常见文件夹结构是什么？</h2><p>React 项目文件结构有两种常见做法。</p><ol><li><strong>按特性或路由分组：</strong>*</li></ol><p>一种常见的项目结构方式是将 CSS、JS 和测试放在一起，按特性或路由分组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">common/</span><br><span class="line">├─ Avatar.js</span><br><span class="line">├─ Avatar.css</span><br><span class="line">├─ APIUtils.js</span><br><span class="line">└─ APIUtils.test.js</span><br><span class="line">feed/</span><br><span class="line">├─ index.js</span><br><span class="line">├─ Feed.js</span><br><span class="line">├─ Feed.css</span><br><span class="line">├─ FeedStory.js</span><br><span class="line">├─ FeedStory.test.js</span><br><span class="line">└─ FeedAPI.js</span><br><span class="line">profile/</span><br><span class="line">├─ index.js</span><br><span class="line">├─ Profile.js</span><br><span class="line">├─ ProfileHeader.js</span><br><span class="line">├─ ProfileHeader.css</span><br><span class="line">└─ ProfileAPI.js</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>按文件类型分组：</strong></li></ol><p>另一种流行的项目结构方式是将类似的文件分组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">api/</span><br><span class="line">├─ APIUtils.js</span><br><span class="line">├─ APIUtils.test.js</span><br><span class="line">├─ ProfileAPI.js</span><br><span class="line">└─ UserAPI.js</span><br><span class="line">components/</span><br><span class="line">├─ Avatar.js</span><br><span class="line">├─ Avatar.css</span><br><span class="line">├─ Feed.js</span><br><span class="line">├─ Feed.css</span><br><span class="line">├─ FeedStory.js</span><br><span class="line">├─ FeedStory.test.js</span><br><span class="line">├─ Profile.js</span><br><span class="line">├─ ProfileHeader.js</span><br><span class="line">└─ ProfileHeader.css</span><br></pre></td></tr></table></figure><h2 id="122-有哪些流行的动画包？"><a href="#122-有哪些流行的动画包？" class="headerlink" title="122. 有哪些流行的动画包？"></a>122. 有哪些流行的动画包？</h2><p>React Transition Group 和 React Motion 是 React 生态系统中流行的动画包。</p><h2 id="123-样式模块的好处是什么？"><a href="#123-样式模块的好处是什么？" class="headerlink" title="123. 样式模块的好处是什么？"></a>123. 样式模块的好处是什么？</h2><p>我们建议避免在组件中硬编码样式值。任何可能在不同的 UI 组件中使用的值都应该被提取到它们自己的模块中。</p><p>例如，这些样式可以被提取到一个单独的组件中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> colors = &#123;</span><br><span class="line">  white,</span><br><span class="line">  black,</span><br><span class="line">  blue,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> space = [<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>];</span><br></pre></td></tr></table></figure><p>然后在其他组件中单独导入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; space, colors &#125; <span class="keyword">from</span> <span class="string">&#x27;./styles&#x27;</span>;</span><br></pre></td></tr></table></figure><h2 id="124-有哪些流行的-React-专用-linter？"><a href="#124-有哪些流行的-React-专用-linter？" class="headerlink" title="124. 有哪些流行的 React 专用 linter？"></a>124. 有哪些流行的 React 专用 linter？</h2><p>ESLint 是一个很流行的 JavaScript linter。有一些插件可以用来分析特定的代码风格。其中最常见的 React 插件是一个名为 <code>eslint-plugin-react</code> 的 npm 包。默认情况下，它将检查一些最佳实践，其规则是检查从迭代器中的键到一整套道具类型的东西。</p><p>另一个流行的插件是 <code>eslint-plugin-jsx-a11y</code>，它将帮助修复可访问性方面的常见问题。由于 JSX 提供了与常规 HTML 稍有不同的语法，例如 <code>alt</code> 文本和 <code>tabindex</code> 的问题将不会被常规插件发现。</p><h2 id="125-如何进行-AJAX-调用，应该在哪个组件的生命周期方法中进行-AJAX-调用？"><a href="#125-如何进行-AJAX-调用，应该在哪个组件的生命周期方法中进行-AJAX-调用？" class="headerlink" title="125. 如何进行 AJAX 调用，应该在哪个组件的生命周期方法中进行 AJAX 调用？"></a>125. 如何进行 AJAX 调用，应该在哪个组件的生命周期方法中进行 AJAX 调用？</h2><p>你可以使用 AJAX 库，如 Axios、jQuery AJAX，以及浏览器内置的 <code>fetch</code>。你应该在 <code>componentDidMount()</code> 生命周期方法中获取数据。这样你就可以在获取数据时使用 <code>setState()</code> 来更新你的组件。</p><p>例如，从 API 获取的雇员名单并设置本地状态。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">employees</span>: [],</span><br><span class="line">      <span class="attr">error</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/items&#x27;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(</span><br><span class="line">        <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">employees</span>: result.<span class="property">employees</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; error &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; error, employees &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;employees.map(employee =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;employee.name&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              &#123;employee.name&#125;-&#123;employee.experience&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="126-什么是渲染-props？"><a href="#126-什么是渲染-props？" class="headerlink" title="126. 什么是渲染 props？"></a>126. 什么是渲染 props？</h2><p><strong>渲染 props</strong>是一种简单的技术，使用一个 props 在组件之间共享代码，其值是一个函数。下面的组件使用渲染 props，它返回一个 React 元素。</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">DataProvider</span> render=&#123;<span class="function"><span class="params">data</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Hello $&#123;data.target&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>React Router 和 DownShift 等库正在使用这种模式。</p><h1 id="React-Router"><a href="#React-Router" class="headerlink" title="React Router"></a>React Router</h1><h2 id="1-React-Router-是什么？"><a href="#1-React-Router-是什么？" class="headerlink" title="1. React Router 是什么？"></a>1. React Router 是什么？</h2><p>React Router 是一个建立在 React 之上的强大的路由库，它可以帮助你快速添加新的屏幕和流程到你的应用程序，同时保持 URL 与页面上显示的内容同步。</p><h2 id="2-React-Router-与-history-库有什么不同？"><a href="#2-React-Router-与-history-库有什么不同？" class="headerlink" title="2. React Router 与 history 库有什么不同？"></a>2. React Router 与 history 库有什么不同？</h2><p>React Router 是一个围绕 <code>history</code> 库的包装器，它处理与浏览器的 <code>window.history</code> 和哈希历史记录的交互。 它还提供了内存历史，这对没有全局历史的环境很有用，如移动应用开发（React Native）和 Node 的单元测试。</p><h2 id="3-React-Router-v4-的-lt-Router-gt-组件是什么？"><a href="#3-React-Router-v4-的-lt-Router-gt-组件是什么？" class="headerlink" title="3. React Router v4 的 &lt;Router&gt; 组件是什么？"></a>3. React Router v4 的 <code>&lt;Router&gt;</code> 组件是什么？</h2><p>React Router v4 提供以下 3 个 <code>&lt;Router&gt;</code> 组件。</p><ol><li><code>&lt;BrowserRouter&gt;</code></li><li><code>&lt;HashRouter&gt;</code></li><li><code>&lt;MemoryRouter&gt;</code></li></ol><p>上述组件将创建<em>browser</em>、<em>hash</em>和<em>memory</em>历史实例。React Router v4 使与你的路由相关的 <code>history</code> 实例的属性和方法通过 <code>router</code> 对象中的上下文可用。</p><h2 id="4-history-的-push-和-replace-方法的用处是什么？"><a href="#4-history-的-push-和-replace-方法的用处是什么？" class="headerlink" title="4. history 的 push() 和 replace() 方法的用处是什么？"></a>4. <code>history</code> 的 <code>push()</code> 和 <code>replace()</code> 方法的用处是什么？</h2><p>一个 history 实例有两个方法用于导航。</p><ol><li><code>push()</code></li><li><code>replace()</code></li></ol><p>如果你把 history 看作是一个访问过的位置的数组， <code>push()</code> 将在数组中添加一个新的位置，<code>replace()</code> 将用新的位置替换数组中的当前位置。</p><h2 id="5-如何用-React-Router-v4-进行程序化导航？"><a href="#5-如何用-React-Router-v4-进行程序化导航？" class="headerlink" title="5. 如何用 React Router v4 进行程序化导航？"></a>5. 如何用 React Router v4 进行程序化导航？</h2><p>There are three different ways to achieve programmatic routing&#x2F;navigation within components.</p><ol><li><strong>Using the <code>withRouter()</code> higher-order function:</strong></li></ol><p>The <code>withRouter()</code> higher-order function will inject the history object as a prop of the component. This object provides <code>push()</code> and <code>replace()</code> methods to avoid the usage of context.</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>; <span class="comment">// this also works with &#x27;react-router-native&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span> = <span class="title function_">withRouter</span>(<span class="function">(<span class="params">&#123; history &#125;</span>) =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">      history.push(&#x27;/new-location&#x27;);</span></span><br><span class="line"><span class="language-xml">    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  &gt;</span></span><br><span class="line"><span class="language-xml">    &#123;&#x27;Click Me!&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">));</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>Using <code>&lt;Route&gt;</code> component and render props pattern:</strong></li></ol><p>The <code>&lt;Route&gt;</code> component passes the same props as <code>withRouter()</code>, so you will be able to access the history methods through the history prop.</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">render</span>=<span class="string">&#123;(&#123;</span> <span class="attr">history</span> &#125;) =&gt;</span> (</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">          history.push(&#x27;/new-location&#x27;);</span></span><br><span class="line"><span class="language-xml">        &#125;&#125;</span></span><br><span class="line"><span class="language-xml">      &gt;</span></span><br><span class="line"><span class="language-xml">        &#123;&#x27;Click Me!&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    )&#125;</span></span><br><span class="line"><span class="language-xml">  /&gt;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>Using context:</strong></li></ol><p>This option is not recommended and treated as unstable API.</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">props, context</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">type</span>=<span class="string">&quot;button&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">    <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-xml">      context.history.push(&#x27;/new-location&#x27;);</span></span><br><span class="line"><span class="language-xml">    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  &gt;</span></span><br><span class="line"><span class="language-xml">    &#123;&#x27;Click Me!&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Button</span>.<span class="property">contextTypes</span> = &#123;</span><br><span class="line">  <span class="attr">history</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">shape</span>(&#123;</span><br><span class="line">    <span class="attr">push</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">func</span>.<span class="property">isRequired</span>,</span><br><span class="line">  &#125;),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="6-如何在-React-Router-v4-中获取查询参数？"><a href="#6-如何在-React-Router-v4-中获取查询参数？" class="headerlink" title="6. 如何在 React Router v4 中获取查询参数？"></a>6. 如何在 React Router v4 中获取查询参数？</h2><p>The ability to parse query strings was taken out of React Router v4 because there have been user requests over the years to support different implementation. So the decision has been given to users to choose the implementation they like. The recommended approach is to use query strings library.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queryString = <span class="built_in">require</span>(<span class="string">&#x27;query-string&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> parsed = queryString.<span class="title function_">parse</span>(props.<span class="property">location</span>.<span class="property">search</span>);</span><br></pre></td></tr></table></figure><p>You can also use <code>URLSearchParams</code> if you want something native:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> params = <span class="keyword">new</span> <span class="title class_">URLSearchParams</span>(props.<span class="property">location</span>.<span class="property">search</span>);</span><br><span class="line"><span class="keyword">const</span> foo = params.<span class="title function_">get</span>(<span class="string">&#x27;name&#x27;</span>);</span><br></pre></td></tr></table></figure><p>You should use a <em>polyfill</em> for IE11.</p><h2 id="7-为什么你得到-Router-may-have-only-one-child-element-的警告？"><a href="#7-为什么你得到-Router-may-have-only-one-child-element-的警告？" class="headerlink" title="7. 为什么你得到 Router may have only one child element 的警告？"></a>7. 为什么你得到 <code>Router may have only one child element</code> 的警告？</h2><p>You have to wrap your Route’s in a <code>&lt;Switch&gt;</code> block because <code>&lt;Switch&gt;</code> is unique in that it renders a route exclusively.</p><p>At first you need to add <code>Switch</code> to your imports:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Switch</span>, <span class="title class_">Router</span>, <span class="title class_">Route</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span>;</span><br></pre></td></tr></table></figure><p>Then define the routes within <code>&lt;Switch&gt;</code> block:</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Router</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> &#123;/* <span class="attr">...</span> */&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">Route</span> &#123;/* <span class="attr">...</span> */&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Router</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="8-如何在-React-Router-v4-中向-history-push-方法传递参数？"><a href="#8-如何在-React-Router-v4-中向-history-push-方法传递参数？" class="headerlink" title="8. 如何在 React Router v4 中向 history.push 方法传递参数？"></a>8. 如何在 React Router v4 中向 <code>history.push</code> 方法传递参数？</h2><p>While navigating you can pass props to the <code>history</code> object:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">history</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">  <span class="attr">pathname</span>: <span class="string">&#x27;/template&#x27;</span>,</span><br><span class="line">  <span class="attr">search</span>: <span class="string">&#x27;?name=sudheer&#x27;</span>,</span><br><span class="line">  <span class="attr">state</span>: &#123; <span class="attr">detail</span>: response.<span class="property">data</span> &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>The <code>search</code> property is used to pass query params in <code>push()</code> method.</p><h2 id="9-如何实现-default-或-NotFound-页面？"><a href="#9-如何实现-default-或-NotFound-页面？" class="headerlink" title="9. 如何实现 default 或 NotFound 页面？"></a>9. 如何实现 <em>default</em> 或 <em>NotFound</em> 页面？</h2><p>A <code>&lt;Switch&gt;</code> renders the first child <code>&lt;Route&gt;</code> that matches. A <code>&lt;Route&gt;</code> with no path always matches. So you just need to simply drop path attribute as below</p><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Switch</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/user&quot;</span> <span class="attr">component</span>=<span class="string">&#123;User&#125;</span> /&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">component</span>=<span class="string">&#123;NotFound&#125;</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">Switch</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="10-如何在-React-Router-v4-上获得历史记录？"><a href="#10-如何在-React-Router-v4-上获得历史记录？" class="headerlink" title="10. 如何在 React Router v4 上获得历史记录？"></a>10. 如何在 React Router v4 上获得历史记录？</h2><p>Below are the list of steps to get history object on React Router v4,</p><ol><li>Create a module that exports a <code>history</code> object and import this module across the project.</li></ol><p>For example, create <code>history.js</code> file:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createBrowserHistory &#125; <span class="keyword">from</span> <span class="string">&#x27;history&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createBrowserHistory</span>(&#123;</span><br><span class="line">  <span class="comment">/* pass a configuration object here if needed */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ol start="2"><li>You should use the <code>&lt;Router&gt;</code> component instead of built-in routers. Imported the above <code>history.js</code> inside <code>index.js</code> file:</li></ol><figure class="highlight jsx"><figcaption><span>| pure</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Router</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> history <span class="keyword">from</span> <span class="string">&#x27;./history&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">Router</span> <span class="attr">history</span>=<span class="string">&#123;history&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">Router</span>&gt;</span></span>,</span><br><span class="line">  holder,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ol start="3"><li>You can also use push method of <code>history</code> object similar to built-in history object:</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// some-other-file.js</span></span><br><span class="line"><span class="keyword">import</span> history <span class="keyword">from</span> <span class="string">&#x27;./history&#x27;</span>;</span><br><span class="line"></span><br><span class="line">history.<span class="title function_">push</span>(<span class="string">&#x27;/go-here&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="11-如何在登录后执行自动重定向？"><a href="#11-如何在登录后执行自动重定向？" class="headerlink" title="11. 如何在登录后执行自动重定向？"></a>11. 如何在登录后执行自动重定向？</h2><p>The <code>react-router</code> package provides <code>&lt;Redirect&gt;</code> component in React Router. Rendering a <code>&lt;Redirect&gt;</code> will navigate to a new location. Like server-side redirects, the new location will override the current location in the history stack.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Redirect</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">LoginComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">isLoggedIn</span> === <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/your/redirect/page&quot;</span> /&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#x27;Login Please&#x27;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前 500 个 ReactJS 面试问题和答案列表....编码练习题即将推出！</summary>
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="React" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/React/"/>
    
    
    <category term="React 面试题" scheme="https://youngjuning.js.org/tags/React-%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    <category term="React 面试" scheme="https://youngjuning.js.org/tags/React-%E9%9D%A2%E8%AF%95/"/>
    
    <category term="React 面试题与答案" scheme="https://youngjuning.js.org/tags/React-%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B8%8E%E7%AD%94%E6%A1%88/"/>
    
    <category term="前端面试题" scheme="https://youngjuning.js.org/tags/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>爱她，就在杭州给她一个家｜2021 年中总结</title>
    <link href="https://youngjuning.js.org/ddc418f71cd4/"/>
    <id>https://youngjuning.js.org/ddc418f71cd4/</id>
    <published>2023-03-06T02:57:23.000Z</published>
    <updated>2023-03-07T10:29:44.648Z</updated>
    
    <content type="html"><![CDATA[<p>当去年 8 月我决定到离开郑州到杭州工作时，当我遭受朋友家人质疑非议濒临崩溃时，大宁选择站在我身后坚定地支持我。当一个下午大宁突然出现，我确信心灵找到了依偎。相信我，如果有一个女孩子愿意为你到一个陌生的城市生活，那她一定很爱你。半年多过去了，我在杭州给了她一个家。</p><h2 id="有爱，即是家"><a href="#有爱，即是家" class="headerlink" title="有爱，即是家"></a>有爱，即是家</h2><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/34c2d6ecfbd542cab014e649637025f5~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG194.jpeg"></p><p>在写下本文时，我已经是坐在新家的书房，书桌右侧点着香薰，左侧摆放着掘金签约作者的证书。大宁在卧室敷着面膜刷着武林外传。前几天我问大宁现在有自己家了是不是很开心。她却一反常态地认真起来说：“在小家的时候，我也很开心呀！只要我们互相爱护，哪里都是家”。看着眼前认真的小姑娘，再回想一下这半年的经历。我才发现我们最在乎的是对方。</p><p>这不是什么凡尔赛故事，大宁跑来杭州陪我时还不知道我定居的打算，却断然放弃了家里安逸的条件跑来和我一起租房。哪怕是知道了之后，由于家里人的反对和老房子迟迟卖出无望以及上涨迅速的杭州房价，一度可能定居杭州无望。但是大宁也从来没有说过跟着我受罪不行回郑州之类的话。</p><p>就在一个月前，我们在为卖家想毁约而担忧；两个月前在为预算不充足焦虑；三个月前在为选的新楼盘鸽了我们彷徨；四个月前在为老房子还没有卖掉无助。除了这些客观因素，最难处理的还是来自父母和亲戚的不支持。这 9 个月来不止一次因为我坚持在杭州定居和父母闹的不欢而散。我们俩现在无比珍惜对方和眼前拥有的一切，正如大宁说一切都是最好的发生。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/63d1b9e2b4684598bca7a256b39cedb6~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG189 1.jpeg"></p><h2 id="技术这半年"><a href="#技术这半年" class="headerlink" title="技术这半年"></a>技术这半年</h2><p>这半年可谓折腾的半年，现在回看可能多少是有点迷失了。从 Go 到 Deno，再到 Rust，在语言本身的学习上越走越远，借此机会，捋一下这一路的得失，与君共勉。</p><h3 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h3><p>洛竹的 Go 水平仅限于熟练编写 CLI 程序，在接到使用 Go 写脚本的时候，我内心是激动的。在 <a href="https://juejin.cn/post/6860522117423857678">极速入门Go并爬取掘金专栏 | 🏆 技术专题第二期</a> 入门 Go 后一直没有能用的上。这半年借工作机会，在 Go 的学习道路上有上升了一个台阶，除了完成了工作任务，也产出了一个 Go 插件 <a href="https://github.com/youngjuning/go-release">youngjuning&#x2F;go-release</a>。以及以下博文：</p><ul><li><a href="https://juejin.cn/post/6924541628031959047">Cobra 中文文档</a></li><li><a href="https://juejin.cn/post/6940296964089053221">从零使用 Go 语言构建 CLI 项目 | 项目复盘</a></li><li><a href="https://juejin.cn/column/6962102040684134436">Go 语言教程系列专栏</a></li></ul><p>很开心的是，由于 3、4 月份在后端领域的勤奋更文，连续两个月获得专栏作者上榜证书：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/b41cd7c5614f495d9e67d72406e16997~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG184.jpeg"></p><blockquote><p>花在 Go 上的时间，现在回看是利大于弊的。一是工作相关，二是借由 Go 的学习之旅，可以对后端开发以及分布式、协程等概念有一个了解的机会。</p></blockquote><h3 id="Deno"><a href="#Deno" class="headerlink" title="Deno"></a>Deno</h3><p>与 Deno 结缘起于 <a href="https://juejin.cn/post/6854573220432248839">Deno从入门到跑路 | 🏆 技术专题第一期征文</a> ，当要设计一个基于 Go 的 CLI 时，想到了 Deno 的源码的工程化部分有可以借鉴的部分，遂进行了探索。Deno 本身的学习和应用并没有太多涉及，只产出了几篇相关文章：</p><ul><li><a href="https://juejin.cn/post/6924465443704930318">向 Deno 学习优秀的脚本管理</a></li><li><a href="https://juejin.cn/post/6925201316264443918">基于 Go 实现 Deno upgrade</a></li><li><a href="https://juejin.cn/post/6926899307735957511">叮，一份 Deno GitHub Action 源码解析请查收|牛气冲天新年征文</a></li></ul><p>凭借对 Deno GitHub Action 详细的解析，厚着脸皮提交了一个 pr，遗憾的是，更为建设性的建议并未被仓库管理员采纳。当时因为成为一门编程语言的 contributor 开心了很久。现在回看这件事对我的意义在于体验了一把参与超大型开源项目的完整流程。也把自己的名字永远定格在了仓库列表中。</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0d9faf73715e475593d0729d4e813a7e~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><blockquote><p>值得反思的是对于 Deno 的探究本该点到为止，我却被虚荣蒙盖了双眼，耗费了过多的精力在这上面，人生也有崖，而知无涯。考虑到自己已经入门且 Deno 的前景并不明朗，今年没有特殊情况是不会再继续研究了。</p></blockquote><h3 id="Rust"><a href="#Rust" class="headerlink" title="Rust"></a>Rust</h3><p>学习 Rust 则单纯是因为当时借着给 Deno 提 pr 成功的高兴劲，怒刷了 7 章 《Rust 权威指南》，说实话学习 Rust 比学习 Deno 意义和必要性还大些。今年计划也不会继续学习 Rust 了。把时间更多地留给大前端方面的学习输出。下面是学习 Rust 时输出的几篇垃圾文：</p><ul><li><a href="https://juejin.cn/post/6937098861152305160">[译]深入理解 Rust 所有权、借用、生命周期</a></li><li><a href="https://juejin.cn/post/6929666131082870797">为什么 Rust 需要局部变量隐藏</a></li><li><a href="https://juejin.cn/post/6929576263216529422">Rust 编写猜数游戏</a></li><li><a href="https://juejin.cn/post/6929080722565267469">两个番茄钟的 Rust 语法学习</a></li><li><a href="https://juejin.cn/post/6928656425090547726">一个番茄钟入门 Rust|牛气冲天新年征文</a></li></ul><h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><p>这半年做的还是基础建设方面的事情，通俗点说是如何解决开发痛点，提升效率。值得一提的是设计并参与了类 iceworks 的 vscode 插件体系工具。为了设计工具，在这中间阅读了 vscode、create-react-app、vue-cli、iceworks 等工具的源码。</p><h2 id="掘金，伴我成长"><a href="#掘金，伴我成长" class="headerlink" title="掘金，伴我成长"></a>掘金，伴我成长</h2><h3 id="只如初见"><a href="#只如初见" class="headerlink" title="只如初见"></a>只如初见</h3><p>从 2020 年开始更文到现在，累积在掘金发布了 123 博客。一切的开始都要从上一次年中总结沸点活动开始，获得掘金定制『豪华定制桌』之后激发了对掘金活动的浓厚兴趣！</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4c0fe85200e945bfb869d7b897712aae~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>去年的的年中总结和年终总结可以查看：</p><ul><li><a href="https://juejin.cn/post/6850418121858088968">怕什么真理无穷，进一寸有一寸的欢喜</a></li><li><a href="https://juejin.cn/post/6930623622944358408#heading-0">洛竹的2021年度目标通晒</a></li></ul><p>再然后我成为了掘金专题第一期征文的第一个投稿的作者。也许是张哥提携，也许话题够热，也许是我写的还行。总之我拥有了人生中第一篇热文，以此进入了掘金作者群。后来认识言鸽、王鸽、小帅、大圣、Alex、Kerwin_、建超、耳朵等等天南地北的好朋友都要从被星探张哥发掘开始。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/505f961ae0c54ee6afa06fdd6146de13~tplv-k3u1fbpfcp-zoom-1.image"></p><p>进入 2021 年后，明显感受到了运营同学的发力，各种活动应接不暇。由于我总是一个不拉的参与活动，一度需要专门对参与的掘金活动进行管理。掘金的快递隔三差五就会有一个，公司小邮局的阿姨都记得我的名字了。不算其他快递寄的，单顺丰这半年已经收到掘金近 20 个快递：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8ff87ec15b274bb8ab5eda9d30d2e85d~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG196.jpeg"></p><p>爱，只如初见，入驻一年下来。从小公司自满自足到进入上市公司，从默默无名到成为签约作者。感谢掘金提供的平台，感谢张哥从茫茫人海中注意到了我。</p><h3 id="机会与软实力提升"><a href="#机会与软实力提升" class="headerlink" title="机会与软实力提升"></a>机会与软实力提升</h3><p>之前开玩笑说和张哥学运营，而这句话最终却不是一句笑话。在耳濡目染下，我从一个不善言辞，台前紧张的宅男。慢慢地可以维护公司大前端专栏、和言鸽一起负责内部沙龙并偶尔客串主持人，这一切无疑都是掘金提供给我的人脉、资源打开了我的眼界提升了我的软实力。下图是第一场沙龙<a href="https://juejin.cn/user/747323638163768">接水怪</a>同学的分享：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/361db1efad154900aa2f10c81e5714c0~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG183.jpeg"></p><p>近期最开心的事是去北京签约的时候，通过掘金，终于面基了大圣老师（之前不止一次在博客表达过对老师的敬佩）。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/83274b59972349088daf61df11362b2d~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG191.jpeg"></p><h3 id="掘金翻译计划"><a href="#掘金翻译计划" class="headerlink" title="掘金翻译计划"></a>掘金翻译计划</h3><p>从三月开始参与掘金翻译计划到现在已经贡献了 8 篇文章，这一过程中倒逼我重新背了一个月单词。并在翻译专业文章时查阅了大量资料。并且大家可以看到每个 PR 都有校对者认真和专业的校对。ps：体验过一次校，感觉对有时候比翻译本身还要辛苦。这一极其有意义的事我下半年还是会继续坚持参与的。也欢迎掘友一起参与！</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a6d9f6ece6fd48a5af9f6a8c376a0085~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="签约，是成长和责任"><a href="#签约，是成长和责任" class="headerlink" title="签约，是成长和责任"></a>签约，是成长和责任</h2><p>签约对于每个人的意义都不一样，对于我来说最大的意义是成长和责任。成长是我对自己的期望值需要更高了，而责任是必须要拿出诚意来认真对待每一篇签约文章不辜负平台的信任。最后掘金高端实木地址签约证书结束本次年中总结：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/61a39d23f26e4c66950b8b4b2b0a54ba~tplv-k3u1fbpfcp-watermark.image" alt="WechatIMG186.jpeg"></p><blockquote><p>本文首发于「<a href="https://youngjuning.js.org/">洛竹的官方网站</a>」，同步于公众号「<a href="https://cdn.jsdelivr.net/gh/youngjuning/images/20210418112129.jpeg">洛竹早茶馆</a>」和「<a href="https://juejin.cn/user/325111174662855">掘金专栏</a>」。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;当去年 8 月我决定到离开郑州到杭州工作时，当我遭受朋友家人质疑非议濒临崩溃时，大宁选择站在我身后坚定地支持我。当一个下午大宁突然出现，我确信心灵找到了依偎。相信我，如果有一个女孩子愿意为你到一个陌生的城市生活，那她一定很爱你。半年多过去了，我在杭州给了她一个家。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="漫谈" scheme="https://youngjuning.js.org/categories/%E6%BC%AB%E8%B0%88/"/>
    
    
    <category term="年中总结" scheme="https://youngjuning.js.org/tags/%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/"/>
    
    <category term="程序员" scheme="https://youngjuning.js.org/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    <category term="杭州" scheme="https://youngjuning.js.org/tags/%E6%9D%AD%E5%B7%9E/"/>
    
  </entry>
  
  <entry>
    <title>React 性能优化实践</title>
    <link href="https://youngjuning.js.org/8132b809f088/"/>
    <id>https://youngjuning.js.org/8132b809f088/</id>
    <published>2023-03-05T09:22:41.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-Profiler"><a href="#React-Profiler" class="headerlink" title="React Profiler"></a>React Profiler</h1><p>React 16.5 添加了对开发者工具的 Profiler 插件的支持。该插件使用了 React 的 Profiler API 来收集所有组件渲染的耗时，目的是为了找出 React 应用程序的性能瓶颈。</p><p>这个“Profiler”面板初始为空，你可以点击 record 按钮开始分析：</p><p><img src="https://zh-hans.reactjs.org/static/bae8d10e17f06eeb8c512c91c0153cff/ad997/start-profiling.png"></p><p>当你开始记录之后，开发者工具将在每次应用程序渲染时自动收集性能数据。 你可以和平常一样使用你的应用程序， 当你完成分析之后，请点击“Stop”按钮。</p><p><img src="https://zh-hans.reactjs.org/static/45619de03bed468869f7a0878f220586/ad997/stop-profiling.png"></p><h1 id="优化法则"><a href="#优化法则" class="headerlink" title="优化法则"></a>优化法则</h1><ul><li>法则一：动静分离，将变的部分与不变的部分分离。</li><li>法则二：缓存，复杂计算和有昂贵消耗的组件 memo 化，比如 React 的 useMemo、useCallback，Redux 的 useSelector。</li></ul><p>下面我们将根据这些法则结合实际开发中案例进行分析。</p><h1 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h1><p>我们都知道，当 state 更新后，整个组件以及它的子组件都会重新更新，尽管子组件没有依赖任何 state，下面的例子就能很好地展示这个问题。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Random</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;Math.random()&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Count</span>(<span class="params">props: &#123; count: <span class="built_in">number</span>&#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;props.count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onAdd</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onMinus</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Random</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Count</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onMinus&#125;</span>&gt;</span>➖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onAdd&#125;</span>&gt;</span>➕<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>在以上示例中，我们声明了一个显示随机数的组件和一个依赖 count 状态的数字显示组件，使用 React Profiler 工具分析如下：</p><p><img src="https://s2.loli.net/2022/09/25/zKn9HslamJi6Ro5.png"></p><p>就像预期的那样，App、Count 和 Random 组件都更新了，从工具中我们可以看到它们更新的原因：</p><ul><li>App：Hook 1 changed.</li><li>Count：Props changed（count）.</li><li>Random：The parent component rendered.</li></ul><p>我们可以看到这里边除了 Count 是因为 count 更新之外，其他组件的更新都是被无辜牵连的。根据法则一，我们可以尝试将 Count 组件和它依赖的状态封装起来。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Random</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;Math.random()&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Count</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onAdd</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onMinus</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onMinus&#125;</span>&gt;</span>➖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onAdd&#125;</span>&gt;</span>➕<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Random</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Count</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>从下图 Profiler 分析可以看到当 count 更新时，只有 Count 组件更新了。</p><p><img src="https://s2.loli.net/2022/09/25/YheAM9ZuviaJDmo.png"></p><p>上面的示例太过理想化，大部分时候，负责更新状态的组件和负责展示状态的组件可能并不在一起，也就没办法抽离动态组件。比如我们将示例中的组件位置做下调整：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Count</span> <span class="attr">count</span>=<span class="string">&#123;count&#125;/</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Random</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onMinus&#125;</span>&gt;</span>➖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onAdd&#125;</span>&gt;</span>➕<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，我们就需要法则二来帮助我们，最简单的是通过 props.children 属性来实现，原理上是一种依靠缓存的 bailout 优化方案。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CountProps</span> &#123;</span><br><span class="line">  children?: <span class="variable constant_">JSX</span>.<span class="property">Element</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Random</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;Math.random()&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Count</span>(<span class="params">props: CountProps</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onAdd</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onMinus</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onMinus&#125;</span>&gt;</span>➖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;onAdd&#125;</span>&gt;</span>➕<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Count</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Random</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">Count</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><h1 id="bailout"><a href="#bailout" class="headerlink" title="bailout"></a>bailout</h1><p>想要解释为什么案例一中使用 props.children 可以解决重复渲染，就要了解一下 React bailout 机制。</p><p>bailout（bail out of re-rendering）可以简单理解为是否重新渲染。</p><p>要触发 bailout 函数，需要同时满足以下条件：</p><ol><li>oldProps &#x3D;&#x3D;&#x3D; newProps 并且 Context 没有改变</li><li>!includesSomeLane(renderLanes, updateLanes)</li></ol><p>当前 fiber 上是否存在更新，如果存在那么更新的优先级是否和本次整棵 Fiber 树调度的优先级一致？如果一致代表该组件上存在更新，需要走 render 逻辑。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// beginWork 函数</span></span><br><span class="line"><span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> oldProps = current.<span class="property">memoizedProps</span>;</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.<span class="property">pendingProps</span>;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    oldProps !== newProps ||</span><br><span class="line">    <span class="title function_">hasLegacyContextChanged</span>()</span><br><span class="line">  ) &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="title function_">includesSomeLane</span>(renderLanes, updateLanes)) &#123;</span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 命中 bailoutOnAlreadyFinishedWork</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>bailout 函数逻辑大致是：尽量复用 fiber，不进行 render。fiber 复用，判断 fiber 的子树是否有 work。有，返回 child，继续遍历子树。无，返回 null，跳过子树。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bailoutOnAlreadyFinishedWork 函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bailoutOnAlreadyFinishedWork</span>(<span class="params"></span></span><br><span class="line"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span><br><span class="line"><span class="params">  workInProgress: Fiber,</span></span><br><span class="line"><span class="params">  renderLanes: Lanes,</span></span><br><span class="line"><span class="params"></span>): <span class="title class_">Fiber</span> | <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 重用以前的 context 依赖关系</span></span><br><span class="line">    workInProgress.<span class="property">dependencies</span> = current.<span class="property">dependencies</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检测子树(childLanes)是否有 work</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title function_">includesSomeLane</span>(renderLanes, workInProgress.<span class="property">childLanes</span>)) &#123;</span><br><span class="line">    <span class="comment">//无，跳过子树</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 虽然 fiber 没有 work，但是它的子树有，克隆子树的 fiber 然后继续检查</span></span><br><span class="line">  <span class="title function_">cloneChildFibers</span>(current, workInProgress);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.<span class="property">child</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>案例一中，由于 children Random 组件的 props 没有发生改变，并且 lanes 也不在 renderLanes 上 ，Diff 组件命中 bailoutOnAlreadyFinishedWork。</p><p>lane 是 React 调度模型中的优先级模型。想象一下不同的赛车疾驰在不同的赛道。内圈的赛道总长度更短，外圈更长。某几个临近的赛道的长度可以看作差不多长。</p><p>lane 模型借鉴了同样的概念，使用 31 位的二进制表示 31 条赛道，位数越小的赛道优先级越高，某些相邻的赛道拥有相同优先级。</p><h1 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h1><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; useState, useContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> countContext = <span class="title class_">React</span>.<span class="property">createContext</span>&lt;<span class="built_in">number</span>&gt;(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">CountProvider</span> = countContext.<span class="property">Provider</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Random</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;Math.random()&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">CountProps</span> &#123;</span><br><span class="line">  children?: <span class="variable constant_">JSX</span>.<span class="property">Element</span></span><br><span class="line">  <span class="attr">onAdd</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">  <span class="attr">onMinus</span>: <span class="function">() =&gt;</span> <span class="built_in">void</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Count</span>(<span class="params">props: CountProps</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> count = <span class="title function_">useContext</span>(countContext);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;count&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;props?.onMinus&#125;</span>&gt;</span>➖<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;props?.onAdd&#125;</span>&gt;</span>➕<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">App</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onAdd</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">onMinus</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="title function_">setCount</span>(count - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;App&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">CountProvider</span> <span class="attr">value</span>=<span class="string">&#123;count&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Count</span> <span class="attr">onAdd</span>=<span class="string">&#123;onAdd&#125;</span> <span class="attr">onMinus</span>=<span class="string">&#123;onMinus&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">Random</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">CountProvider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">App</span>;</span><br></pre></td></tr></table></figure><p>该案例中我们引入了 Context，当 context 的 value 改变时，</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://zh-hans.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html">React Profiler 介绍</a></li><li><a href="https://blog.wuct.me/react-internal-reconciliation-bailout-587695eb05a8?gi=c4bc84e7c1df">深入 React Reconciliation Bailout 機制</a></li><li><a href="https://jishuin.proginn.com/p/763bfbd32552">我在大厂写React学到了什么？性能优化篇</a></li><li><a href="https://juejin.cn/post/7090466770774917150">react 性能优化 - children如何避免不必要的渲染</a></li><li><a href="https://juejin.cn/post/7092593300233781285#heading-4">React 性能优化，你需要知道的一切</a></li></ul>]]></content>
    
    
    <summary type="html">React 组件性能优化的核心是减少渲染真实 DOM 节点的频率，减少 VirtualDOM 比对的频率。</summary>
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="React" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/React/"/>
    
    
    <category term="React" scheme="https://youngjuning.js.org/tags/React/"/>
    
    <category term="性能优化" scheme="https://youngjuning.js.org/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
    <category term="React.memo" scheme="https://youngjuning.js.org/tags/React-memo/"/>
    
    <category term="useMemo" scheme="https://youngjuning.js.org/tags/useMemo/"/>
    
  </entry>
  
  <entry>
    <title>前端组件化实战之 Button</title>
    <link href="https://youngjuning.js.org/f4ea430d1d6d/"/>
    <id>https://youngjuning.js.org/f4ea430d1d6d/</id>
    <published>2023-03-03T02:36:18.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>⚠️本文为掘金社区首发签约文章，未获授权禁止转载</p></blockquote><blockquote><p>大家好，我是<a href="https://youngjuning.js.org/">洛竹🎋</a>，一只住在杭城的木系前端🧚🏻‍♀️，如果你喜欢我的文章📚，可以通过点赞帮我聚集灵力⭐️。</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://juejin.cn/post/6983854006124675108">《每个前端都应该拥有自己的组件库,就像每个夏天都有西瓜🍉》</a> 一文中，洛竹带领小黑从零搭建了一个组件库项目，完成了项目结构、构建、测试、文档等基础工程化工作并完成了第一个组件 Icon。本期延续上期的组件工程化的主题，夏日炎热，点上一杯杨枝甘露，和洛竹赴一场 Button 开发之约吧。赴约后，你将会收获以下的内容：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/58285f3cce144972b2ccb88e11efd73f~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p>PS：配合<a href="https://github.com/youngjuning/vant-react-native">仓库</a>和<a href="https://vant-react-native.js.org/">组件库文档</a>阅读本文效果更佳喲！</p></blockquote><h2 id="Button-与设计心理学"><a href="#Button-与设计心理学" class="headerlink" title="Button 与设计心理学"></a>Button 与设计心理学</h2><p>作为前端工程师，入行至今接触最多的就是设计师了。耳濡目染下虽说没学会什么设计工具，但是对设计与人的心理有了一定认识。</p><p>洛竹认为任何事物都不可能凭空出现，自有其传承。使用广泛的基础界面元素 Button 也不例外，我们生活中就有随处可见的按钮。举个栗子🌰，每天上班下班必然要按的电梯按钮、手机音量按钮、小米 9 鸡肋的小爱同学唤起按钮。要搞清楚为什么需要按钮，我们有必要探究下生活中这些按钮的作用。</p><h3 id="点一下按钮的快感"><a href="#点一下按钮的快感" class="headerlink" title="点一下按钮的快感"></a>点一下按钮的快感</h3><p>想象一下把键盘按键换成触摸屏，你最在乎的一定是完美还原物理键的敲击感，像洛竹用手机虚拟键盘就喜欢设置按键震动和音效。通过打击（点击）获得快感是较为普遍的人性。按钮在按下、松开时有丰富的质感和交互感，完美满足了人们点一下的快感。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/542a6bbb880e4594ae384ee0bd1e511d~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="现实的实用性"><a href="#现实的实用性" class="headerlink" title="现实的实用性"></a>现实的实用性</h3><p>从 BB 机到诺基亚再到如今的智能机，实体按钮削减到只剩下音量键和开关机键。按键虽然光秃秃没有任何标识，但我们就是知道它的功能。试想一下没有这个来自远古时代的开关键，你手里的手机就是一块板砖。</p><h3 id="疯狂暗示用户，达到不可告人目的"><a href="#疯狂暗示用户，达到不可告人目的" class="headerlink" title="疯狂暗示用户，达到不可告人目的"></a>疯狂暗示用户，达到不可告人目的</h3><p>小米 9 单独唤起小爱同学的按键经常会被误按，之前我还不理解这么蠢的设计的目的。在简单研究了点设计心理学我明白了。小爱的设计者为了 产品日活和 AI 训练就是故意这个设计的。</p><p>小米 10 虽然移除了单独的唤起键，却把原来的电源键改成了一键多用。每次想要重启手机还得先唤起一下小爱同学。不得不说，小爱同学小米亲女儿。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/633381b8c2c342ed94bf024dbc19cf76~tplv-k3u1fbpfcp-watermark.image"></p><p>吐槽归吐槽，小米这个按钮确实起到了培养用户习惯的任务。当用户知悉某个按钮能指向某个操作，或者获取某类信息后，长此以往用户就会形成使用习惯。如果某操作能够为用户和厂商持续带来价值，那就可以让按钮的位置更加醒目，持续培养用户点击习惯。</p><h3 id="指引用户操作"><a href="#指引用户操作" class="headerlink" title="指引用户操作"></a>指引用户操作</h3><p>这个在 Web 开发中是最常见的使用场景，每个可交互页面上都有这类按钮的出现，用来指引用户下一步该怎么做。比如表单的提交和重置。</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d2c2a8abbe84471f96a67e18196c53fb~tplv-k3u1fbpfcp-watermark.image"></p><p>虽然按钮也常作为表单元素，但是区别于其他表单元素，按钮因其天然地自说明性，不需要 Label 对其进行辅助说明，啰嗦这么多，掘友们应该在看到一个按钮时，应该也会有从设计上品鉴的意识了，欢迎将对下图的品鉴在评论区告诉洛竹。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/88c6754b28984fc3866319c35790fc03~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="组件主题化"><a href="#组件主题化" class="headerlink" title="组件主题化"></a>组件主题化</h2><p>在开始开发具体组件之前，我们必须先约定好组件主题化的规范。之前 antd-mobile-rn 就因为设计问题，中途花费大力气重构。几乎所有的组件库都会将色彩、布局这些以 css 变量的形式提供给使用者和开发者为，React Native 不同的是样式基于 CSS in JS，不过道理相通，参照 vant 的<a href="https://github.com/youzan/vant/blob/dev/src/style/var.less">设计资源</a>，我们抽出了一套 JavaScript 常量：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// packages/themes</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">interface</span> <span class="title class_">Theme</span> &#123;</span><br><span class="line">  <span class="string">&#x27;animation-duration-base&#x27;</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="string">&#x27;animation-duration-fast&#x27;</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="string">&#x27;animation-timing-function-enter&#x27;</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="string">&#x27;animation-timing-function-leave&#x27;</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="string">&#x27;font-size-xs&#x27;</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="string">&#x27;font-size-sm&#x27;</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="string">&#x27;font-size-md&#x27;</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="string">&#x27;font-size-lg&#x27;</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="string">&#x27;font-weight-bold&#x27;</span>: <span class="built_in">number</span>;</span><br><span class="line">  <span class="comment">// 变量过多，这里仅展示部分变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了这些 JS 常量，我们就可以设计主题系统。基于 CSS in JS 的主题化设计一般是基于 React Context 实现，需要提供 ThemeProvider 传入主题上下文，ThemeConsumer、WithTheme（高阶类组件）、withTheme（高阶函数组件） 或 useTheme（React Hooks）作为消费者获取上下文。自己实现也不难，不过更文任务比较紧急，我们先基于 <a href="https://github.com/cssinjs/theming">cssinjs&#x2F;theming</a> 实现功能，后期有需要再回来造轮子也不迟。下面👇就是我们基于 theming 的 <code>createTheming</code> 函数创建自定义主题上下文。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createTheming &#125; <span class="keyword">from</span> <span class="string">&#x27;theming&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> context = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultTheme);</span><br><span class="line"><span class="keyword">const</span> theming = <span class="title function_">createTheming</span>(context);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> &#123; <span class="title class_">ThemeProvider</span>, withTheme, useTheme &#125; = theming;</span><br></pre></td></tr></table></figure><blockquote><p>主题功能是通用的，因此我将主题相关的能力都放在 <code>@vant-react-native/theme</code> 包中发布。</p></blockquote><h2 id="Button-的实现"><a href="#Button-的实现" class="headerlink" title="Button 的实现"></a>Button 的实现</h2><p>React Native 内置的 Button 组件的样式是固定的，只能进行一些简单的设置。且内置的 Button 组件在 Android 和 ios 两个平台上的表现并不一致。所以我们需要根据更底层的组件进行封装。我们对比 ant-design-mobile-rn 和 react-native-elements 后采用了前者使用的 <code>TouchableHighlight</code> 组件。由于继承自 TouchableHighlight，所以我们组件的 Props 类型如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">TouchableHighlightProps</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ButtonProps</span> <span class="keyword">extends</span> <span class="title class_">TouchableHighlightProps</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按钮类型"><a href="#按钮类型" class="headerlink" title="按钮类型"></a>按钮类型</h3><p>vant 的 <a href="https://youzan.github.io/vant/#/zh-CN/button#an-niu-lei-xing">Button</a> 支持 <code>default</code>、<code>primary</code>、<code>info</code>、<code>warning</code>、<code>danger</code> 五种类型，默认为 <code>default</code>。现在，组件的基本定义如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">FunctionComponent</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Text</span>, <span class="title class_">View</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ButtonProps</span> &#123;</span><br><span class="line">  <span class="keyword">type</span>?: <span class="string">&#x27;default&#x27;</span> | <span class="string">&#x27;primary&#x27;</span> | <span class="string">&#x27;info&#x27;</span> | <span class="string">&#x27;warning&#x27;</span> | <span class="string">&#x27;danger&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span>: <span class="title class_">FunctionComponent</span>&lt;<span class="title class_">ButtonProps</span>&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>我们的组件为了适应主题化需求，样式不能是写死在组件里的，而是要通过上下文获取样式常量。我们思路是首先使用 <code>useTheme</code> 从上下文中获取主题，然后由于样式定义较多，我们为每个组件编写一个 <code>useStyle</code> hook 放在单独的 style.ts 文件中：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">StyleSheet</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;react-native&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Theme</span>, useTheme &#125; <span class="keyword">from</span> <span class="string">&#x27;@vant-react-native/theme&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">useStyle</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> theme = useTheme&lt;<span class="title class_">Theme</span>&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getBackgroundColor</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (props.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;primary&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;success-color&#x27;</span>];</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;info&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;primary-color&#x27;</span>];</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;warning&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;warning-color&#x27;</span>];</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;danger&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;danger-color&#x27;</span>];</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span> theme.<span class="property">white</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getTextColor</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">type</span> === <span class="string">&#x27;default&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> theme.<span class="property">black</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> theme.<span class="property">white</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getBorderRadius</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">round</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> theme[<span class="string">&#x27;border-radius-max&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props.<span class="property">square</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> theme[<span class="string">&#x27;border-radius-sm&#x27;</span>];</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> styles = <span class="title class_">StyleSheet</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">container</span>: &#123;</span><br><span class="line">      <span class="attr">alignItems</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">      <span class="attr">backgroundColor</span>: <span class="title function_">getBackgroundColor</span>(),</span><br><span class="line">      <span class="attr">borderColor</span>: <span class="title function_">getBorderColor</span>(),</span><br><span class="line">      <span class="attr">borderRadius</span>: theme[<span class="string">&#x27;border-radius-sm&#x27;</span>],</span><br><span class="line">      <span class="attr">borderWidth</span>: theme[<span class="string">&#x27;border-width-base&#x27;</span>],</span><br><span class="line">      <span class="attr">flexDirection</span>: <span class="string">&#x27;row&#x27;</span>,</span><br><span class="line">      <span class="attr">flex</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">justifyContent</span>: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">      <span class="attr">opacity</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="attr">paddingHorizontal</span>: <span class="number">15</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">indicator</span>: &#123;</span><br><span class="line">      <span class="attr">marginRight</span>: theme[<span class="string">&#x27;padding-xs&#x27;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">textStyle</span>: &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="title function_">getTextColor</span>(),</span><br><span class="line">      <span class="attr">fontSize</span>: <span class="number">14</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">wrapper</span>: &#123;</span><br><span class="line">      <span class="attr">borderRadius</span>: theme[<span class="string">&#x27;border-radius-sm&#x27;</span>],</span><br><span class="line">      <span class="attr">height</span>: <span class="number">44</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> styles;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>基于 <code>useStyle</code> 我们便可完成一个支持多类型的 Button 组件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">Button</span>: <span class="title class_">FunctionComponent</span>&lt;<span class="title class_">ButtonProps</span>&gt; = <span class="function"><span class="params">props</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> styles = <span class="title function_">useStyle</span>(props);</span><br><span class="line">  <span class="keyword">const</span> &#123; style, ...restProps &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">TouchableHighlight</span> <span class="attr">style</span>=<span class="string">&#123;[styles.wrapper,</span> <span class="attr">style</span>]&#125; &#123;<span class="attr">...restProps</span>&#125;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.container&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;typeof props.children === &#x27;string&#x27; ? (</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;styles.textStyle&#125;</span>&gt;</span>&#123;props.children&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        ) : (</span></span><br><span class="line"><span class="language-xml">          props.children</span></span><br><span class="line"><span class="language-xml">        )&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">View</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">TouchableHighlight</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意：子组件可能是字符串，也可能是组件，所以需要判断类型。</p></blockquote><p>实现效果如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a0b412c227e4dc994b818294165240d~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="朴素按钮"><a href="#朴素按钮" class="headerlink" title="朴素按钮"></a>朴素按钮</h3><p>朴素按钮的文字为按钮颜色，背景为白色，我们通过 <code>plain</code> 属性将按钮设置为朴素按钮。调研了 antd 和 react-native-elements 发现它们都是定义了很多样式，然后在组件内通过逻辑判断计算具体样式的值。个人很不喜欢这种方式，不是彻底的 CSS in JS，我的处理方式是将所有有关样式计算的都封装在每个组件的 <code>useStyle</code> 钩子中，比如当引入朴素按钮属性时，相对于普通按钮改变的有容器背景色、容器边框和字体颜色。所以我们将这三个属性的值都通过一个单独的函数计算。对比 antd 的源码，会发现不仅代码更易读，甚至代码量也少了。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getBackgroundColor</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (props.<span class="property">plain</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> theme.<span class="property">white</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getTextColor</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (props.<span class="property">plain</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (props.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;primary&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;success-color&#x27;</span>];</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;info&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;primary-color&#x27;</span>];</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;warning&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;warning-color&#x27;</span>];</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;danger&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;danger-color&#x27;</span>];</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;gray-3&#x27;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (props.<span class="property">type</span> === <span class="string">&#x27;default&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> theme.<span class="property">black</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> theme.<span class="property">white</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0fc1bedf56fe4dd0a31e6d18b048665c~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="细边框"><a href="#细边框" class="headerlink" title="细边框"></a>细边框</h3><p>vant 实现细边框是通过设置 <code>hairline</code> 属性可以展示 0.5px 的细边框。但是手机上由于分辨率的影响，贸然设置 0.5 会导致边框不显示的兼容问题。好在 React Native 为我们提供了 <code>StyleSheet.hairlineWidth</code> 常量来兼容最细边框问题，下面是官方对它的定义：</p><blockquote><p>hairlineWidth 这一常量始终是一个整数的像素值（线看起来会像头发丝一样细），并会尽量符合当前平台最细的线的标准。可以用作边框或是两个元素间的分隔线。然而，你不能把它“视为一个常量”，因为不同的平台和不同的屏幕像素密度会导致不同的结果。</p><p>如果模拟器缩放过，可能会看不到这么细的线。</p></blockquote><p>由于 <code>hairline</code> 只影响了容器 <code>borderWidth</code> 属性，我们不需要编写单独的样式计算函数：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styles = <span class="title class_">StyleSheet</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">container</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">borderWidth</span>: props.<span class="property">hairline</span> ? theme[<span class="string">&#x27;border-width-hairline&#x27;</span>] : theme[<span class="string">&#x27;border-width-base&#x27;</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实现效果如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/43d80d537b07487d9043d718e6541f7e~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="禁用状态"><a href="#禁用状态" class="headerlink" title="禁用状态"></a>禁用状态</h3><p>表单元素或者说可触摸可点击的元素一般都有禁用状态，vant 中是通过 disabled 属性来禁用按钮，禁用状态下按钮不可点击。TouchableHighlight 继承地有 <code>disabled</code> 属性，我们只需要设置一些禁用状态下的按钮样式就可以，查看 vant 源码我们发现只需要修改透明度为 0.5 即可：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> styles = <span class="title class_">StyleSheet</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">container</span>: &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">opacity</span>: props.<span class="property">disabled</span> ? <span class="number">0.5</span> : <span class="number">1</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实现效果如下：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/892589086d07426a8346319d8466bccf~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="加载状态"><a href="#加载状态" class="headerlink" title="加载状态"></a>加载状态</h3><p>vant 是通过 <code>loading</code> 属性设置按钮为加载状态，加载状态下默认会隐藏按钮文字，可以通过 <code>loading-text</code> 设置加载状态下的文字。我们借助 React Native 的 ActivityIndicator 组件可以轻松实现这个特性：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">&lt;<span class="title class_">TouchableHighlight</span> &#123;...restProps&#125;&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">View</span> <span class="attr">style</span>=<span class="string">&#123;styles.contentWrapper&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;props.loading ? (</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">ActivityIndicator</span> <span class="attr">size</span>=<span class="string">&quot;small&quot;</span> <span class="attr">color</span>=<span class="string">&#123;indicatorColor&#125;</span> <span class="attr">style</span>=<span class="string">&#123;styles.indicator&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;props.loadingText ? <span class="tag">&lt;<span class="name">Text</span> <span class="attr">style</span>=<span class="string">&#123;styles.textStyle&#125;</span>&gt;</span>&#123;props.loadingText&#125;<span class="tag">&lt;/<span class="name">Text</span>&gt;</span> : null&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    ) : <span class="literal">null</span>&#125;</span><br><span class="line">  &lt;/<span class="title class_">View</span>&gt;</span><br><span class="line">&lt;/<span class="title class_">TouchableHighlight</span>&gt;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>样式如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useIndicatorColor = (<span class="attr">props</span>: <span class="title class_">ButtonProps</span>): <span class="function"><span class="params">string</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> theme = useTheme&lt;<span class="title class_">Theme</span>&gt;();</span><br><span class="line">  <span class="keyword">if</span> (props.<span class="property">plain</span>) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (props.<span class="property">type</span>) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;primary&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;success-color&#x27;</span>];</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;info&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;primary-color&#x27;</span>];</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;warning&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;warning-color&#x27;</span>];</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;danger&#x27;</span>:</span><br><span class="line">        <span class="keyword">return</span> theme[<span class="string">&#x27;danger-color&#x27;</span>];</span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">return</span> theme.<span class="property">black</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (props.<span class="property">type</span> === <span class="string">&#x27;default&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> theme.<span class="property">black</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> theme.<span class="property">white</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现效果如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/27c4340df2254245a3c830bf667a2e28~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="按钮形状"><a href="#按钮形状" class="headerlink" title="按钮形状"></a>按钮形状</h3><p>默认的按钮有值为 2 的圆角，vant 中通过 <code>square</code> 设置方形按钮，通过 <code>round</code> 设置圆形按钮。按例，我们通过判断设置样式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getBorderRadius</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (props.<span class="property">round</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> theme[<span class="string">&#x27;border-radius-max&#x27;</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (props.<span class="property">square</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> theme[<span class="string">&#x27;border-radius-sm&#x27;</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> styles = <span class="title class_">StyleSheet</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">container</span>: &#123;</span><br><span class="line">    <span class="attr">borderColor</span>: <span class="title function_">getBorderColor</span>(),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">wrapper</span>: &#123;</span><br><span class="line">    <span class="attr">borderRadius</span>: <span class="title function_">getBorderRadius</span>(),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实现效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d1402517566e49d1a1920fd9b3f7bb20~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="按钮尺寸"><a href="#按钮尺寸" class="headerlink" title="按钮尺寸"></a>按钮尺寸</h3><p>Antd RN 只提供了 large、small 两个尺寸，而在 vant 中支持 large、normal、small、mini 四种尺寸，默认为 normal。虽然写到这里已经很疲倦了，杨枝甘露也早喝完了，但是为了完整复原，还是续上一杯咖啡继续肝。根据 vant 设计稿我们新增三个样式获取函数并动态化指定样式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getSizeHeight</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (props.<span class="property">size</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;large&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;mini&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">24</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">44</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getSizePadding</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (props.<span class="property">size</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;mini&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">15</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getSizeFontSize</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">switch</span> (props.<span class="property">size</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;large&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;small&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">12</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;mini&#x27;</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">10</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="number">14</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> styles = <span class="title class_">StyleSheet</span>.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">container</span>: &#123;</span><br><span class="line">    <span class="attr">paddingHorizontal</span>: <span class="title function_">getSizePadding</span>(),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">textStyle</span>: &#123;</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="title function_">getSizeFontSize</span>(),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">wrapper</span>: &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="title function_">getSizeHeight</span>(),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>实现效果如下：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/59c01002f25b477d85ed26fa1e21c86b~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="自定义颜色"><a href="#自定义颜色" class="headerlink" title="自定义颜色"></a>自定义颜色</h3><p>如果不是自己亲自复刻 Vant，是没想到一个 Button 能玩出这么多花，支持特性这么多耐心和代码管理都是一个挑战。当然了，洛竹采取的样式管理方式比较偏激，大家有好的方式也可以在评论区讨论。</p><p>通过 <code>color</code> 属性自定义按钮的颜色。我们可以得出需求，不管 type 是什么，<code>color</code> 属性需始终覆盖原有样式，color 能影响的就是背景色、字体颜色和边框颜色，所以我们修改 <code>getBackgroundColor</code>、<code>getTextColor</code>、<code>getBorderColor</code> 样式函数在合适的地方加上以下代码即可：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (props.<span class="property">color</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> props.<span class="property">color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8efffdbfd6424618be6152895a53e8ee~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="双击事件的实现"><a href="#双击事件的实现" class="headerlink" title="双击事件的实现"></a>双击事件的实现</h2><p>我们从 React Native 内置的 TouchableHighlight 组件继承了很多事件，其中 onPress、onLongPress 分别代表单击和长按。但唯独“双击 666”的双击事件没有姓名。之前在实际业务曾经封装过双击事件，这次我们就直接就内置了。</p><p>实现思路是延时执行单击事件（默认 200 毫秒），然后记录点击次数和两次时间间隔，当识别为第二次点击且时间间隔小于单击延时时间。那么就取消单击事件延时，并立即执行双击事件。完整代码如下：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastTime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">let</span> clickCount = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> timeout = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">_onPress</span> = (<span class="params">event: GestureResponderEvent</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> now = <span class="title class_">Date</span>.<span class="title function_">now</span>();</span><br><span class="line">  <span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">  &#125;</span><br><span class="line">  timeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    props.<span class="title function_">onPress</span>(event);</span><br><span class="line">    clickCount = <span class="number">1</span>;</span><br><span class="line">    lastTime = <span class="number">0</span>;</span><br><span class="line">  &#125;, props.<span class="property">delayDoublePress</span>);</span><br><span class="line">  <span class="keyword">if</span> (clickCount === <span class="number">2</span> &amp;&amp; now - lastTime &lt;= props.<span class="property">delayDoublePress</span>) &#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timeout);</span><br><span class="line">    clickCount = <span class="number">1</span>;</span><br><span class="line">    lastTime = <span class="number">0</span>;</span><br><span class="line">    props.<span class="title function_">onDoublePress</span>(event);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    clickCount++;</span><br><span class="line">    lastTime = now;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>大家会发现这里的实现糅合了函数防抖、节流以及计数器的原理，有兴趣的小伙伴可以自行复习下原理，这里就不展开了。</p><h2 id="API-文档"><a href="#API-文档" class="headerlink" title="API 文档"></a>API 文档</h2><p>一个组件的文档，除了 Demo，还需要展示出来可用的 Props，Dumi 内置的 <code>&lt;API&gt;&lt;/API&gt;</code> 组件可以根据组件自动生成 API 文档。首先我们像下面一样编写 Props 注释：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">ButtonProps</span> <span class="keyword">extends</span> <span class="title class_">TouchableHighlightProps</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>       Can be set to primary、info、warning、danger</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>.zh-CN 类型，可选值为 primary、info、warning、danger</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">type</span>?: <span class="string">&#x27;default&#x27;</span> | <span class="string">&#x27;primary&#x27;</span> | <span class="string">&#x27;info&#x27;</span> | <span class="string">&#x27;warning&#x27;</span> | <span class="string">&#x27;danger&#x27;</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>       Can be set to large、small、mini</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@description</span>.zh-CN 尺寸，可选值为</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  size?: <span class="string">&#x27;large&#x27;</span> | <span class="string">&#x27;normal&#x27;</span> | <span class="string">&#x27;small&#x27;</span> | <span class="string">&#x27;mini&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在 Markdown 中引入 API 组件即可：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">API</span> <span class="attr">src</span>=<span class="string">&quot;./index.tsx&quot;</span>&gt;</span></span><span class="language-xml"><span class="tag">&lt;/<span class="name">API</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>内置组件 API 没有处理继承的情况，我们后续会自定义一个 API 组件，这里就不展开了，浏览 <a href="https://vant-react-native.js.org/components/button#api">Button 文档</a> 可以查看现在的效果：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bedac7240334ff79c4142005a66b158~tplv-k3u1fbpfcp-watermark.image"></p><h2 id="工程化串讲"><a href="#工程化串讲" class="headerlink" title="工程化串讲"></a>工程化串讲</h2><p>由于很难在一篇文章中将组件开发相关的工程化讲完，我们需要在每篇实战中串讲一下。</p><h3 id="组件创建脚手架"><a href="#组件创建脚手架" class="headerlink" title="组件创建脚手架"></a>组件创建脚手架</h3><blockquote><p>小黑：洛竹，<code>lerna create</code> 命令创建出来的模块并不是我们想要的，以后要创建很多很多组件，我们可以写一个创建组件模块的脚手架吗？</p></blockquote><p>lerna 使用起来是有不少痛点的，<code>lerna create</code> 命令没办法指定模板，考虑到之后的几十上百个组件每次创建都要进行项目结构、Typescript 配置、单元测试配置、Babel 配置等等工作步骤，我们有必要写一个脚手架。</p><h4 id="模板解析"><a href="#模板解析" class="headerlink" title="模板解析"></a>模板解析</h4><p>说到模板解析，相信大家和我一样想到的是 vue-cli 的 template 解析。通过阅读 <a href="https://cdn.jsdelivr.net/npm/vue-cli@2.9.6/lib/generate.js">vue-cli@2.9.6 generate.js</a> 源码，我们可以分析出尤大是基于 metalsmith、handlebars、consolidate 这三个包来实现模板解析能力的。让人不安的是其中 metalsmith 库有长达 5 年没有维护了，洛竹挑选开源项目一般对维护度很敏感，本着轮子要用自己造的原则，我翻看了 Metalsmith 的 Readme 发现这个插件无非是通过递归读文件的方式渲染模板，并且它的静态网站生成的能力对我们模板解析的需求也是多余的。</p><p>说干就干，在和 <a href="https://juejin.cn/user/3175045313873943">@林小帅</a> 同学简单沟通后，我动手造了 <a href="https://github.com/youngjuning/handlebars-template-compiler">handlebars-template-compiler</a> 这个轮子，其主要原理如下：</p><ol><li>使用 recursive-readdir 递归获取所有文件路径</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> files = <span class="keyword">await</span> <span class="title function_">recursive</span>(rootDir);</span><br></pre></td></tr></table></figure><ol start="2"><li>使用 <code>handlebars.compile</code> 方法使用元数据对模板进行渲染</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> content = fs.<span class="title function_">readFileSync</span>(file).<span class="title function_">toString</span>();</span><br><span class="line"><span class="keyword">const</span> result = handlebars.<span class="title function_">compile</span>(content)(meta);</span><br></pre></td></tr></table></figure><ol start="3"><li>使用 <code>fs.writeFileSync</code> API 重写文件</li></ol><p>另外，通过引入 <a href="https://www.npmjs.com/package/micromatch">glob</a> 模式匹配实现了 <code>exclude</code> 配置以及只处理指定后缀（默认 <code>**/*.tpl.*</code>）的文件来避免不必要的渲染。（PS：NPM 一周有了 300 多下载，有需要的掘友值得一试😄）</p><h4 id="Node-CLI（-vant-react-native-x2F-scripts）搭建"><a href="#Node-CLI（-vant-react-native-x2F-scripts）搭建" class="headerlink" title="Node CLI（@vant-react-native&#x2F;scripts）搭建"></a>Node CLI（@vant-react-native&#x2F;scripts）搭建</h4><p>这里洛竹尝试用最简洁的语言为大家描述一个脚手架的诞生，源码在 <a href="https://github.com/youngjuning/vant-react-native/tree/main/packages/scripts">packages&#x2F;scripts</a> 目录下，没有接触过 CLI 的掘友请相信我，Node CLI 很容易上手的。接触过的同学也可以查漏补缺借鉴一二。</p><ol><li><code>package.json</code> 文件的 <code>bin</code> 字段是我们脚手架的入口</li></ol><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定可执行文件的位置以及别名</span></span><br><span class="line"><span class="attr">&quot;bin&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;vant&quot;</span><span class="punctuation">:</span> <span class="string">&quot;./bin/cli.js&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><ol start="2"><li>定义 <code>./bin/cli.js</code> 为可执行文件并调用 <code>init</code> 方法。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 由于我们的脚本是 Node 编写的，所以需要指定 node 所在位置</span></span><br><span class="line">#!<span class="regexp">/usr/</span>bin/env node</span><br><span class="line"><span class="keyword">const</span> &#123; init &#125; = <span class="built_in">require</span>(<span class="string">&#x27;../lib&#x27;</span>);</span><br><span class="line"><span class="comment">// 这个地方参考了 create-react-native 的设计</span></span><br><span class="line"><span class="comment">// 本文点赞过 300，下一篇洛竹带小黑为大家带来《基于 TypeScript 重构 create-react-native》</span></span><br><span class="line"><span class="title function_">init</span>();</span><br></pre></td></tr></table></figure><ol start="3"><li>然后在 <code>src/index.ts</code> 中初始化 commander 这个久负盛名的命令行框架</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> init = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> packageJson = <span class="built_in">require</span>(<span class="string">&#x27;../package.json&#x27;</span>);</span><br><span class="line">  program.<span class="title function_">version</span>(packageJson.<span class="property">version</span>).<span class="title function_">description</span>(packageJson.<span class="property">description</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  program.<span class="title function_">parse</span>(process.<span class="property">argv</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="4"><li>为了方便管理命令，我们将命令都放置在 <code>src/commands</code> 目录下并通过 <code>fs.readdirSync</code> API 动态扫描注册。</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> init = (): <span class="function"><span class="params">void</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 这段代码借鉴自 NeteaseCloudMusicApi 项目，作者的代码很有设计感，推荐阅读。</span></span><br><span class="line">  fs.<span class="title function_">readdirSync</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;commands&#x27;</span>)).<span class="title function_">forEach</span>(<span class="function">(<span class="params">file: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!file.<span class="title function_">endsWith</span>(<span class="string">&#x27;.js&#x27;</span>)) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">require</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;commands&#x27;</span>, file));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5"><li>最后在 <code>commands</code> 目录下新建一个 <code>create.ts</code> 文件编写命令</li></ol><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; program &#125; <span class="keyword">from</span> <span class="string">&#x27;commander&#x27;</span>;</span><br><span class="line">program</span><br><span class="line">  .<span class="title function_">command</span>(<span class="string">&#x27;create &lt;name&gt; [loc]&#x27;</span>)</span><br><span class="line">  .<span class="title function_">description</span>(<span class="string">&#x27;Create a new vant-react-native package&#x27;</span>)</span><br><span class="line">  .<span class="title function_">action</span>(<span class="function">(<span class="params">name,loc</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello Luozhu&#x27;</span>);</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="脚手架实现"><a href="#脚手架实现" class="headerlink" title="脚手架实现"></a>脚手架实现</h4><p>上一小结，我们初始化了 CLI 并添加了 <code>create</code> 命令，这一小节我们就来实现一下脚手架功能。</p><p>我们首先在 <code>packages/scripts</code> 目录下创建组件模板</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── README.tpl.md <span class="comment"># tpl 后缀在生成组件模板的时候会被 handlebars-template-compiler 自动去掉。</span></span><br><span class="line">├── package.tpl.json</span><br><span class="line">├── src</span><br><span class="line">│   └── index.ts <span class="comment"># 没有 tpl 后缀则不会被编译，模板很大时可以节省时间。</span></span><br><span class="line">└── tsconfig.json</span><br></pre></td></tr></table></figure><p>然后我们明确我们的模板元数据的数据结构，我这里的数据结构是：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IMeta</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">version</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">description</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">author</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">email</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">url</span>: <span class="built_in">string</span>;</span><br><span class="line">  <span class="attr">directory</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了数据结构，我们就可以使用 inquirer 模块引导用户输入信息。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inquirer <span class="keyword">from</span> <span class="string">&#x27;inquirer&#x27;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// getQuestions 过长，感兴趣的同学可以查看：http://tny.im/UFbg</span></span><br><span class="line"><span class="keyword">const</span> <span class="attr">answer</span>: <span class="title class_">IMeta</span> = <span class="keyword">await</span> inquirer.<span class="title function_">prompt</span>(<span class="title function_">getQuestions</span>(name));</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>下一步，我们使用 <code>tmp-promise</code> 模块创建一个系统临时文件夹，并将前文提到的 template 文件夹的内容拷贝进去：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> tmp <span class="keyword">from</span> <span class="string">&#x27;tmp-promise&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> fs <span class="keyword">from</span> <span class="string">&#x27;fs-extra&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">const</span> tmpdir = <span class="keyword">await</span> tmp.<span class="title function_">dir</span>(&#123; <span class="attr">unsafeCleanup</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">fs.<span class="title function_">copySync</span>(path.<span class="title function_">join</span>(__dirname, <span class="string">&#x27;../../template&#x27;</span>), tmpdir.<span class="property">path</span>);</span><br></pre></td></tr></table></figure><p>最后，我们对临时文件夹的内容进行编译再拷贝到指定位置即可：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> htc <span class="keyword">from</span> <span class="string">&#x27;handlebars-template-compiler&#x27;</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">await</span> htc&lt;<span class="title class_">IMeta</span>&gt;(answer, tmpdir.<span class="property">path</span>);</span><br><span class="line">fs.<span class="title function_">copySync</span>(tmpdir.<span class="property">path</span>, <span class="string">`<span class="subst">$&#123;process.cwd()&#125;</span>/packages/<span class="subst">$&#123;locPath&#125;</span>`</span>);</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><p>折腾这一顿，让我们来看下成果吧：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ba477bcbd8b4ef6b880c7e8e5a095bc~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="Github-CODEOWENERS"><a href="#Github-CODEOWENERS" class="headerlink" title="Github CODEOWENERS"></a>Github CODEOWENERS</h3><p>大型的开源项目最难的不是技术问题，技术大咖永远不会缺。最难的其实是协作和后期维护。试想一下一个成百上千人参与的项目当有新的 pr 时，正常人根本无力去快速检索出需要谁去 review 代码。我们的 vant-react-native 由于是将每个组件单独发包维护，当参与的小伙伴多了也会产生这个困扰。</p><p>而 GitHub CODEOWNERS（代码所有者）就是为了解决这个问题的，在 5000+ 贡献者参与的 <a href="https://github.com/DefinitelyTyped/DefinitelyTyped">DefinitelyTyped</a> 项目中我们就可以看到它的身影。官方对代码所有者定义如下：</p><blockquote><p>你可以使用 CODEOWNERS 文件定义负责仓库代码的个人或团队。当有人修改代码并打开一个 pull request 时，将自动请求代码所有者进行审查。</p></blockquote><p>CODEOWNERS 文件使用遵循 gitignore 文件中所用大多数规则的模式，CODEOWNERS 文件位置一般位于 <code>.github/</code> 目录下。</p><p>在 vant-react-native，洛竹是仓库的最终负责人，所以是期望每个 pr 都可以分配给自己审查一下的。那么我们这就来实验一下吧，新建一个 <code>.github/CODEOWNERS</code> 文件并写入以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># This is a comment.</span><br><span class="line"># Each line is a file pattern followed by one or more owners.</span><br><span class="line"></span><br><span class="line"># These owners will be the default owners for everything in</span><br><span class="line"># the repo. Unless a later match takes precedence,</span><br><span class="line"># @youngjuning will be requested for review when someone opens a pull request.</span><br><span class="line">*       @youngjuning</span><br><span class="line"></span><br><span class="line"># In this example, @doctocat owns any files in the build/logs</span><br><span class="line"># directory at the root of the repository and any of its</span><br><span class="line"># subdirectories.</span><br><span class="line">/packages/ @luozhu1994</span><br></pre></td></tr></table></figure><p>一般如果文件具有代码所有者，则在打开拉取请求之前可以看到代码所有者是谁。在仓库中，你可以找到文件并悬停于一个锁图标上，悬浮之后会告诉你该文件所有者是谁：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/726bd5144a104902ae27ad31e1d46f93~tplv-k3u1fbpfcp-zoom-1.image"></p><p>然后我们提交一个 pr 看看效果：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf4cb8b7ef5c41989660e735e621fc4e~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="NPM-发包自动化"><a href="#NPM-发包自动化" class="headerlink" title="NPM 发包自动化"></a>NPM 发包自动化</h3><p>发包权限一般只有仓库所有者一个人拥有，但是 owner 同时维护好几个 NPM 账号，或者是 owner 忽然很忙将发布权限交给其他人管理员但是不便告知 NPM 账号该怎么办呢？答案是将 NPM 发包 CD（持续部署）化，公司一般会基于 Gitlab 或自建平台实现该功能。作为开源项目，我们当然是使用 GitHub Action。</p><p>正常的单包项目，使用 <a href="https://github.com/JS-DevTools/npm-publish">npm-publish</a> 或 <a href="https://github.com/pascalgn/npm-publish-action">npm-publish-action</a> 这两个 GitHub Action，这并没有好讲的。但是基于 lerna 的多包单体仓库并没有现成的插件可以用，照例，我们来看下自己实现的步骤：</p><ol><li>判断 commit message 是否以 <code>chore(release):</code> 开头<blockquote><p>通过 GitHub Action <code>startsWith(github.event.head_commit.message, &#39;chore(release):&#39;)</code> 实现</p></blockquote></li><li>通过 NPM publish token 认证登录<blockquote><p>通过 <code>npm config set //registry.npmjs.org/:_authToken=$&#123;&#123; secrets.NPM_TOKEN &#125;&#125;</code> 认证</p></blockquote></li><li>执行 <code>lerna publish from-package --yes</code> 发布<blockquote><p>需要本地先执行 <code>lerna version</code> 系列命令提升版本</p></blockquote></li></ol><p>完整 GitHub Action 实现如下：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">npm-publish</span></span><br><span class="line"></span><br><span class="line"><span class="attr">on:</span></span><br><span class="line">  <span class="attr">push:</span></span><br><span class="line">    <span class="attr">branches:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="string">main</span></span><br><span class="line"></span><br><span class="line"><span class="attr">jobs:</span></span><br><span class="line">  <span class="attr">npm-publish:</span></span><br><span class="line">    <span class="attr">runs-on:</span> <span class="string">ubuntu-latest</span></span><br><span class="line">    <span class="attr">if:</span> <span class="string">startsWith(github.event.head_commit.message,</span> <span class="string">&#x27;chore(release):&#x27;</span><span class="string">)</span></span><br><span class="line">    <span class="attr">steps:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">actions/checkout@v2</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">uses:</span> <span class="string">c-hive/gha-yarn-cache@v2</span> <span class="comment"># 缓存 node_modules 加快构建速度</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Install</span> <span class="string">Packages</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">yarn</span> <span class="string">install</span> <span class="string">--registry=https://registry.npmjs.org/</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Authenticate</span> <span class="string">with</span> <span class="string">Registry</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">|</span></span><br><span class="line"><span class="string">          npm config set //registry.npmjs.org/:_authToken=$&#123;NPM_TOKEN&#125;</span></span><br><span class="line"><span class="string"></span>        <span class="attr">env:</span></span><br><span class="line">          <span class="attr">NPM_TOKEN:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.NPM_TOKEN</span> <span class="string">&#125;&#125;</span></span><br><span class="line">      <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Publish</span> <span class="string">package</span></span><br><span class="line">        <span class="attr">run:</span> <span class="string">lerna</span> <span class="string">publish</span> <span class="string">from-package</span> <span class="string">--yes</span></span><br></pre></td></tr></table></figure><p>为了在发布后及时获取通知，洛竹使用了 <code>peter-evans/commit-comment</code> 插件在发布失败或成功后对相应 commit 进行评论，这样我们就可以收到邮件和站内通知。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">commit</span> <span class="string">comment</span> <span class="string">after</span> <span class="string">publish</span> <span class="string">successfully</span></span><br><span class="line">  <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">success()</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">peter-evans/commit-comment@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">body:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      Hello Dear @youngjuning. This commit has been publish to NPM successfully.</span></span><br><span class="line"><span class="string">      &gt; Created by [commit-comment][1]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      [<span class="number">1</span>]<span class="string">:</span> <span class="string">https://github.com/peter-evans/commit-comment</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Create</span> <span class="string">commit</span> <span class="string">comment</span> <span class="string">after</span> <span class="string">publish</span> <span class="string">unsuccessfully</span></span><br><span class="line">  <span class="attr">if:</span> <span class="string">$&#123;&#123;</span> <span class="string">failure()</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="attr">uses:</span> <span class="string">peter-evans/commit-comment@v1</span></span><br><span class="line">  <span class="attr">with:</span></span><br><span class="line">    <span class="attr">body:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      Hello Dear @youngjuning. This commit has been publish to NPM unsuccessfully.</span></span><br><span class="line"><span class="string">      &gt; Created by [commit-comment][1]</span></span><br><span class="line"><span class="string"></span></span><br><span class="line">      [<span class="number">1</span>]<span class="string">:</span> <span class="string">https://github.com/peter-evans/commit-comment</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;⚠️本文为掘金社区首发签约文章，未获授权禁止转载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;大家好，我是&lt;a href=&quot;https://youngjuning.js.org/&quot;&gt;洛竹🎋&lt;/a&gt;，一只住在杭城的木系前端�</summary>
      
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="组件化" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
    
    <category term="React Native" scheme="https://youngjuning.js.org/tags/React-Native/"/>
    
    <category term="前端" scheme="https://youngjuning.js.org/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="组件化" scheme="https://youngjuning.js.org/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
    <category term="组件库" scheme="https://youngjuning.js.org/tags/%E7%BB%84%E4%BB%B6%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>掘金一下 | 从零开发一款基于 webview 的 vscode 扩展</title>
    <link href="https://youngjuning.js.org/609531a3ab52/"/>
    <id>https://youngjuning.js.org/609531a3ab52/</id>
    <published>2023-02-28T16:55:47.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>⚠️本文为掘金社区首发签约文章，未获授权禁止转载</p></blockquote><blockquote><p>温馨提示：结合本文配套<a href="https://github.com/youngjuning/juejin-me">源码</a>阅读体验更佳！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在团队降本提效的基建中，洛竹开发了一款 vscode 插件，第一版我使用的是 vscode 内置 UI，虽说也能用，但是用户体验欠佳。由于 vscode 内置 UI 不够灵活，一番调研后我决定使用 webview 重构。</p><p>开发过 vscode 插件的同学可能对插件开发知识点多、文档阅读困难、参考资料少有所体会。基于 webview 开发插件更是如此，寻遍网络，虽然有优秀的项目，但却没有完整且优秀的教程。为了修炼 vscode 开发灵力，不妨和洛竹一起挑战从零到一开发一款基于 webview 的 vscode 插件。</p><h2 id="Hello-vscode"><a href="#Hello-vscode" class="headerlink" title="Hello vscode"></a>Hello vscode</h2><p>英雄多起于市井，高楼皆起于平地。再伟大的软件也都是从 Hello World 开始的，本章尽量用最简洁的语言描述一个 vscode 插件 Hello World 的诞生。</p><h3 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h3><p>安装 <a href="http://yeoman.io/">Yeoman</a> 和 <a href="https://www.npmjs.com/package/generator-code">VS Code Extension Generator</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g yo generator-code</span><br></pre></td></tr></table></figure><p>这个脚手架会生成一个可以立马开发的项目。运行生成器，然后填好下列字段：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ yo code</span><br><span class="line"><span class="comment">#     _-----_     ╭──────────────────────────╮</span></span><br><span class="line"><span class="comment">#    |       |    │   Welcome to the Visual  │</span></span><br><span class="line"><span class="comment">#    |--(o)--|    │   Studio Code Extension  │</span></span><br><span class="line"><span class="comment">#   `---------´   │        generator!        │</span></span><br><span class="line"><span class="comment">#    ( _´U`_ )    ╰──────────────────────────╯</span></span><br><span class="line"><span class="comment">#    /___A___\   /</span></span><br><span class="line"><span class="comment">#     |  ~  |</span></span><br><span class="line"><span class="comment">#   __&#x27;.___.&#x27;__</span></span><br><span class="line"><span class="comment"># ´   `  |° ´ Y `</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ? What type of extension do you want to create? New Extension (TypeScript)</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the name of your extension? Juejin Posts</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the identifier of your extension? juejin-posts</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the description of your extension? 掘金文章管理</span></span><br><span class="line"><span class="comment"># ? Initialize a git repository? Yes</span></span><br><span class="line"><span class="comment"># ? Bundle the source code with webpack? No</span></span><br><span class="line"><span class="comment"># ? Which package manager to use? yarn</span></span><br><span class="line"></span><br><span class="line">$ code ./juejin-posts</span><br></pre></td></tr></table></figure><blockquote><p>提交记录：<a href="https://is.gd/IaJdlW">hello world</a></p></blockquote><h3 id="代码规范"><a href="#代码规范" class="headerlink" title="代码规范"></a>代码规范</h3><p>默认的脚手架生成的也有 ESLint 配置，但是 Editor、Prettier 的配置都没有，并且 ESLint 配置也不符合我的习惯。洛竹关于前端工程化的包都在 <a href="https://github.com/youngjuning/luozhu">youngjuning&#x2F;luozhu</a>， ESlint 配置的包是 <code>@luozhu/eslint-config-*</code>。由于我们开发插件使用的是 Typescript，所以我们选择 <code>@luozhu/eslint-config-typescript</code>。</p><p><strong>安装依赖：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add @luozhu/eslint-config-typescript @luozhu/prettier-config prettier -D</span><br></pre></td></tr></table></figure><p><strong>具体配置：</strong></p><p>配置涉及文件较多，请参考 <a href="https://github.com/youngjuning/luozhu#coding-style">coding-style</a>，不关心的同学也可以直接略过。</p><p><strong>提交检测：</strong></p><p>安装依赖：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add lint-staged yorkie -D</span><br></pre></td></tr></table></figure><p>修改配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// package.json</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;gitHooks&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;pre-commit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;lint-staged&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;lint-staged&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;**/*.&#123;js,jsx,ts,tsx&#125;&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;eslint --fix&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;**/*.&#123;md,json&#125;&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;prettier --write&quot;</span><span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>eslint –fix：</strong></p><p>修改完配置之后需要执行 fix 对所有文件格式化一次。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn lint --fix</span><br></pre></td></tr></table></figure><blockquote><p>提交记录：<a href="https://is.gd/xzFAVE">chore: code style config</a></p></blockquote><h3 id="约定式提交"><a href="#约定式提交" class="headerlink" title="约定式提交"></a>约定式提交</h3><p>约定式提交我使用的是渐进式脚手架 <code>@luozhu/create-commitlint</code>，在项目中执行 <code>npx @luozhu/create-commitlint</code> 即可使项目符合规范化提交的配置。对规范化提交不了解的同学，强烈建议读一下 <a href="https://juejin.cn/post/6877462747631026190/">一文搞定 Conventional Commits </a>。</p><blockquote><p>提交记录：<a href="https://is.gd/Ld142y">chore: npx @luozhu&#x2F;create-commitlint</a></p></blockquote><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>按下 <code>F5</code> 开启调试会出现[扩展开发宿主]窗口，然后按 <code>Command+Shift+P</code> 组件键输入 <code>Hello World</code> 命令。如下图所示 vscode 弹出了 <code>Hello World from Juejin Posts!</code> 的提示。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc26d7d429f84564b88b55e9df60fcd7~tplv-k3u1fbpfcp-zoom-1.image"></p><p>同时我们的开发窗口中，会出现一个 watch 任务的终端：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/75a15d0bd2cc4096af1a3f76173cbbe1~tplv-k3u1fbpfcp-zoom-1.image"></p><p>开发窗口的调试控制台会输出插件运行日志（忽略红色的警告）：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c31068ea0bca4d4793e35bdb16d70c0a~tplv-k3u1fbpfcp-zoom-1.image"></p><p>调试执行的任务是在 <code>.vscode/tasks.json</code> 中配置的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// See https://go.microsoft.com/fwlink/?LinkId=733558</span></span><br><span class="line"><span class="comment">// for the documentation about the tasks.json format</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;2.0.0&quot;</span><span class="punctuation">,</span> <span class="comment">// 配置的版本号。</span></span><br><span class="line"><span class="attr">&quot;tasks&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span> <span class="comment">// 任务配置。通常是外部任务运行程序中已定义任务的扩充。</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm&quot;</span><span class="punctuation">,</span> <span class="comment">// 要自定义的任务类型。</span></span><br><span class="line"><span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="string">&quot;watch&quot;</span><span class="punctuation">,</span> <span class="comment">// 要自定义的 npm 脚本。</span></span><br><span class="line"><span class="attr">&quot;problemMatcher&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$tsc-watch&quot;</span><span class="punctuation">,</span> <span class="comment">// 要使用的问题匹配程序。可以是一个字符串或一个问题匹配程序定义，也可以是一个字符串数组和多个问题匹配程序。</span></span><br><span class="line"><span class="attr">&quot;isBackground&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span> <span class="comment">// 执行的任务是否保持活动状态并在后台运行。</span></span><br><span class="line"><span class="attr">&quot;presentation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 配置用于显示任务输出并读取其输入的面板。</span></span><br><span class="line"><span class="attr">&quot;reveal&quot;</span><span class="punctuation">:</span> <span class="string">&quot;never&quot;</span> <span class="comment">// 控制运行任务的终端是否显示。可按选项 &quot;revealProblems&quot; 进行替代。默认设置为“始终”。</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="comment">// 定义此任务属于的执行组。它支持 &quot;build&quot; 以将其添加到生成组，也支持 &quot;test&quot; 以将其添加到测试组。</span></span><br><span class="line"><span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;build&quot;</span><span class="punctuation">,</span> <span class="comment">// 任务的执行组。</span></span><br><span class="line"><span class="attr">&quot;isDefault&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span> <span class="comment">// 定义此任务是否为组中的默认任务。</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>我们的插件开发完成前，想要分享给小伙伴体验可以吗？答案是肯定的，vscode 为我们提供了 <a href="https://github.com/microsoft/vscode-vsce">vsce</a> 实现这个需求，我们将 vsce 模块安装到全局，然后使用 <code>vsce package</code> 命令尝试打包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vsce package</span><br><span class="line"> ERROR  Missing publisher name. Learn more: https://code.visualstudio.com/api/working-with-extensions/publishing-extension<span class="comment">#publishing-extensions</span></span><br></pre></td></tr></table></figure><p>啊，咋还报错了？<code>publisher</code> 是啥？？一脸懵逼。不慌，按<a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension#create-a-publisher">链接</a> 我知道了 publisher 是一个可以将扩展发布到Visual Studio Code Marketplace 的身份。每个扩展都需要在其 <code>package.json</code> 文件中包含一个发布者名称。如果注册发布者我们后面详说，这里我们把 <code>publisher</code> 设置为 <code>luozhu</code>。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ vsce package</span><br><span class="line"> INFO  Detected presence of yarn.lock. Using <span class="string">&#x27;yarn&#x27;</span> instead of <span class="string">&#x27;npm&#x27;</span> (to override this pass <span class="string">&#x27;--no-yarn&#x27;</span> on the <span class="built_in">command</span> line).</span><br><span class="line"> ERROR  Make sure to edit the README.md file before you package or publish your extension.</span><br></pre></td></tr></table></figure><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cf561381232b4690a5d7cd0378c267d7~tplv-k3u1fbpfcp-zoom-1.image"></p><p>额，裂开，这咋还报错，假装淡定，读一下提示原来是要我们编辑一下 README.md，没错，vscode 模板里有初始的 README，我们需要编辑一下才可以打包。修改后再次尝试 <code>vsce package</code>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/acfe2e957c9545578c7b6990371a3f0b~tplv-k3u1fbpfcp-zoom-1.image"></p><p>终于，打包成功！为了追求完美，最后我们再来做一些优化工作：</p><ol><li>执行 <code>vsce package</code> 的时候加上 <code>--no-yarn</code></li><li>在 <em>package.json</em> 中加上 <code>repository</code> 字段即可看不到任何警告。</li><li>为了便捷，我们将 vsce 安装到项目中，然后把 <code>vsce package --no-yarn</code> 添加到 npm scripts 中。</li><li><em>package.json</em> 加上 <code>license</code> 字段。</li></ol><p>然后再次尝试 <code>yarn package</code> 就完美了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4a9a251834b945c8a882039020f56e4f~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p>提示：vsce package 会先执行 <code>vscode:prepublish</code> 这个预发布脚本去编译项目。</p></blockquote><blockquote><p>提交记录：<a href="https://is.gd/ZCp4qU">chore: config vsce package</a></p></blockquote><h3 id="打包原理"><a href="#打包原理" class="headerlink" title="打包原理"></a>打包原理</h3><p>如过你也跟着一路敲到了这里，此时你会在项目根目录发现 <code>vsix</code> 结尾的文件：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/f2c0846bd66747ceab0c09524a209b28~tplv-k3u1fbpfcp-zoom-1.image"></p><p>这就是 vscode 插件的安装包，我们先不急着安装，先一起来看一下这个文件是个什么东西。尝试用归档工具解压后得到如下目录文件夹：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/182c365a0690467cb0bd8b0d1490c175~tplv-k3u1fbpfcp-zoom-1.image"></p><p>我们可以看到编译后的文件夹 <code>out</code> 和其他一些文件是被直接压缩进安装包的，聪明的你肯定发现了 <code>.cz-config.js</code>、<code>.prettierrc.js</code> 和 <code>commitlint.config.js</code> 这种开发时文件也被压缩了，运行插件完全用不到，这明显不合理。其实和其他插件体系一样，vscode 也提供了 <code>.vscodeignore</code> 来实现打包忽略配置，我们将以上无关文件忽略重新打包即可。</p><p>原理就这？不存在的，我们打开 <code>extension.js</code> 会发现引用了 <code>vscode</code> 这个包：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bb42881e49a94456aeac417f6b5cba71~tplv-k3u1fbpfcp-zoom-1.image"></p><p>但是我们的安装包中并没有 _node_modules_，那么 vscode 这个包存在在哪里呢？我猜的是挂在 node 环境上了，读了<a href="https://is.gd/33GTcH">源码</a>后我发现我竟然是对的：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5e796fcf81b64fd7a18d9c3e36fbefdf~tplv-k3u1fbpfcp-zoom-1.image"></p><p>vscode 实现了拦截器在加载 Node 环境的时候将 vscode 给添加到了内置包中，这样的好处是减小插件的体积。</p><p>那么我们如果使用三方插件呢？以常用的 lodash 为例，安装 lodash 之后重新打包：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ yarn package</span><br><span class="line">yarn run v1.22.10</span><br><span class="line">$ vsce package --no-yarn</span><br><span class="line">Executing prepublish script <span class="string">&#x27;npm run vscode:prepublish&#x27;</span>...</span><br><span class="line"></span><br><span class="line">&gt; juejin-posts@0.0.1 vscode:prepublish</span><br><span class="line">&gt; yarn run compile</span><br><span class="line"></span><br><span class="line">$ tsc -p ./</span><br><span class="line">This extension consists of 1060 files, out of <span class="built_in">which</span> 1049 are JavaScript files. For performance reasons, you should bundle your extension: https://aka.ms/vscode-bundle-extension . You should also exclude unnecessary files by adding them to your .vscodeignore: https://aka.ms/vscode-vscodeignore</span><br><span class="line"> DONE  Packaged: /Users/luozhu/Desktop/playground/juejin-posts/juejin-posts-0.0.1.vsix (1060 files, 644.72KB)</span><br><span class="line">✨  Done <span class="keyword">in</span> 5.54s.</span><br></pre></td></tr></table></figure><p>这个时候提示我们有 1000 多个文件，大概率 <em>node_modules</em> 文件夹被打包了，我们来解压下见证一下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/917b7742991640c9a0b03314cef24ce6~tplv-k3u1fbpfcp-zoom-1.image"></p><p>不出所料，vscode 默认的打包方式就是简单的编译拷贝，通过忽略文件减小体积也是杯水车薪。而且 vscode 扩展的规模往往增长很快。它们是在多个源文件中编写的，并依赖于 npm 的模块。分解和重用是开发的最佳实践，但在安装和运行扩展时，它们是有代价的。加载 100 个小文件要比加载一个大文件慢得多。这就是我们推荐捆绑的原因。捆绑是将多个小的源文件合并成一个文件的过程。</p><p>在 JavaScript 中，有不同的打包工具可以用，流行的有 rollup.js、Parcel、esbuild 和 webpack，官方脚手架默认只能选 webpack，我们这里推荐直接使用更快更强的 esbuild。</p><blockquote><p>提交记录：<a href="https://is.gd/ZCp4qU">chore: ignore config file when package</a>、<a href="https://is.gd/ggpQmv">chore: add esModuleInterop to tsconfig</a></p></blockquote><h3 id="使用-esbuild-优化打包"><a href="#使用-esbuild-优化打包" class="headerlink" title="使用 esbuild 优化打包"></a>使用 esbuild 优化打包</h3><p><strong>安装依赖：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn add -D esbuild</span><br></pre></td></tr></table></figure><p><strong>npm scripts：</strong></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&quot;scripts&quot;: &#123;</span><br><span class="line"><span class="deletion">-    &quot;vscode:prepublish&quot;: &quot;yarn run compile&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;compile&quot;: &quot;tsc -p ./&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;watch&quot;: &quot;tsc -watch -p ./&quot;,</span></span><br><span class="line"><span class="deletion">-    &quot;pretest&quot;: &quot;yarn run compile &amp;&amp; yarn run lint&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;vscode:prepublish&quot;: &quot;yarn esbuild-base --minify&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;esbuild-base&quot;: &quot;esbuild ./src/extension.ts --bundle --outfile=out/extension.js --external:vscode --format=cjs --platform=node&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;esbuild&quot;: &quot;yarn esbuild-base --sourcemap&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;esbuild-watch&quot;: &quot;yarn esbuild-base --sourcemap --watch&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;test-compile&quot;: &quot;tsc -p ./&quot;,</span></span><br><span class="line"><span class="addition">+    &quot;pretest&quot;: &quot;yarn test-compile &amp;&amp; yarn lint&quot;,</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：由于 watch 改成了 esbuild-watch，所以 <em>.vscode&#x2F;tasks.json</em> 中的 scripts 子段也需要做相应修改。</p></blockquote><p><strong>vscode tasks：</strong></p><p>理论上我们把打包命令改成 esbuild 之后，应该将 vscode 任务中的问题匹配程序设置为 <code>$esbuild-watch</code>，但是 vscode 会提示我们无法识别的问题匹配程序：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4b51c79ee1344b6f92a3f2efaf9ef7aa~tplv-k3u1fbpfcp-zoom-1.image"></p><p>尝试搜索扩展，果然有一个 esbuild Problem Matchers 插件，我们将其安装并添加 <code>&quot;connor4312.esbuild-problem-matchers&quot;</code> 到 <em>.vscode&#x2F;extensions.json</em> 文件的 <code>recommendations</code> 中。</p><p><strong>忽略文件：</strong></p><p>我们使用 esbuild 打包后会将使用到的代码都打包进 <code>out/extension.js</code>，但是 vsce 的打包机制是不管你有没有用到都会把 <code>dependencies</code> 中的包打进安装包中，所以我们需要将 <em><em>node_modules</em></em> 忽略掉。</p><p><strong>成果展示：</strong></p><p>从图中我们可以看到，安装包的体积大大减小了。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ba86286be7fc41f4b8325a3e0be0d2d2~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p>提交记录：<a href="https://is.gd/F12xNk">chore: config esbuild</a></p></blockquote><h2 id="集成-umijs"><a href="#集成-umijs" class="headerlink" title="集成 umijs"></a>集成 umijs</h2><h3 id="初始化-umi-项目"><a href="#初始化-umi-项目" class="headerlink" title="初始化 umi 项目"></a>初始化 umi 项目</h3><p>使用 umi 脚手架在根目录新建一个 <em>web</em> 目录。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> web &amp;&amp; <span class="built_in">cd</span> web</span><br></pre></td></tr></table></figure><p>通过官方工具创建项目：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ yarn create @umijs/umi-app</span><br></pre></td></tr></table></figure><p>修改 <em>.umirc.ts</em> 配置：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig, <span class="title class_">IConfig</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(&#123;</span><br><span class="line">  <span class="attr">nodeModulesTransform</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;none&#x27;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">component</span>: <span class="string">&#x27;@/pages/index&#x27;</span> &#125;],</span><br><span class="line">  <span class="attr">fastRefresh</span>: &#123;&#125;, <span class="comment">// 开发时可以保持组件状态，同时编辑提供即时反馈。</span></span><br><span class="line">  <span class="attr">history</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;memory&#x27;</span>, <span class="comment">// 默认的类型是 `browser`，但是由于 vscode webview 环境不存在浏览器路由，改成 `memory` 和 `hash` 都可以</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="comment">// 需要在 dev 时写文件到输出目录，这样保证开发阶段有 js/css 文件</span></span><br><span class="line">    <span class="attr">writeToDisk</span>: <span class="function"><span class="params">filePath</span> =&gt;</span></span><br><span class="line">      [<span class="string">&#x27;umi.js&#x27;</span>, <span class="string">&#x27;umi.css&#x27;</span>].<span class="title function_">some</span>(<span class="function"><span class="params">name</span> =&gt;</span> filePath.<span class="title function_">endsWith</span>(name)),</span><br><span class="line">  &#125;,</span><br><span class="line">&#125; <span class="keyword">as</span> <span class="title class_">IConfig</span>);</span><br></pre></td></tr></table></figure><p>修改 <code>package.json</code> 加入 <code>name</code>、<code>version</code>、<code>description</code>：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;web&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;web for juejin-posts&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p><strong>.gitignore：</strong></p><p>将 vscode 扩展和 umijs 脚手架生成的 gitignore 合并为一下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># See https://help.github.com/articles/ignoring-files/ for more about ignoring files.</span><br><span class="line"></span><br><span class="line"># vscode</span><br><span class="line">.vscode-test/</span><br><span class="line">*.vsix</span><br><span class="line"></span><br><span class="line"># dependencies</span><br><span class="line">node_modules</span><br><span class="line">npm-debug.log</span><br><span class="line">yarn-error.log</span><br><span class="line">package-lock.json</span><br><span class="line"></span><br><span class="line"># production</span><br><span class="line">out</span><br><span class="line">dist</span><br><span class="line"></span><br><span class="line"># misc</span><br><span class="line">.DS_Store</span><br><span class="line"></span><br><span class="line"># umi</span><br><span class="line">**/src/.umi</span><br><span class="line">**/src/.umi-production</span><br><span class="line">**/src/.umi-test</span><br><span class="line">**/.env.local</span><br><span class="line">web/yarn.lock</span><br></pre></td></tr></table></figure><p><strong>.vscodeignore：</strong></p><p>由于 vscode 打包的时候只需要获取 umijs 打包后的产物，所有加入 <code>web/**</code> 和 <code>!web/dist/**</code> 将无用的文件忽略掉。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">.vscode/**</span><br><span class="line">.vscode-test/**</span><br><span class="line">out/test/**</span><br><span class="line"></span><br><span class="line">src/**</span><br><span class="line">.gitignore</span><br><span class="line">.yarnrc</span><br><span class="line">vsc-extension-quickstart.md</span><br><span class="line">**/tsconfig.json</span><br><span class="line">**/*.map</span><br><span class="line">**/*.ts</span><br><span class="line"></span><br><span class="line">.cz-config.js</span><br><span class="line">.prettierrc.js</span><br><span class="line">.commitlintrc.js</span><br><span class="line">**/node_modules/**</span><br><span class="line">yarn-error.log</span><br><span class="line">web/**</span><br><span class="line">!web/dist/**</span><br></pre></td></tr></table></figure><h3 id="yarn-workspace"><a href="#yarn-workspace" class="headerlink" title="yarn workspace"></a>yarn workspace</h3><p>由于我们的项目是 vscode 扩展和 web 项目混合的项目。为了方便管理脚本和依赖，我们引入了 <code>yarn workspace</code> 来管理项目。在根目录的 <em>package.json</em> 中加入以下配置即可：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;private&quot;</span><span class="punctuation">:</span> <span class="string">&quot;true&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;workspaces&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;web&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="调试-1"><a href="#调试-1" class="headerlink" title="调试"></a>调试</h3><p>由于我们的 web 项目也需要编译，所以我们需要修改一下 vscode <code>launch.json</code> 加入 web 项目的编译任务。配置参考了 <a href="http://tny.im/bOqQT">appworks</a>。</p><p>首先在根目录的 <code>package.json</code> 的 scripts 中添加:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;web-build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn workspace web run build&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;web-watch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn workspace web run start&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后修改 <em>.vscode&#x2F;launch.json</em> 配置为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A launch configuration that compiles the extension and then opens it inside a new window</span></span><br><span class="line"><span class="comment">// Use IntelliSense to learn about possible attributes.</span></span><br><span class="line"><span class="comment">// Hover to view descriptions of existing attributes.</span></span><br><span class="line"><span class="comment">// For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0.2.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;compounds&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="comment">// 复合列表。每个复合可引用多个配置，这些配置将一起启动。</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Debug Extension&quot;</span><span class="punctuation">,</span> <span class="comment">// 复合的名称。在启动配置下拉菜单中显示。</span></span><br><span class="line">      <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="comment">// 将作为此复合的一部分启动的配置名称。</span></span><br><span class="line">        <span class="string">&quot;Run Extension&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="string">&quot;Watch Webview&quot;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;presentation&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;order&quot;</span><span class="punctuation">:</span> <span class="number">0</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;configurations&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Watch Webview&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;attach&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;node&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;npm: web-watch&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Run Extension&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;extensionHost&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;request&quot;</span><span class="punctuation">:</span> <span class="string">&quot;launch&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;args&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;--extensionDevelopmentPath=$&#123;workspaceFolder&#125;&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;outFiles&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;$&#123;workspaceFolder&#125;/out/**/*.js&quot;</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;preLaunchTask&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$&#123;defaultBuildTask&#125;&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>完成后进入 VS Code，按下<code>F5</code>，你会立即看到一个<strong>插件发开主机</strong>窗口，其中就运行着插件。这时候运行你会发现控制台报一下错误 ❌：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">error TS6059: File &#x27;/Users/luozhu/Desktop/github/juejin-posts/web/src/pages/index.tsx&#x27; is not under &#x27;rootDir&#x27; &#x27;/Users/luozhu/Desktop/github/juejin-posts/src&#x27;. &#x27;rootDir&#x27; is expected to contain all source files.</span><br><span class="line">  The file is in the program because:</span><br><span class="line">    Matched by include pattern &#x27;**/*&#x27; in &#x27;/Users/luozhu/Desktop/github/juejin-posts/tsconfig.json&#x27;</span><br></pre></td></tr></table></figure><p>原因是因为 umi 的约定的项目结构和 vscode extension 都包含 <em>src</em> 目录。由于 vscode 插件和 umi 的编译是分开的，我们在根目录的 <em>tsconfig.json</em> 中将 <em>web</em> 目录忽略即可：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;exclude&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;web&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>现在，你可以按下 <code>F5</code> 看到<strong>插件发开主机</strong>窗口的同时还会看到两个调试任务：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d4b3b6f2522643fb9bc574e2f9982775~tplv-k3u1fbpfcp-zoom-1.image"></p><blockquote><p>注意📢：请选择 Debug Extension 调试任务而不是 Run Extension</p></blockquote><h3 id="其他优化工作"><a href="#其他优化工作" class="headerlink" title="其他优化工作"></a>其他优化工作</h3><ol><li>由于基于 yarn workspace，我们把公用的依赖合并</li><li>合并 Eslint 配置并使用 <code>@luozhu/eslint-config-react-typescrip</code></li><li>合并 Editorconfig 和 Prettier 配置</li><li>添加 <code>prestart</code> 和 <code>prebuild</code> script</li><li>设置 <code>HTML=none umi build</code></li></ol><blockquote><p>提交记录：<a href="https://is.gd/bt3WHr">chore: config umijs</a></p></blockquote><h2 id="vscode-插件开发核心概念"><a href="#vscode-插件开发核心概念" class="headerlink" title="vscode 插件开发核心概念"></a>vscode 插件开发核心概念</h2><p>在开始 webview 能力开发之前，我们有必要了解一下 vscode 插件开发的核心概念。为了有个全局的理解，我们先来看下我们现在项目的主要目录结构：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── CHANGELOG.md <span class="comment"># 基于 standard-version 生成的更新日志文件</span></span><br><span class="line">├── README.md</span><br><span class="line">├── package.json <span class="comment"># vscode 包配置文件，诸如插件 LOGO、名字、描述、注册激活事件</span></span><br><span class="line">├── src</span><br><span class="line">│   └── extension.ts <span class="comment"># 插件入口文件，暴露 activate 方法用于注册命令和初始化一些配置，暴露 deactivate 方法用于插件关闭前执行清理工作</span></span><br><span class="line">├── tsconfig.json <span class="comment"># vscode 的编译配置</span></span><br><span class="line">├── web <span class="comment"># 基于 umi 的 web，也是我们后边 webview 要承载的内容</span></span><br><span class="line">└── yarn.lock</span><br></pre></td></tr></table></figure><p>从目录结构可以看出，关键的文件是 <code>package.json</code> 和 <code>extension.ts</code>，我们以 helloWorld 命令为例介绍下 vscode 插件的三个核心概念。</p><h3 id="1-激活事件"><a href="#1-激活事件" class="headerlink" title="1. 激活事件"></a>1. 激活事件</h3><p><strong>激活事件</strong>是在 <code>package.json</code> 中的 <code>activationEvents</code> 字段声明的一个 JSON 数组对象。为了注册 helloWorld 这个命令，第一步就是注册激活事件，激活事件类型有很多，注册命令的激活事件是 <code>onCommand</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;activationEvents&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="string">&quot;onCommand:juejin-posts.helloWorld&quot;</span><span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-发布内容配置"><a href="#2-发布内容配置" class="headerlink" title="2. 发布内容配置"></a>2. 发布内容配置</h3><p>发布内容配置（ 即 VS Code 为插件扩展提供的配置项）是 <code>package.json</code> 的 <code>contributes</code> 字段，你可以在其中注册各种配置项扩展 VS Code 的能力。上一步我们注册的 helloWorld 激活事件只是告诉了 vscode 可以通过 <code>juejin-posts.helloWorld</code> 命令触发。我们还需要再 <code>contributes.commands</code> 中注册我们的 <code>juejin-posts.helloWorld</code> 命令：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;contributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;juejin-posts.helloWorld&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Hello World&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="3-VS-Code-API"><a href="#3-VS-Code-API" class="headerlink" title="3. VS Code API"></a>3. VS Code API</h3><p><strong>VS Code API</strong> 是 VS Code 提供给插件使用的一系列 Javascript API。通过前两个核心概念的能力，我们已经注册好了命令和事件，那么下一步必然就是注册事件回调。事件回调在 vscode 中是通过 <code>vscode.commands.registerCommand</code> 函数来注册的，下面 👇🏻 是我们在入口文件 <code>src/extension.ts</code> 中注册 <code>juejin-posts.helloWorld</code> 命令。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vscode 这个模块包含了 VS Code 扩展的 API</span></span><br><span class="line"><span class="keyword">import</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个方法当你的扩展激活时调用，扩展会在命令首次执行时激活</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) &#123;</span><br><span class="line">  <span class="comment">// 当你的扩展被激活时，这行代码将只被执行一次</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// 使用 console.log 输出日志信息或使用 console.error 输出错误信息。</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Congratulations, your extension &quot;juejin-posts&quot; is now active!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 入口命令已经在 package.json 文件中定义好了，现在调用 registerCommand 方法</span></span><br><span class="line">  <span class="comment">// registerCommand 中的参数必须与 package.json 中的 command 保持一致</span></span><br><span class="line">  <span class="keyword">const</span> disposable = vscode.<span class="property">commands</span>.<span class="title function_">registerCommand</span>(<span class="string">&#x27;juejin-posts.helloWorld&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 把你的代码写在这里，每次命令执行时都会调用这里的代码</span></span><br><span class="line">    <span class="comment">// 给用户显示一个消息提示</span></span><br><span class="line">    vscode.<span class="property">window</span>.<span class="title function_">showInformationMessage</span>(<span class="string">&#x27;Hello World from Juejin Posts!&#x27;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(disposable);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当你的扩展被停用时，这个方法被调用。</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">deactivate</span>(<span class="params"></span>) &#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="集成-webview"><a href="#集成-webview" class="headerlink" title="集成 webview"></a>集成 webview</h2><h3 id="注册命令"><a href="#注册命令" class="headerlink" title="注册命令"></a>注册命令</h3><p>1、<em>package.json</em> 激活事件（<code>activationEvents</code>）中添加 <code>&quot;onCommand:juejin-posts.start&quot;</code></p><p>2、<em>package.json</em> 命令（<code>commands</code>）中添加：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;juejin-posts.start&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;start&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Juejin Posts&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>3、<em>src&#x2F;extension.ts</em> 中注册命令</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(</span><br><span class="line">  vscode.<span class="property">commands</span>.<span class="title function_">registerCommand</span>(<span class="string">&#x27;juejin-posts.start&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// Truth is endless. Keep coding...</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="创建-webview-面板"><a href="#创建-webview-面板" class="headerlink" title="创建 webview 面板"></a>创建 webview 面板</h3><h4 id="创建一个空白的面板"><a href="#创建一个空白的面板" class="headerlink" title="创建一个空白的面板"></a>创建一个空白的面板</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建并显示新的webview</span></span><br><span class="line"><span class="keyword">const</span> panel = vscode.<span class="property">window</span>.<span class="title function_">createWebviewPanel</span>(</span><br><span class="line">  <span class="string">&#x27;juejin-posts&#x27;</span>, <span class="comment">// 只供内部使用，这个 webview 的标识</span></span><br><span class="line">  <span class="string">&#x27;Juejin Posts&#x27;</span>, <span class="comment">// 给用户显示的面板标题</span></span><br><span class="line">  vscode.<span class="property">vscode</span>.<span class="property">ViewColumn</span>.<span class="property">One</span>, <span class="comment">// 给新的 webview 面板一个编辑器视图</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">enableScripts</span>: <span class="literal">true</span>, <span class="comment">// 启用 javascript 脚本</span></span><br><span class="line">    <span class="attr">retainContextWhenHidden</span>: <span class="literal">true</span>, <span class="comment">// 隐藏时保留上下文</span></span><br><span class="line">  &#125; <span class="comment">// webview 面板的内容配置</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>我们使用了 <a href="https://vscode-api.js.org/modules/window.html#createWebviewPanel">window.createWebviewPanel</a> API 创建了一个 webview 面板，现在我们尝试运行 <code>juejin-posts.start</code> 就可以打开一个 webview 面板：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d85ad985232542f587376e5073feb1a1~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="给面板设置内容"><a href="#给面板设置内容" class="headerlink" title="给面板设置内容"></a>给面板设置内容</h4><p>上面我们创建了一个空白的面板，那么我们如何给面板添加内容呢？我们可以使用 <code>panel.webview.html</code> 来设置 HTML 内容：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getWebviewContent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">    &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">    &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;title&gt;Juejin Posts&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;style&gt;</span></span><br><span class="line"><span class="string">          html, body &#123;</span></span><br><span class="line"><span class="string">            padding: 0px;</span></span><br><span class="line"><span class="string">            height: 100vh;</span></span><br><span class="line"><span class="string">            position: relative;</span></span><br><span class="line"><span class="string">            margin: 0;</span></span><br><span class="line"><span class="string">            padding: 0;</span></span><br><span class="line"><span class="string">            overflow: hidden;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          #yoyo &#123;</span></span><br><span class="line"><span class="string">            position: absolute;</span></span><br><span class="line"><span class="string">            bottom: 50px;</span></span><br><span class="line"><span class="string">            right: -90px;</span></span><br><span class="line"><span class="string">            opacity: 0;</span></span><br><span class="line"><span class="string">            transition: .25s ease-in-out</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">          #yoyo:hover &#123;</span></span><br><span class="line"><span class="string">            opacity: 1;</span></span><br><span class="line"><span class="string">            right: 0;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &lt;/style&gt;</span></span><br><span class="line"><span class="string">    &lt;/head&gt;</span></span><br><span class="line"><span class="string">    &lt;body&gt;</span></span><br><span class="line"><span class="string">      &lt;a href=&quot;https://juejin.cn&quot;&gt;&lt;img id=&quot;yoyo&quot; src=&quot;https://cdn.jsdelivr.net/gh/youngjuning/images/20210817163229.png&quot; width=&quot;100&quot; /&gt;&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 给 webview panel 设置 HTML 内容</span></span><br><span class="line">panel.<span class="property">webview</span>.<span class="property">html</span> = <span class="title function_">getWebviewContent</span>();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>重新使用 <code>juejin-posts.start</code> 命令就可以调戏悠悠船长了：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5160d0c76536441b8d1ac3cfcedc0d0e~tplv-k3u1fbpfcp-zoom-1.image"></p><h4 id="限制-webview-视图为一个"><a href="#限制-webview-视图为一个" class="headerlink" title="限制 webview 视图为一个"></a>限制 webview 视图为一个</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) &#123;</span><br><span class="line">  <span class="comment">// 追踪当前 webview 面板</span></span><br><span class="line">  <span class="keyword">let</span> <span class="attr">currentPanel</span>: vscode.<span class="property">WebviewPanel</span> | <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">  context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(</span><br><span class="line">    vscode.<span class="property">commands</span>.<span class="title function_">registerCommand</span>(<span class="string">&#x27;juejin-posts.start&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 获取当前活动的编辑器</span></span><br><span class="line">      <span class="keyword">const</span> columnToShowIn = vscode.<span class="property">window</span>.<span class="property">activeTextEditor</span></span><br><span class="line">        ? vscode.<span class="property">window</span>.<span class="property">activeTextEditor</span>.<span class="property">viewColumn</span></span><br><span class="line">        : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (currentPanel) &#123;</span><br><span class="line">        <span class="comment">// 如果我们已经有了一个面板，那就把它显示到目标列布局中</span></span><br><span class="line">        currentPanel.<span class="title function_">reveal</span>(columnToShowIn);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不然，创建一个新面板</span></span><br><span class="line">        currentPanel = vscode.<span class="property">window</span>.<span class="title function_">createWebviewPanel</span>();</span><br><span class="line">        <span class="comment">// 当前面板被关闭后重置</span></span><br><span class="line">        currentPanel.<span class="title function_">onDidDispose</span>(</span><br><span class="line">          <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            currentPanel = <span class="literal">undefined</span>;</span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="literal">null</span>,</span><br><span class="line">          context.<span class="property">subscriptions</span></span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><a href="https://vscode-api-cn.js.org/modules/window.html#activeTextEditor">vscode.window.activeTextEditor</a>：获取当前活动的文本编辑器</li><li><a href="https://vscode-api-cn.js.org/interfaces/WebviewPanel.html#reveal">currentPanel.reveal()</a>：调用 <code>reveal()</code> 或者拖动 webview 面板到新的编辑布局中去。</li></ul><h4 id="设置-Icon"><a href="#设置-Icon" class="headerlink" title="设置 Icon"></a>设置 Icon</h4><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 Logo</span></span><br><span class="line">panel.<span class="property">iconPath</span> = vscode.<span class="property">Uri</span>.<span class="title function_">file</span>(</span><br><span class="line">  path.<span class="title function_">join</span>(context.<span class="property">extensionPath</span>, <span class="string">&#x27;assets&#x27;</span>, <span class="string">&#x27;icon-juejin.png&#x27;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在 vscode 扩展中我们需要通过 <code>vscode.Uri.file</code> 方法获取磁盘上的资源路径。</p><h4 id="webview-获取内容的-Uri"><a href="#webview-获取内容的-Uri" class="headerlink" title="webview 获取内容的 Uri"></a>webview 获取内容的 Uri</h4><p>你应该使用 <code>asWebviewUri</code> 管理插件资源。不要硬编码 <code>vscode-resource://</code>，而是使用 <code>asWebviewUri</code> 确保你的插件在云端环境也能正常运行。</p><p>在 <a href="http://tny.im/jb4go">@luozhu&#x2F;vscode-utils</a> 中我们对获取本地资源路径做了封装：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取内容的 Uri</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getDiskPath</span> = (<span class="params">fileName: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> webviewPanel.<span class="property">webview</span>.<span class="title function_">asWebviewUri</span>(</span><br><span class="line">    vscode.<span class="property">Uri</span>.<span class="title function_">file</span>(path.<span class="title function_">join</span>(context.<span class="property">extensionPath</span>, rootPath, <span class="string">&#x27;dist&#x27;</span>, fileName))</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="使用-umi-开发-webview"><a href="#使用-umi-开发-webview" class="headerlink" title="使用 umi 开发 webview"></a>使用 umi 开发 webview</h3><p>上一节我们通过调戏悠悠船长熟悉了 webview 面板的创建，这一节我们来看下如何使用 umijs 来代替 HTML 的内容。</p><p><code>panel.webview.html</code> 中的内容其实就是正常的 HTML+JavaScript+CSS 代码。你可以使用任何前端技术去编写它的内容，比如 jquery、bootstrap、Vue 以及 React。虽然本文的例子是基于 umijs 开发 webview 的内容，但是其他技术原理是一样的，洛竹在后续也会提供多个技术的 vscode webview 开发脚手架。</p><h4 id="封装获取-umijs-打包产物的方法"><a href="#封装获取-umijs-打包产物的方法" class="headerlink" title="封装获取 umijs 打包产物的方法"></a>封装获取 umijs 打包产物的方法</h4><p>我们知道 <code>umi build</code> 命令会在 <em>web&#x2F;dist</em> 产生 index.html、umi.js、umi.css 三个文件，我们根据 index.html 改造前面的 getWebviewContent 方法如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> path <span class="keyword">from</span> <span class="string">&#x27;path&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取基于 umijs 的 webview 内容</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> context 扩展上下文</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> webviewPanel webview 面板对象</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rootPath webview 所在路径，默认 web</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> umiVersion umi 版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@returns</span> <span class="variable">string</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">getUmiContent</span> = (<span class="params"></span></span><br><span class="line"><span class="params">  context: vscode.ExtensionContext,</span></span><br><span class="line"><span class="params">  webviewPanel: vscode.WebviewPanel,</span></span><br><span class="line"><span class="params">  umiVersion?: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">  rootPath = <span class="string">&#x27;web&#x27;</span></span></span><br><span class="line"><span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 获取磁盘上的资源路径</span></span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getDiskPath</span> = (<span class="params">fileName: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> webviewPanel.<span class="property">webview</span>.<span class="title function_">asWebviewUri</span>(</span><br><span class="line">      vscode.<span class="property">Uri</span>.<span class="title function_">file</span>(path.<span class="title function_">join</span>(context.<span class="property">extensionPath</span>, rootPath, <span class="string">&#x27;dist&#x27;</span>, fileName))</span><br><span class="line">    );</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">    &lt;html&gt;</span></span><br><span class="line"><span class="string">      &lt;head&gt;</span></span><br><span class="line"><span class="string">        &lt;meta charset=&quot;utf-8&quot; /&gt;</span></span><br><span class="line"><span class="string">        &lt;meta</span></span><br><span class="line"><span class="string">          name=&quot;viewport&quot;</span></span><br><span class="line"><span class="string">          content=&quot;width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no&quot;</span></span><br><span class="line"><span class="string">        /&gt;</span></span><br><span class="line"><span class="string">        &lt;link rel=&quot;stylesheet&quot; href=&quot;<span class="subst">$&#123;getDiskPath(<span class="string">&#x27;umi.css&#x27;</span>)&#125;</span>&quot; /&gt;</span></span><br><span class="line"><span class="string">        &lt;style&gt;</span></span><br><span class="line"><span class="string">          html, body, #root &#123;</span></span><br><span class="line"><span class="string">            width: 100%;</span></span><br><span class="line"><span class="string">            height: 100%;</span></span><br><span class="line"><span class="string">            margin: 0;</span></span><br><span class="line"><span class="string">            padding: 0;</span></span><br><span class="line"><span class="string">            overflow: hidden;</span></span><br><span class="line"><span class="string">          &#125;</span></span><br><span class="line"><span class="string">        &lt;/style&gt;</span></span><br><span class="line"><span class="string">        &lt;script&gt;</span></span><br><span class="line"><span class="string">          //! umi version: <span class="subst">$&#123;umiVersion&#125;</span></span></span><br><span class="line"><span class="string">        &lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/head&gt;</span></span><br><span class="line"><span class="string">      &lt;body&gt;</span></span><br><span class="line"><span class="string">        &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">        &lt;script src=&quot;<span class="subst">$&#123;getDiskPath(<span class="string">&#x27;umi.js&#x27;</span>)&#125;</span>&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="string">      &lt;/body&gt;</span></span><br><span class="line"><span class="string">    &lt;/html&gt;</span></span><br><span class="line"><span class="string">  `</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>提示：上面的方法我已经封装在 <a href="https://github.com/youngjuning/luozhu/tree/main/packages/vscode-utils">@luozhu&#x2F;vscode-utils</a> 的中。</p></blockquote><p>我们使用 getUmiContent 重新前面的代码：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; getUmiContent &#125; <span class="keyword">from</span> <span class="string">&#x27;@luozhu/vscode-utils&#x27;</span>;</span><br><span class="line">...</span><br><span class="line">panel.<span class="property">webview</span>.<span class="property">html</span> = <span class="title function_">getUmiContent</span>(context, panel, <span class="string">&#x27;3.5.17&#x27;</span>);</span><br></pre></td></tr></table></figure><h4 id="优化打包"><a href="#优化打包" class="headerlink" title="优化打包"></a>优化打包</h4><p>由于我们封装了 <code>getUmiContent</code> 方法，<code>umi build</code> 生成的 index.html 就没有用了，我们可以使用 <code>HTML=none umi build</code> 命令在打包的时候不生成 index.html 文件。</p><p>另外目前 <a href="https://github.com/umijs/umi/issues/7132">umijs 的 mfsu 不支持 writeToDisk 方法</a>，如果后续支持了可以使用 mfsu 优化调试速度。</p><blockquote><p>创建 webview 面板的任务大部分都比较重复，为了沉淀最佳实践，我在 <a href="https://github.com/youngjuning/luozhu/tree/main/packages/vscode-utils">@luozhu&#x2F;vscode-utils</a> 封装了 <a href="http://tny.im/bHLQx">createUmiWebviewPanel</a> 方法。</p></blockquote><h3 id="给-webview-内容加上主题"><a href="#给-webview-内容加上主题" class="headerlink" title="给 webview 内容加上主题"></a>给 webview 内容加上主题</h3><p>webview 可以基于当前的 VS Code 主题和 CSS 改变自身的样式。VS Code 将主题分成 3 种类别，而且在 body 元素上加上了特殊类名以表明当前主题，我们在 umi 中全局加入下面的样式：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">body.<span class="property">vscode</span>-light &#123;</span><br><span class="line">  h1, h2, h3, h4, h5, h6 &#123;</span><br><span class="line">    <span class="attr">color</span>: black;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">color</span>: black;</span><br><span class="line">  background-<span class="attr">color</span>: <span class="title function_">var</span>(--vscode-editor-background);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body.<span class="property">vscode</span>-dark &#123;</span><br><span class="line">  h1, h2, h3, h4, h5, h6 &#123;</span><br><span class="line">    <span class="attr">color</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">color</span>: white;</span><br><span class="line">  background-<span class="attr">color</span>: <span class="title function_">var</span>(--vscode-editor-background);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">body.<span class="property">vscode</span>-high-contrast &#123;</span><br><span class="line">  h1, h2, h3, h4, h5, h6 &#123;</span><br><span class="line">    <span class="attr">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="attr">color</span>: red;</span><br><span class="line">  background-<span class="attr">color</span>: <span class="title function_">var</span>(--vscode-editor-background);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于这部分适配大部分是通用的，所以我也将它封装进了 <code>@luozhu/vscode-utils</code> 的 <code>getUmiContent</code> 中了。</p><h2 id="webview-与-vscode-交互"><a href="#webview-与-vscode-交互" class="headerlink" title="webview 与 vscode 交互"></a>webview 与 vscode 交互</h2><h3 id="webview-中执行脚本"><a href="#webview-中执行脚本" class="headerlink" title="webview 中执行脚本"></a>webview 中执行脚本</h3><p>vscode 中的 webview 本质就是一个 iframe，因此我们是可以再 webview 中执行脚本的，只不过在 vscode 中 webview 默认禁用了 JavaScript，我们在调用 <code>createWebviewPanel</code> API 时传入 <code>enableScripts: true</code> 即可。</p><h3 id="插件传递信息给-webview"><a href="#插件传递信息给-webview" class="headerlink" title="插件传递信息给 webview"></a>插件传递信息给 webview</h3><p>webview 的脚本能做到任何普通网页脚本能做到的事情，但是 webview 运行在自己的上下文中，脚本是不能访问 VS Code API 的。我们需要借助 postMessage 这种事件的方式传递信息。在 vscode 中，我们在 vscode 侧可以使用 <a href="https://vscode-api-cn.js.org/interfaces/Webview.html#postMessage">Webview.postMessage</a> 发布事件并发送任何序列化的 JSON 数据，在 webview 侧则使用 <code>window.addEventListener(&#39;message&#39; event =&gt; &#123; ... &#125;)</code> 来处理这些信息：</p><p><strong>vscode 侧</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注册一个新的命令</span></span><br><span class="line">context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(</span><br><span class="line">  vscode.<span class="property">commands</span>.<span class="title function_">registerCommand</span>(<span class="string">&#x27;juejin-me.author&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!currentPanel) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把信息发送到 webview</span></span><br><span class="line">    <span class="comment">// 你可以发送任何序列化的 JSON 数据</span></span><br><span class="line">    currentPanel.<span class="property">webview</span>.<span class="title function_">postMessage</span>(&#123; <span class="attr">method</span>: <span class="string">&#x27;showAuthor&#x27;</span> &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>webview 侧</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Modal</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span>;</span><br><span class="line">...</span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> message = event.<span class="property">data</span>;</span><br><span class="line">  <span class="keyword">switch</span> (message.<span class="property">method</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;showAuthor&#x27;</span>: &#123;</span><br><span class="line">      <span class="title class_">Modal</span>.<span class="title function_">info</span>(&#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;洛竹&#x27;</span>,</span><br><span class="line">        <span class="attr">content</span>: (</span><br><span class="line">          <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            大家好，我是洛竹🎋一只住在杭城的木系前端🧚🏻‍♀️，如果你喜欢我的文章📚，可以通过</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://juejin.cn/user/325111174662855/posts&quot;</span>&gt;</span>点赞<span class="tag">&lt;/<span class="name">a</span>&gt;</span>帮我聚集灵力⭐️。</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">        ),</span><br><span class="line">        <span class="attr">okText</span>: <span class="language-xml"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://juejin.cn/user/325111174662855/posts&quot;</span>&gt;</span>点赞 o(￣▽￣)ｄ<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>效果</strong>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0dd7dd37db954d84925ac1c0f60cb965~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="webview-传递信息给插件"><a href="#webview-传递信息给插件" class="headerlink" title="webview 传递信息给插件"></a>webview 传递信息给插件</h3><p>webview 反向传递信息给插件的原理也是一样的，只不过由于 webview 的上下文限制，我们只能通过 <code>acquireVsCodeApi</code> 函数获取阉割版的 VS Code API 对象，这个阉割的对象上有一个 <code>postMessage</code> 函数可以供我们发送事件用。注意 <code>acquireVsCodeApi</code> 个会话中只能调用一次，重复调用会报错。而在插件侧则可以通过 <a href="https://vscode-api-cn.js.org/interfaces/Webview.html#onDidReceiveMessage">Webview.onDidReceiveMessage</a> 处理 webview 传递的信息。我们来写一个在 webview 中调用 <code>vscode.window.showInformationMessage</code> 的例子：</p><p><strong>webview 侧</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vscode = <span class="title function_">acquireVsCodeApi</span>();</span><br><span class="line">vscode.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&#x27;showMessage&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">text</span>: <span class="string">`为人民服务`</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>插件侧</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理 webview 中的信息</span></span><br><span class="line">currentPanel.<span class="property">webview</span>.<span class="title function_">onDidReceiveMessage</span>(</span><br><span class="line">  <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (message.<span class="property">method</span> === <span class="string">&#x27;showMessage&#x27;</span>) &#123;</span><br><span class="line">      vscode.<span class="property">window</span>.<span class="title function_">showInformationMessage</span>(message.<span class="property">params</span>.<span class="property">content</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  context.<span class="property">subscriptions</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>效果</strong>：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c32c8b374b534d6fac1cb552287de6ca~tplv-k3u1fbpfcp-zoom-1.image"></p><h3 id="在-webview-中请求接口"><a href="#在-webview-中请求接口" class="headerlink" title="在 webview 中请求接口"></a>在 webview 中请求接口</h3><p>一开始，我以为这是个轻松的工作，直到遇到跨域半天解决不了后我绝望了，在 <a href="https://juejin.cn/post/6844903966799577101#heading-3">VSCode WebView插件（扩展）开发实战</a> 一文中我终于知道了 vscode webview 内部是不允许发送 ajax 请求，所有 ajax 请求都是跨域的，因为 webview 本身是没有 host 的。</p><p>人裂开了，这什么鬼呀，我们核心的需求就是请求掘金的接口获取我们的文章列表呀，那我们还有办法吗？答案是肯定的，其实还是借助上面我们提到的通信机制把请求接口的任务交给 vscode 去处理，完事再让 vscode 把数据通过 <code>postMessage</code> 返回给我们，多说无益，我们来看代码：</p><p><strong>webview 侧</strong>：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// @ts-ignore</span></span><br><span class="line">  <span class="keyword">const</span> vscode = <span class="keyword">typeof</span> acquireVsCodeApi === <span class="string">&#x27;function&#x27;</span> ? <span class="title function_">acquireVsCodeApi</span>() : <span class="literal">null</span>;</span><br><span class="line">  vscode.<span class="title function_">postMessage</span>(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;queryPosts&#x27;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (method === <span class="string">&#x27;queryPosts&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> message = event.<span class="property">data</span>;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, []);</span><br></pre></td></tr></table></figure><p><strong>vscode 侧</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 处理 webview 中的信息，并返回接口请求的数据</span></span><br><span class="line">currentPanel.<span class="property">webview</span>.<span class="title function_">onDidReceiveMessage</span>(</span><br><span class="line">  <span class="keyword">async</span> message =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> <span class="title function_">events</span>(message);</span><br><span class="line">    currentPanel?.<span class="property">webview</span>.<span class="title function_">postMessage</span>(&#123; data &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="literal">undefined</span>,</span><br><span class="line">  context.<span class="property">subscriptions</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="luozhu-x2F-vscode-channel"><a href="#luozhu-x2F-vscode-channel" class="headerlink" title="@luozhu&#x2F;vscode-channel"></a>@luozhu&#x2F;vscode-channel</h3><p>前面我们知道了使用 <a href="https://vscode-api-cn.js.org/interfaces/Webview.html#postMessage">Webview.postMessage</a>、<a href="https://vscode-api-cn.js.org/interfaces/Webview.html#onDidReceiveMessage">Webview.onDidReceiveMessage</a>、<code>acquireVsCodeApi().postMessage</code> 和 <code>window.addEventListener</code> 就可以满足各种通信需求了，那 <code>@luozhu/vscode-channel</code> 又是什么呢？</p><p>受 <a href="https://www.npmjs.com/package/js-channel">js-channel</a> 启发，<code>@luozhu/vscode-channel</code> 主要是封装了 webview 与 vscode 交互流程，核心原理是通过暴露 <code>call</code>、<code>bind</code> 方法抹平 API 的差异，减少重复代码量。其中参考 appworks 和 cs-channel 使用 uuid 保证交互的可靠性。Talk is cheap, show you the code：</p><p><strong>webview 侧</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 channel 对象</span></span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">Channel</span>();</span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 发起一个请求，并等待其返回数据</span></span><br><span class="line">  <span class="keyword">const</span> &#123; payload &#125; = <span class="keyword">await</span> channel.<span class="title function_">call</span>(&#123; <span class="attr">method</span>: <span class="string">&#x27;queryPosts&#x27;</span> &#125;);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(payload);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>webview 中由于 acquireVsCodeApi 只能调用一次，之后又需要在多个地方使用，所以我们在 <code>wev/src/layouts/index.ts</code> 中创建一次并挂载到 <code>window</code> 对象上比较合适。</p></blockquote><p><strong>vscode 侧</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vscode 侧的 channel 需要依赖上下文和 WebviewPanel 实例</span></span><br><span class="line"><span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">Channel</span>(context, currentPanel);</span><br><span class="line"><span class="comment">// 绑定一个回调函数，一般只需要创建一个，然后根据约定做分发即可</span></span><br><span class="line">channel.<span class="title function_">bind</span>(<span class="keyword">async</span> message =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; eventType, method, params &#125; = message;</span><br><span class="line">  <span class="comment">// 实际发起请求获取数据的地方</span></span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> events[eventType][method](params);</span><br><span class="line">  <span class="comment">// 这里将获取的数据直接返回即可，channel 内部会进行消息合并和回传。</span></span><br><span class="line">  <span class="comment">// 如果只是执行一个功能，不写 return 语句即可，内部会进行判断降级成单工通信。</span></span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="vscode-国际化"><a href="#vscode-国际化" class="headerlink" title="vscode 国际化"></a>vscode 国际化</h2><p>我们都知道 vscode 中是可以切换语言环境的，一款优秀的 vscode 扩展至少要支持中英两种语言。而且支持国际化可以让你的插件受众直接突破国界限制。vscode 国际化分为三部分，一部分是配置的国际化，一部分是代码中的国际化，另一部分则是 webview 中 umijs 的国际化。本章我们就来具体看一下如何在 vscode 中实现国际化。</p><h3 id="配置国际化"><a href="#配置国际化" class="headerlink" title="配置国际化"></a>配置国际化</h3><p>我们已经知道 vscode 中的配置都是在 <em>package.json</em> 中，而配置的国际化是约定在 <code>package.nls.json</code> 和 <code>package.nls.zh-cn.json</code> 这种文件中编写。比如我们要在中英文环境下命令配置中英文版本，我们可以在 <code>package.nls.json</code> 中写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;contributes.category.juejin-me&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Juejin Me&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>在 <code>package.nls.zh-cn.json</code> 写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;contributes.category.juejin-me&quot;</span><span class="punctuation">:</span> <span class="string">&quot;掘金一下&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>然后 <code>package.json</code> 中写：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;contributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="attr">&quot;category&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%contributes.category.juejin-me%&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="代码中国际化"><a href="#代码中国际化" class="headerlink" title="代码中国际化"></a>代码中国际化</h3><p>推荐使用洛竹贡献过代码的 <a href="https://github.com/axetroy/vscode-nls-i18n">vscode-nls-i18n</a>，使用方法也很简单，配置的话和上一节一样，在 <code>src/extension.ts</code> 中使用 <code>init</code> 方法初始化，然后使用 <code>localize</code> 方法实现国际化：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; init, localize &#125; <span class="keyword">from</span> <span class="string">&#x27;vscode-nls-i18n&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) &#123;</span><br><span class="line">  <span class="title function_">init</span>(context.<span class="property">extensionPath</span>); <span class="comment">// 初始化国际化配置。只用在扩展激活时初始化一次</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">localize</span>(<span class="string">&#x27;extension.activeLog&#x27;</span>)); <span class="comment">// 之后就可以在各个文件中使用。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="umijs-国际化"><a href="#umijs-国际化" class="headerlink" title="umijs 国际化"></a>umijs 国际化</h3><p>umijs 的国际化需要使用 <code>@umijs/plugin-locale</code> 插件支持，这个插件封装了 <code>react-intl</code>，配置方式如下：</p><p>1、.umirc.ts 中配置 <code>local</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">locale</span>: &#123;&#125;</span><br></pre></td></tr></table></figure><p>2、在 <em>src</em> 目录下创建 <code>locales</code> 并创建 <code>en.ts</code> 或 <code>zh-CN.ts</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/locales/en.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">WELCOME_TO_UMI_WORLD</span>: <span class="string">&quot;welcome to umi&#x27;s world&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/locales/zh-CN.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">WELCOME_TO_UMI_WORLD</span>: <span class="string">&#x27;欢迎光临  umi  的世界&#x27;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>3、使用国际化</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; useIntl &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="attr">default</span>: <span class="title class_">React</span>.<span class="property">FunctionComponent</span> = <span class="function">(<span class="params">props</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> intl = <span class="title function_">useIntl</span>()</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">     &lt;div&gt;</span><br><span class="line">     &#123;intl.<span class="title function_">formatMessage</span>(</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="attr">id</span>: <span class="string">&#x27;WELCOME_TO_UMI_WORLD&#x27;</span>,</span><br><span class="line">        &#125;</span><br><span class="line">      )&#125;&lt;div&gt;</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、切换语言</p><p>切换语言，我们需要使用 <code>setLocale</code> 方法，需要注意的是我们给这个方法第二个参数传入 <code>false</code> 来实现无刷新动态切换。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; setLocale &#125; <span class="keyword">from</span> <span class="string">&#x27;umi&#x27;</span>;</span><br><span class="line"><span class="comment">// 不刷新页面</span></span><br><span class="line"><span class="title function_">setLocale</span>(<span class="string">&#x27;zh-CN&#x27;</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><p>不过，切换语言的时机在什么时候呢？切换时机就是我们语言环境改变的时机。在 vscode webview 环境中，其实当使用 <code>Config display language</code> 方法切换语言环境后，会要求 vscode 重启。也就说我们只需要在 webview 创建时设置一次语言环境即可。由于 vscode 和 webview 传值太困难，我们选择在 <code>getUmiHTMLContent</code> 时传如 <code>vscode.env</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="property">vscodeEnv</span> = $&#123;<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(vscode.<span class="property">env</span>)&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后，我们在 <code>web/src/layouts/index.ts</code> 中设置一下即可：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setLocale</span>(<span class="variable language_">window</span>.<span class="property">vscodeEnv</span>.<span class="property">language</span>, <span class="literal">false</span>);</span><br></pre></td></tr></table></figure><h2 id="“掘金一下”-扩展核心实现"><a href="#“掘金一下”-扩展核心实现" class="headerlink" title="“掘金一下” 扩展核心实现"></a>“掘金一下” 扩展核心实现</h2><p>灵感来源于现实，作为掘金的重度使用者，几乎每篇文章和笔记都同步在这里。当有些知识忘记需要查阅或拷贝代码时，我就有在掘金搜索我的文章的需求。但是掘金的搜索是全站的，就算加上自己的名字搜索也会出现大量无关记录。“掘金一下” 这个名字就像插件功能一样，在你想搜索自己掘金文章的时候就可以打开插件“掘金一下” 进行搜索。</p><p>其实为了只搜索到自己的文章，我想到的还有开发 chrome 插件来实现。但是考虑到市场和便捷性，我最终还是决定开发 vscode 插件来落地这个灵感。本章就是综合前面的经验实现 “掘金一下” 的核心逻辑。</p><h3 id="juejin-me-start-命令"><a href="#juejin-me-start-命令" class="headerlink" title="juejin-me.start 命令"></a><code>juejin-me.start</code> 命令</h3><h4 id="vscode-侧开启-channel-通信"><a href="#vscode-侧开启-channel-通信" class="headerlink" title="vscode 侧开启 channel 通信"></a>vscode 侧开启 channel 通信</h4><p>vscode 侧通过 <code>channel.bind</code> 绑定一个事件处理函数。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> events <span class="keyword">from</span> <span class="string">&#x27;./events&#x27;</span>;</span><br><span class="line">...</span><br><span class="line">context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(</span><br><span class="line">  vscode.<span class="property">commands</span>.<span class="title function_">registerCommand</span>(<span class="string">&#x27;juejin-me.start&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    currentPanel = <span class="title function_">createUmiWebviewPanel</span>(</span><br><span class="line">      context,</span><br><span class="line">      <span class="string">&#x27;juejin-me&#x27;</span>,</span><br><span class="line">      <span class="title function_">localize</span>(<span class="string">&#x27;extension.webview-panel.title&#x27;</span>),</span><br><span class="line">      <span class="string">&#x27;assets/icon-luozhu.png&#x27;</span>,</span><br><span class="line">      <span class="string">&#x27;3.5.17&#x27;</span></span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 处理 webview 中的信息</span></span><br><span class="line">    channel = <span class="keyword">new</span> <span class="title class_">Channel</span>(context, currentPanel);</span><br><span class="line">    channel.<span class="title function_">bind</span>(<span class="keyword">async</span> message =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; eventType, method, params &#125; = message;</span><br><span class="line">      <span class="comment">// 根据事件类型、方法、参数来完成一次 api 调用，内置的 eventType 有 request、command 和 variable。</span></span><br><span class="line">      <span class="keyword">const</span> data = <span class="keyword">await</span> events[eventType][method](params);</span><br><span class="line">      <span class="keyword">return</span> data;</span><br><span class="line">    &#125;, vscode);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><blockquote><p>注意：我们不需要给定监听事件名，内部会根据 eventId 保证可靠性和全局唯一性</p></blockquote><h4 id="注册-events"><a href="#注册-events" class="headerlink" title="注册 events"></a>注册 events</h4><p><strong>events&#x2F;index.ts</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests <span class="keyword">from</span> <span class="string">&#x27;./requests&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">request</span>: requests,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>events&#x2F;requests</strong>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&#x27;../utils/request&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queryPosts = <span class="keyword">async</span> (<span class="attr">params</span>: &#123; <span class="attr">cursor</span>: <span class="built_in">string</span> &#125;): <span class="title class_">Promise</span>&lt;<span class="built_in">any</span>&gt; =&gt; &#123;</span><br><span class="line">  <span class="comment">// 这里我们根据 vscode 配置动态取的用户 id</span></span><br><span class="line">  <span class="keyword">const</span> &#123; userId &#125; = vscode.<span class="property">workspace</span>.<span class="title function_">getConfiguration</span>(<span class="string">&#x27;juejin-me&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> &#123; cursor &#125; = params;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> request.<span class="title function_">post</span>(<span class="string">&#x27;/article/query_list&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">cursor</span>: <span class="string">`<span class="subst">$&#123;cursor&#125;</span>`</span>,</span><br><span class="line">    <span class="attr">sort_type</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="attr">user_id</span>: userId,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  queryPosts,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>utils&#x2F;request</strong>：</p><p>这里简单封装了基于 axios 的请求对象。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* eslint-disable no-param-reassign */</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&#x27;qs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中文文档: http://t.cn/ROfXFuj</span></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">const</span> request = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&#x27;https://api.juejin.cn/content_api/v1/&#x27;</span>,</span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">10000</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加请求拦截器</span></span><br><span class="line">request.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (config.<span class="property">method</span> === <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">      config.<span class="property">paramsSerializer</span> = <span class="function"><span class="params">params</span> =&gt;</span> qs.<span class="title function_">stringify</span>(params, &#123; <span class="attr">arrayFormat</span>: <span class="string">&#x27;repeat&#x27;</span> &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    vscode.<span class="property">window</span>.<span class="title function_">showErrorMessage</span>(error.<span class="property">message</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加响应拦截器</span></span><br><span class="line">request.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; data &#125; = response;</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    vscode.<span class="property">window</span>.<span class="title function_">showErrorMessage</span>(error.<span class="property">message</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request;</span><br></pre></td></tr></table></figure><h3 id="webview-中调用接口"><a href="#webview-中调用接口" class="headerlink" title="webview 中调用接口"></a>webview 中调用接口</h3><p>channel 是在 <code>web/src/layouts/index.tsx</code> 中初始化并挂载到 window 上的，我们在 <code>web/src/pages/index.tsx</code> 中调用 <code>window.channel.call</code> 即可调用指定接口。由于我们需要模糊搜索所有的文章，所以我们需要在初始化页面时一次请求完所有数据。</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Homepage</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">getData</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; payload &#125; = (<span class="keyword">await</span> <span class="variable language_">window</span>.<span class="property">channel</span>.<span class="title function_">call</span>(&#123;</span><br><span class="line">      <span class="attr">eventType</span>: <span class="string">&#x27;request&#x27;</span>,</span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;queryPosts&#x27;</span>,</span><br><span class="line">      <span class="attr">params</span>: &#123; cursor &#125;,</span><br><span class="line">    &#125;)) <span class="keyword">as</span> <span class="built_in">any</span>;</span><br><span class="line">    tempData = tempData.<span class="title function_">concat</span>(payload.<span class="property">data</span>);</span><br><span class="line">    <span class="title function_">setData</span>(tempData);</span><br><span class="line">    <span class="keyword">if</span> (!payload.<span class="property">has_more</span>) &#123;</span><br><span class="line">      <span class="title function_">setInitLoading</span>(<span class="literal">false</span>);</span><br><span class="line">      <span class="title function_">setCategories</span>(<span class="title function_">_union</span>([<span class="string">&#x27;全部&#x27;</span>, ...tempData.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> item.<span class="property">category</span>.<span class="property">category_name</span>)]));</span><br><span class="line">      tempData = [];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cursor += <span class="number">10</span>;</span><br><span class="line">      <span class="title function_">getData</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更多具体实现细节就是一些页面编写逻辑，不是本文的重点，感兴趣的同学可以直接进查看<a href="https://github.com/youngjuning/juejin-me/tree/main/web">源码</a>。</p><h3 id="配置掘金-ID"><a href="#配置掘金-ID" class="headerlink" title="配置掘金 ID"></a>配置掘金 ID</h3><p><strong>声明配置</strong>：</p><p>vscode 的配置我们需要借助 package.json 的 <code>contributes.configuration</code> 属性，我们的掘金 ID 是 string，所以声明如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;contributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;configuration&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%configuration.title%&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;object&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;properties&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;juejin-me.userId&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;string&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;default&quot;</span><span class="punctuation">:</span> <span class="string">&quot;325111174662855&quot;</span><span class="punctuation">,</span></span><br><span class="line">          <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;%configuration.properties.juejin-me.userId%&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p><strong>修改配置的命令</strong>：</p><p>让用户打开设置去修改配置也可以，但是为了用户体验，我们提供了 <code>juejin-me.configUserId</code> 命令，我们来看下命令的实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(</span><br><span class="line">  vscode.<span class="property">commands</span>.<span class="title function_">registerCommand</span>(<span class="string">&#x27;juejin-me.configUserId&#x27;</span>, <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> userId = <span class="keyword">await</span> vscode.<span class="property">window</span>.<span class="title function_">showInputBox</span>(&#123;</span><br><span class="line">      <span class="attr">placeHolder</span>: <span class="title function_">localize</span>(<span class="string">&#x27;extension.juejin-me.configUserId.placeHolder&#x27;</span>),</span><br><span class="line">      <span class="attr">validateInput</span>: <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">localize</span>(<span class="string">&#x27;extension.juejin-me.configUserId.validateInput&#x27;</span>);</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">const</span> config = vscode.<span class="property">workspace</span>.<span class="title function_">getConfiguration</span>(<span class="string">&#x27;juejin-me&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    config.<span class="title function_">update</span>(<span class="string">&#x27;userId&#x27;</span>, userId, <span class="literal">true</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li><a href="https://vscode-api-cn.js.org/modules/window.html#showInputBox">vscode.window.showInputBox</a>：打开一个输入框，提示用户输入掘金用户 ID</li><li><a href="https://vscode-api-cn.js.org/modules/workspace.html#getConfiguration">vscode.workspace.getConfiguration</a>：获取工作空间的配置对象</li><li><a href="https://vscode-api-cn.js.org/interfaces/WorkspaceConfiguration.html#update">WorkspaceConfiguration.update</a>：更新一个配置值。</li><li><a href="https://vscode-api-cn.js.org/interfaces/InputBoxOptions.html#validateInput">InputBoxOptions.validateInput</a>：一个可选的函数，被调用来验证输入信息并提示用户</li></ul><h3 id="插件效果展示"><a href="#插件效果展示" class="headerlink" title="插件效果展示"></a>插件效果展示</h3><p>感兴趣的话你也可以直接在扩展中搜索“掘金一下”自行体验。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ac7d2ab498b2469486e8f237fc3b7997~tplv-k3u1fbpfcp-zoom-1.image"></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/91ae0fdbff7043db9513e539640fcc2e~tplv-k3u1fbpfcp-zoom-1.image"></p><h2 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h2><h3 id="luozhu-x2F-create-vscode-webview"><a href="#luozhu-x2F-create-vscode-webview" class="headerlink" title="@luozhu&#x2F;create-vscode-webview"></a>@luozhu&#x2F;create-vscode-webview</h3><p>本文中有很多最佳实践，为了方便之后创建新的项目时减少重复工作，洛竹抽离出了一个简单的模板。掘友直接使用 <code>yarn create @luozhu/vscode-webview  myvscode</code> 即可创建出一个属于自己的 vscode 扩展。参考本文的一些实践再加一些你的创意即可完成一个出色的基于 webview 的 vscode 扩展。</p><h3 id="Word-Count-Juejin"><a href="#Word-Count-Juejin" class="headerlink" title="Word Count Juejin"></a>Word Count Juejin</h3><p>为了答谢掘金平台和掘友一直以来的支持，我编写了一款专为掘金适配的 Markdown 文件字数统计 VS Code 扩展，字数统计会实时显示在状态栏。比起来 vscode 官方的 Word Count，我们支持中文字数统计，比起来 Word Count CJK，我们支持中英文混排。如果你也喜欢使用 VS Code 的 Markdown 编辑能力，那么一定不要错过洛竹的这款插件，下载请认准：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/08c060326c954849b3eb2d34f2e6b0e5~tplv-k3u1fbpfcp-zoom-1.image"></p><p>如果你还在犹豫要不要下载，那不妨看下三个插件的统计对比，我们拿 <code>i love juejin. 我爱掘金</code> 这个字符串测试一下三款插件的功能：</p><table><thead><tr><th>Word Count</th><th>Word Count CJK</th><th>Word Count Juejin</th></tr></thead><tbody><tr><td>4 个字</td><td>4 个字</td><td>7 个字</td></tr><tr><td>中文算成了一个字</td><td>直接忽略了英文</td><td>中文4 个字加英文三个字，格局正好</td></tr></tbody></table><h3 id="vscode-api-cn"><a href="#vscode-api-cn" class="headerlink" title="vscode api cn"></a>vscode api cn</h3><p>在学习和开发 vscode 插件的过程中，最大的痛点无过于 API 文档翻译的缺失。哪怕是硬着头皮看英文原版 API 文档，阅读体验也很差。为了方便自己、回馈社区，我和 <a href="https://juejin.cn/user/703340610597064">寒草</a> 等小伙伴决定翻译 vscode api 类型声明并使用 Typedoc 承载，另外在完工后我们也会输出 <code>@types/vscode-cn</code> 类型包代替 <code>@types/vscode</code> 进一步方便 vscode 插件开发者。团队成员现状：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/aa80c1603b2e4482883fe39e1b44f62e~tplv-k3u1fbpfcp-zoom-1.image"></p><p>翻译是一件带有侠义精神的事业，欢迎更多的小伙伴加入我们。你可以浏览<a href="https://github.com/vscode-cn/vscode-api-cn">仓库</a>和<a href="https://vscode-api-cn.js.org/">官网</a>了解具体情况。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>这是第一次尝试写这么长的文章，断断续续经历了有半个月，本着对读者负责任的态度，文中的实践都是经过反复测试以及和同事朋友的讨论。当然 vscode 插件开发的概念和 API 比较多，一篇文章也很难讲全，讲透彻。如果大家感兴趣，可以在评论区告诉洛竹，我可以继续更新这方面的教程。</p><blockquote><p>本文首发于「掘金专栏」，同步于公众号「程序人生」。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;⚠️本文为掘金社区首发签约文章，未获授权禁止转载&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;温馨提示：结合本文配套&lt;a href=&quot;https://github.com/youngjuning/juejin-me&quot;&gt;源码&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="VS Code" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/VS-Code/"/>
    
    
    <category term="掘金" scheme="https://youngjuning.js.org/tags/%E6%8E%98%E9%87%91/"/>
    
    <category term="VS Code" scheme="https://youngjuning.js.org/tags/VS-Code/"/>
    
    <category term="Webview" scheme="https://youngjuning.js.org/tags/Webview/"/>
    
    <category term="扩展" scheme="https://youngjuning.js.org/tags/%E6%89%A9%E5%B1%95/"/>
    
  </entry>
  
  <entry>
    <title>如何开发一款 VS Code yarn.lock 预览插件</title>
    <link href="https://youngjuning.js.org/1bbed3d2a249/"/>
    <id>https://youngjuning.js.org/1bbed3d2a249/</id>
    <published>2023-02-26T05:56:50.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://marketplace.visualstudio.com/items?itemName=youngjuning.yarn-lock-preview">Yarn Lock Preview</a> 插件已发布，亲测已比较稳定，源码在 <a href="https://github.com/youngjuning/vscode-yarn-lock-preview">vscode-yarn-lock-preview</a> ，如果对你些许帮助和启发，不妨赏一个 Star。</p></blockquote><blockquote><p><a href="https://vscode-api-cn.js.org/">VS Code API 中文文档</a> 在大家的热情下已经有序开展了翻译工作，也欢迎大家一起参与翻译！</p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <a href="https://juejin.cn/post/7000589186898231333">《从零开发一款基于 webview 的 vscode 扩展》</a> 一文中，洛竹通过实战阐述了如何基于 webview 实现在 vscode 中展示自定义 UI 的功能，另外文章配套产物 <a href="vscode:extension/youngjuning.juejin-me">掘金一下</a> 插件也已经发布，欢迎试用。</p><p>人们👨🏻‍💻总是喜欢炫耀自己的新技能，洛竹也不例外，毕竟新技能需要大量的实战练习。在入门了 VS Code 扩展开发后，遇到开发痛点我就习惯地用 VS Code 插件的思路去解决。不过大多扩展 idea 都已经名花有主，直到我想到可以将 <code>yarn.lock</code> 文件可视化并搜索相关插件无果后，我知道机会来了。</p><h2 id="什么是自定义编辑器❓"><a href="#什么是自定义编辑器❓" class="headerlink" title="什么是自定义编辑器❓"></a>什么是自定义编辑器❓</h2><p>在开始开发之前，我们有必要先了解一下什么编辑器？什么又是自定义编辑器？</p><p>VS Code 中编辑器（Editor）其实就是我们使用频率最高的编码的地方。如下图，VS Code 的用户界面分为 5 个部分，分别是 Activity Bar（活动栏）、Side Bar（侧边栏）、Editor Groups（编辑器组）、Panel（面板） 和 Status Bar（状态栏）。</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/301eab5bbab04c65aec4a927b7d306a9~tplv-k3u1fbpfcp-zoom-1.image"></p><p>自定义编辑器指的是 VS Code 中相对于默认文本编辑器的编辑器类型。根据用途不同，自定义编辑器又分为 <a href="https://vscode-api-cn.js.org/interfaces/vscode.CustomTextEditorProvider.html">自定义文本编辑器</a>、<a href="https://vscode-api-cn.js.org/interfaces/vscode.CustomEditorProvider.html">自定义编辑器</a> 和 <a href="https://vscode-api-cn.js.org/interfaces/vscode.CustomReadonlyEditorProvider.html">自定义只读编辑器</a>。</p><p>自定义文本编辑器常被用来为 JSON、XML、CSV、JSON 或者任意 <a href="https://vscode-api-cn.js.org/interfaces/vscode.TextDocument.html">文本文档</a> 提供自定义的视觉渲染。比如 <a href="https://marketplace.visualstudio.com/items?itemName=SimonSiefke.svg-preview">Svg Preview</a>、<a href="https://marketplace.visualstudio.com/items?itemName=shd101wyy.markdown-preview-enhanced">Markdown Preview Enhanced</a>、<a href="https://marketplace.visualstudio.com/items?itemName=vstirbu.vscode-mermaid-preview">Mermaid Preview</a> 和 <a href="https://marketplace.visualstudio.com/items?itemName=saber2pr.todolist">Todo List</a>。</p><p>自定义编辑器常被用来预览资产(assets)文件，比如 <a href="https://marketplace.visualstudio.com/items?itemName=slevesque.vscode-3dviewer">3D Viewer for VSCode</a>、<a href="https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio">Draw.io Integration</a> 和 <a href="https://marketplace.visualstudio.com/items?itemName=elypia.magick-image-reader">Magick Image Reader</a></p><p>但他们的共同点都是使用了 VS Code 自定义编辑器这个功能。本文的目标其实就是实现一个和上述插件一样的 Preview 类型的扩展。</p><h2 id="为什么开发-Yarn-Lock-Preview？"><a href="#为什么开发-Yarn-Lock-Preview？" class="headerlink" title="为什么开发 Yarn Lock Preview？"></a>为什么开发 Yarn Lock Preview？</h2><p>本来文章是没有这一章的。在插件刚发布的时候，没等文章写完，我就迫不及待地向同事和朋友以及常混迹的几个群推荐了我的插件，然后就被一个群友灵魂拷问了“你这有什么意义？”：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c054b9bca3b44b61b7b9ecc7206240a4~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/643f9dd16c734e8487866f6a3306f0f3~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>开发一款自定义编辑器插件要比单纯的开发插件和 webview 插件都要麻烦，没有人会闲的无聊牺牲业余时间，做一个没有意思的事情。从学习角度来讲，可以掌握了大量 VSCode API，从作用来讲，更直观地查看 <code>yarn.lock</code> 并支持搜索某个包以及依赖该包的包。这在你想确定应用的间接引用了哪些包时很有帮助：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2faa24d3cee4c9088e83c4d0ee06c63~tplv-k3u1fbpfcp-watermark.image" alt="screenshot.gif"></p><p>这其实是一个来自于实际工作中的一个痛点，React Native 中如果同时依赖两个不同版本的原生包，运行项目的时候就会因为重复注册某个 <code>View</code> 造成应用崩溃。入职涂鸦一年来，帮助业务同学排查了 N 次这个问题。由于某些版本的依赖并不是直接在 <code>dependencies</code> 中写的，而是某个包间接依赖的，我的办法是就是在 <code>yarn.lock</code> 中 <code>cmd+f</code> 搜索造成崩溃的包被哪些包依赖了，然后再人肉分析这个有结构的纯文本文件：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4ee531d6d54d4d269984174b5bae97b8~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>虽然我已经是处理这个问题的老司机了，但总归是会耽误不少我和同事的时间。上面的这个问题可能比较极端，还有一个我们经常遇到的开发的反馈是引入了某个原生包之后导致应用崩溃。这其实是因为我们的 React Native 应用是以嵌套的形式集成到已有原生涂鸦 App 内的，所以原生库的支持也是依赖 App 提供的版本。我们在打包的时候也有相应的检验工具，但是用户有可能没有直接依赖这个库，而是这个库间接或者间接地间接库引用了这个库。这个时候我们就得在上万行纯文本 yarn.lock 中开启人肉分析。</p><p>比如，App 目前支持的 react-native-svg 版本是 5.5.1。用户使用的 <code>react-native-svg-charts</code> 最新版依赖的是 react-native-svg <code>^6.2.1</code> 或者 <code>^7.0.3</code>。用户按照指引直接安装使用运行崩溃，然后找到我们质疑。那如果用了这款插件，我们就可以直接在项目中搜索：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/95d979f9b7c549e68f8321dac0aaa481~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><p>最后一个就是你一定可能会遇到的场景，比如开发声明的依赖是 <code>tuya-panel-kit@^4.6.0</code>，然后遇到问题，直接截图告诉你我没有升级过版本呀，为啥报错了或者为啥表现不一样了的问题。然后我们就得让用户看一下实际依赖的版本是什么。有的开发会去 <code>node_modules</code> 下面找，这其实不靠谱，层级那么复杂，想快速定位是很难的；有的开发会在 <code>yarn.lock</code> 中人肉搜索；或者有的开发直接让我们帮忙排查。那么有了这款插件，我们就可以直接让开发自己搜，然后截图提 issues 给我们：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7bc01f9c7df543db90d6f6b31444eeca~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><blockquote><p>温馨提示：<code>yarn list --pattern tuya-panel-kit</code> 命令也可以列出简要的依赖信息。</p></blockquote><p>叨逼叨这么多，相信读者已经和我达成共识了，如果没有，欢迎评论区 Battle。废话不多说，下面就让我们来开始展示真正的技术吧。</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/7c9f81662bba4518b8d075d132d870e1~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h2><h3 id="使用官方脚手架"><a href="#使用官方脚手架" class="headerlink" title="使用官方脚手架"></a>使用官方脚手架</h3><ol><li>安装 <a href="http://yeoman.io/">Yeoman</a> 和 <a href="https://www.npmjs.com/package/generator-code">VS Code Extension Generator</a>：<code>npm install -g yo generator-code</code></li><li>生成项目：<code>yo code</code></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ yo code</span><br><span class="line"><span class="comment">#     _-----_     ╭──────────────────────────╮</span></span><br><span class="line"><span class="comment">#    |       |    │   Welcome to the Visual  │</span></span><br><span class="line"><span class="comment">#    |--(o)--|    │   Studio Code Extension  │</span></span><br><span class="line"><span class="comment">#   `---------´   │        generator!        │</span></span><br><span class="line"><span class="comment">#    ( _´U`_ )    ╰──────────────────────────╯</span></span><br><span class="line"><span class="comment">#    /___A___\   /</span></span><br><span class="line"><span class="comment">#     |  ~  |</span></span><br><span class="line"><span class="comment">#   __&#x27;.___.&#x27;__</span></span><br><span class="line"><span class="comment"># ´   `  |° ´ Y `</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ? What type of extension do you want to create? New Extension (TypeScript)</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the name of your extension? Yarn Lock Preview</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the identifier of your extension? yarn-lock-preview</span></span><br><span class="line"><span class="comment"># ? What&#x27;s the description of your extension? Previews yarn.lock file</span></span><br><span class="line"><span class="comment"># ? Initialize a git repository? Yes</span></span><br><span class="line"><span class="comment"># ? Bundle the source code with webpack? No</span></span><br><span class="line"><span class="comment"># ? Which package manager to use? yarn</span></span><br><span class="line"></span><br><span class="line">$ code ./vscode-yarn-lock-preview</span><br></pre></td></tr></table></figure><h3 id="规范化项目"><a href="#规范化项目" class="headerlink" title="规范化项目"></a>规范化项目</h3><ol><li>代码规范配置 - <code>npx @luozhu/create-coding-style</code></li><li>按照新的代码规范格式化代码 - <code>yarn lint --fix</code></li><li>Git Commit 规范配置 - <code>npx @luozhu/create-commitlint</code></li></ol><h3 id="扩展信息配置"><a href="#扩展信息配置" class="headerlink" title="扩展信息配置"></a>扩展信息配置</h3><ol><li>扩展信息配置（package.json）<ol><li>配置 <a href="https://code.visualstudio.com/api/working-with-extensions/publishing-extension#create-a-publisher">publisher</a></li><li>添加上 <code>license</code> 字段。</li><li>添加 <code>repository</code> 字段。</li><li>配置 <code>icon</code>：128 x 128 像素图标的路径。</li></ol></li><li>修改 readme：因为初始的没法通过 <code>vsce package</code> 校验</li><li>使用 <code>npx vsce package</code> 尝试打包，确保没有错误和警告</li></ol><h3 id="使用-esbuild-打包"><a href="#使用-esbuild-打包" class="headerlink" title="使用 esbuild 打包"></a>使用 esbuild 打包</h3><p>在 <a href="https://juejin.cn/post/7000589186898231333/#heading-8">从零开发一款基于 webview 的 vscode 扩展</a> 中我们讲述了使用 esbuild 打包可以减小打包产物的体积以及加快调试速度。参考上一篇文章即可完成配置，这里就不赘述了。</p><h3 id="Don’t-repeat-yourself"><a href="#Don’t-repeat-yourself" class="headerlink" title="Don’t repeat yourself"></a>Don’t repeat yourself</h3><p>本着重复的工作都可以用脚本代替的原则，我 vscode 插件开发的最佳实践沉淀为了一个脚手架，执行 <code>yarn create @luozhu/vscode-extension</code> 即可快速开始开发 vscode 扩展。</p><h2 id="自定义编辑器原理"><a href="#自定义编辑器原理" class="headerlink" title="自定义编辑器原理"></a>自定义编辑器原理</h2><h3 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h3><p>前面我们已经知道了在 VS Code 中自定义编辑器有三种：自定义文本编辑器、自定义编辑器和自定义只读编辑器。三种类型的编辑器都会替换 VS Code 中的标准文本编辑器展示的位置。不同的是自定义文本编辑器由于是基于 VS Code 的标准文本文档模型，不需要开发者提供，比如 <a href="https://marketplace.visualstudio.com/items?itemName=SimonSiefke.svg-preview">Svg Preview</a> 插件。而自定义编辑器用于二进制文件的预览，因此需要开发者自己提供文档模型并自行实现诸如保存和备份这些功能比如 <a href="https://marketplace.visualstudio.com/items?itemName=hediet.vscode-drawio">Draw.io Integration</a> 插件。自定义只读编辑器则用于预览二进制文件，比如 <a href="https://marketplace.visualstudio.com/items?itemName=elypia.magick-image-reader">Magick Image Reader</a>。</p><p>了解了三种自定义编辑器的区别，我们来看下我们的插件属于哪种自定义编辑器。其实答案显而易见，<code>yarn.lock</code> 文件属于 VS Code 标准文档模型，我们选用最简单的自定义文本编辑器即可。</p><p>编写一个自定义编辑器会涉及视图、插件、文档模型、底层资源文件以及它们之间的交互，其大概原理如下图：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/116948b627f4406ba51faa0353f147a7~tplv-k3u1fbpfcp-zoom-1.image"></p><p>由于预览 <code>yarn.lock</code> 不需要我们提供文档模型，因此我们只需要基于 <a href="https://vscode-api-cn.js.org/interfaces/vscode.CustomTextEditorProvider.html">CustomTextEditorProvider</a> 编写一个 CustomEditorProvider 给插件注册使用，然后编写我们的视图（用户界面），最后实现视图和插件的交互即可。</p><p>其中我们需要关注的点有如何开发视图、视图和插件如何通信、如何实现 CustomEditorProvider 以及如何注册 CustomEditorProvider。</p><h3 id="如何开发视图"><a href="#如何开发视图" class="headerlink" title="如何开发视图"></a>如何开发视图</h3><p>视图是通过 webview 实现的，所以你可以通过标准的 HTML、CSS 和 JavaScript 构建用户体验，也可以使用你熟悉的前端框架实现。</p><h3 id="视图如何与插件通信"><a href="#视图如何与插件通信" class="headerlink" title="视图如何与插件通信"></a>视图如何与插件通信</h3><p>由于 VS Code 的限制，Webview 是不能直接访问 VS Code API 以及发送网络请求的，但是它可以通过 postMessage 与插件进行双向通信。但是手写双向通信比较麻烦，尤其是进行网络请求时，webview 需要先发送发起网络请求的消息，插件侧注册的监听事件发起网络请求，插件等待网络请求返回后再发送消息将数据发给 webview，最后 webview 通过注册的监听事件获取信息。简要的流程如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/20f34a967c234945afbaf9aaf2901163~tplv-k3u1fbpfcp-watermark.image" alt="webview 通信原理.png"></p><p>抛开具体实现来看这个交互就已经很反人类了，而且具体使用时还会面对 webview 和插件用到的 API 也不一样导致的转换成本和心智负担。为了解决这个痛点，我封装了 <a href="https://www.npmjs.com/package/@luozhu/vscode-channel">@luozhu&#x2F;vscode-channel</a> 来实现好用的双向通信。你可以简单地在 webview 侧通过 <code>call</code> 方法调用方法并等待处理结果，插件侧通过 <code>bind</code> 方法绑定事件处理。</p><h3 id="如何实现-CustomEditorProvider"><a href="#如何实现-CustomEditorProvider" class="headerlink" title="如何实现 CustomEditorProvider"></a>如何实现 CustomEditorProvider</h3><p>参考官方 Demo <a href="https://github.com/microsoft/vscode-extension-samples/blob/main/custom-editor-sample/src/catScratchEditor.ts#L16">catScratchEditor</a> 我们可以看到 <code>CatScratchEditorProvider</code> 是通过实现了 <code>vscode.CustomTextEditorProvider</code> 接口创建的自定义编辑器 Provider。而 <code>vscode.CustomTextEditorProvider</code> 这个接口只有一个方法  <code>resolveCustomTexEditor</code>。所以原理上我们只需要实现 <code>resolveCustomTexEditor</code> 这个方法即可。</p><h3 id="如何注册-CustomEditorProvider"><a href="#如何注册-CustomEditorProvider" class="headerlink" title="如何注册 CustomEditorProvider"></a>如何注册 CustomEditorProvider</h3><p>实现了自定义编辑器 Provider 之后，我们需要将其注册到插件中，VS Code 提供了 <code>vscode.window.registerCustomEditorProvider</code> 方法用来完成这项任务。</p><h2 id="自定义编辑器实现"><a href="#自定义编辑器实现" class="headerlink" title="自定义编辑器实现"></a>自定义编辑器实现</h2><p>纸上得来终觉浅，绝知此事要躬行。如果对前面的概念感到困惑，那接下来的实战可能会让你豁然开朗。</p><h3 id="声明自定义编辑器"><a href="#声明自定义编辑器" class="headerlink" title="声明自定义编辑器"></a>声明自定义编辑器</h3><p>自定义编辑器是通过 <code>package.json</code> 的贡献内容（<code>contributes</code>）的 <code>customEditors</code> 属性声明的，<code>customEditors</code> 提供自定义编辑器。它是一个数组，也就是说我们可以在一个扩展中提供多个自定义编辑器。我们声明的自定义编辑器如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;contributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;activationEvents&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;onCustomEditor:yarn-lock-preview.yarnLock&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;customEditors&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;viewType&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn-lock-preview.yarnLock&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;displayName&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Preview yarn.lock&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;selector&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">        <span class="punctuation">&#123;</span></span><br><span class="line">          <span class="attr">&quot;filenamePattern&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn.lock&quot;</span></span><br><span class="line">        <span class="punctuation">&#125;</span></span><br><span class="line">      <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;priority&quot;</span><span class="punctuation">:</span> <span class="string">&quot;option&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><ul><li><code>activationEvents</code> - 注册激活事件<ul><li><code>onCustomEditor:*</code> - 激活自定义编辑器的事件</li></ul></li><li><code>customEditors</code> - 提供的自定义编辑器。<ul><li><code>viewType</code> - 自定义编辑器的标识符。它在所有自定义编辑器中都必须是唯一的，因此建议将扩展 ID 作为 <code>viewType</code> 的一部分包括在内。在使用 <code>vscode.registerCustomEditorProvider</code> 和在 <code>onCustomEditor:$&#123;id&#125;</code> 激活事件中注册自定义编辑器时，使用 <code>viewType</code>。</li><li><code>displayName</code> - 自定义编辑器的用户可读名称。当选择要使用的编辑器时，向用户显示此名称。</li><li><code>selector</code> - 为其启用了自定义编辑器的一组 glob。</li><li><code>priority</code> - （可选）确定自定义编辑器的使用时机。这个字段控制合适使用特定的自定义编辑器。<ul><li><code>option</code> - 在用户打开资源时不会自动使用此编辑器，但用户可使用 <code>Reopen With</code> 命令切换到此编辑器。</li><li><code>default</code> - 在用户打开资源时自动使用此编辑器，前提是没有为该资源注册其他默认的自定义编辑器。</li></ul></li></ul></li></ul><p>我们现在可以打开一个 <code>yarn.lock</code> 文件，并在命令面板中输入 <code>Reopen with</code> 选择我前面注册的 <code>Preview yarn.lock</code>：</p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/376a6b66b7c24de589fb48a54d29efb6~tplv-k3u1fbpfcp-watermark.image" alt="Kapture 2021-09-14 at 11.28.37.gif"></p><p>这时我们可以看到一个空白的编辑器以及顶部的不会停止的加载进度条。</p><p>打开命令面板输出命令的方式对用户来说不是很友好，我们可以在编辑器菜单中添加一个切换按钮实现快速切换编辑器模式。首先我们在 <code>package.json</code> 中配置命令和菜单：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;contributes&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;commands&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn-lock-preview.switchEditorMode&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;title&quot;</span><span class="punctuation">:</span> <span class="string">&quot;switch editor mode&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;icon&quot;</span><span class="punctuation">:</span> <span class="string">&quot;$(rocket)&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;menus&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;editor/title&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">      <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;command&quot;</span><span class="punctuation">:</span> <span class="string">&quot;yarn-lock-preview.switchEditorMode&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;navigation&quot;</span></span><br><span class="line">      <span class="punctuation">&#125;</span></span><br><span class="line">    <span class="punctuation">]</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><ul><li><code>commands</code> - 对命令面板提供命令。</li><li><code>menus</code> - 向编辑器提供菜单项。</li></ul><p>然后在 <code>src/extension</code> 中的 active 函数中注册命令及实现命令回调：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; commands, <span class="title class_">ExtensionContext</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">activate</span>(<span class="params">context: ExtensionContext</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Congratulations, your extension &quot;yarn-lock-preview&quot; is now active!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(</span><br><span class="line">    commands.<span class="title function_">registerCommand</span>(<span class="string">&#x27;yarn-lock-preview.switchEditorMode&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      commands.<span class="title function_">executeCommand</span>(<span class="string">&#x27;workbench.action.reopenWithEditor&#x27;</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我只找到了 <code>workbench.action.reopenWithEditor</code> 这个可以触发的命令，我本意是实现类似 git 的<strong>打开文件</strong>和<strong>打开更改</strong>的功能。由于学艺不精，<a href="https://github.dev/microsoft/vscode/blob/f66a3e06bcb9f000e5dc0ad0040ff9b32fc75c78/extensions/git/src/commands.ts#L655-L656">git.openFile</a> 的实现我还需要再研究一下，如果有大佬看到这来可以指点一下。目前效果如下：</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/cb03abea51634bd3a0a8c1a27b155ec0~tplv-k3u1fbpfcp-watermark.image" alt="Kapture 2021-09-14 at 12.46.00.gif"></p><h3 id="注册自定义编辑器-Provider"><a href="#注册自定义编辑器-Provider" class="headerlink" title="注册自定义编辑器 Provider"></a>注册自定义编辑器 Provider</h3><p>现在我们已经注册了自定义文档类型 <code>yarn-lock-preview.yarnLock</code> 和 <code>onCustomEditor:yarn-lock-preview.yarnLock</code> 激活事件。现在我们需要借助 <a href="https://vscode-api-cn.js.org/modules/window.html#registerCustomEditorProvider">window.registerCustomEditorProvider</a> 方法注册对应的自定义编辑器 Provider。</p><p>如果这时候尝试调用 <code>registerCustomEditorProvider</code> 方法，你会发现我们并没有一个自定义编辑器 provider 可以使用，下一节我们会实现自定义编辑器 Provider。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Congratulations, your extension &quot;yarn-lock-preview&quot; is now active!&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(</span><br><span class="line">    vscode.<span class="property">window</span>.<span class="title function_">registerCustomEditorProvider</span>(</span><br><span class="line">      <span class="string">&#x27;yarn-lock-preview.yarnLock&#x27;</span>,</span><br><span class="line">      provider <span class="comment">// 自定义编辑器 provider 实例</span></span><br><span class="line">    );</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现自定义编辑器-Provider"><a href="#实现自定义编辑器-Provider" class="headerlink" title="实现自定义编辑器 Provider"></a>实现自定义编辑器 Provider</h3><p>由于我们要预览的文件是 VS Code 的标准文档模型，所以我们需要基于 <code>CustomTextEditorProvider</code> 这个接口封装一个类来实现它。为此我们新建一个 <code>YarnLockEditorProvider.ts</code> 文件，该文件的最小实现如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YarnLockEditorProvider</span> <span class="keyword">implements</span> vscode.<span class="property">CustomTextEditorProvider</span> &#123;</span><br><span class="line">  <span class="comment">// 将 context 注入 this 对象</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"><span class="keyword">private</span> <span class="keyword">readonly</span> context: vscode.ExtensionContext</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当自定义编辑器打开时调用。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">resolveCustomTextEditor</span>(</span><br><span class="line">    <span class="attr">_document</span>: vscode.<span class="property">TextDocument</span>,</span><br><span class="line">    <span class="attr">webviewPanel</span>: vscode.<span class="property">WebviewPanel</span>,</span><br><span class="line">    <span class="attr">_token</span>: vscode.<span class="property">CancellationToken</span></span><br><span class="line">  ): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 给 webview 设置初始内容</span></span><br><span class="line">    webviewPanel.<span class="property">webview</span>.<span class="property">options</span> = &#123;</span><br><span class="line">      <span class="attr">enableScripts</span>: <span class="literal">true</span>, <span class="comment">// 允许在 webview 中运行脚本</span></span><br><span class="line">    &#125;;</span><br><span class="line">    webviewPanel.<span class="property">webview</span>.<span class="property">html</span> = <span class="variable language_">this</span>.<span class="title function_">getHtmlForWebview</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getHtmlForWebview</span>(): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">        &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;</span></span><br><span class="line"><span class="string">            &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;title&gt;Cat Coding&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">            &lt;img src=&quot;https://media.giphy.com/media/JIX9t2j0ZTN9S/giphy.gif&quot; width=&quot;300&quot; /&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">YarnLockEditorProvider</span>;</span><br></pre></td></tr></table></figure><ul><li><code>class YarnLockEditorProvider implements vscode.CustomTextEditorProvider</code> - 声明一个类实现自定义文本编辑器 provider。</li><li><a href="https://vscode-api-cn.js.org/interfaces/CustomTextEditorProvider.html#resolveCustomTextEditor">resolveCustomTextEditor</a>：根据给定的文本资源解析自定义编辑器。当用户第一次打开一个 <code>CustomTextEditorProvider</code> 的资源时，或者当他们使用这个 <code>CustomTextEditorProvider</code> 重新打开一个现有的编辑器时，该方法将被调用。</li><li><code>webviewPanel.webview.options</code> - 配置 webview 选项，这里我们配置了允许使用脚本。</li><li><code>webviewPanel.webview.html = this.getHtmlForWebview()</code> - 为 HTML 设置初始内容。</li></ul><p>为了简化初始化操作，我们为 <code>YarnLockEditorProvider</code> 类封装一个 <code>register</code> 静态方法：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="title function_">register</span>(<span class="attr">context</span>: vscode.<span class="property">ExtensionContext</span>): vscode.<span class="property">Disposable</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> provider = <span class="keyword">new</span> <span class="title class_">YarnLockEditorProvider</span>(context);</span><br><span class="line">  <span class="keyword">const</span> providerRegistration = vscode.<span class="property">window</span>.<span class="title function_">registerCustomEditorProvider</span>(</span><br><span class="line">    <span class="title class_">YarnLockEditorProvider</span>.<span class="property">viewType</span>,</span><br><span class="line">    provider,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">webviewOptions</span>: &#123;</span><br><span class="line">        <span class="attr">retainContextWhenHidden</span>: <span class="literal">true</span>, <span class="comment">// 隐藏时保留上下文</span></span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> providerRegistration;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">readonly</span> viewType = <span class="string">&#x27;yarn-lock-preview.yarnLock&#x27;</span>;</span><br></pre></td></tr></table></figure><p>现在我们就可以注册我们的自定义编辑器 provider 了，在 <code>src/extension.ts</code> 的 <code>activate</code> 方法中调用 <code>YarnLockEditorProvider.register(context)</code> 得到注册的自定义编辑器，然后 <code>push</code> 到代理监听数组中即可：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> vscode <span class="keyword">from</span> <span class="string">&#x27;vscode&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">YarnLockEditorProvider</span> <span class="keyword">from</span> <span class="string">&#x27;./YarnLockEditorProvider&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">activate</span>(<span class="params">context: vscode.ExtensionContext</span>) &#123;</span><br><span class="line">  context.<span class="property">subscriptions</span>.<span class="title function_">push</span>(<span class="title class_">YarnLockEditorProvider</span>.<span class="title function_">register</span>(context));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样一个简单但完整的自定义编辑器就完成了：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e6addd1cb739448db52db1767154fe65~tplv-k3u1fbpfcp-watermark.image" alt="Kapture 2021-09-14 at 17.00.55.gif"></p><h2 id="yarn-lock-可视化预览实现"><a href="#yarn-lock-可视化预览实现" class="headerlink" title="yarn.lock 可视化预览实现"></a>yarn.lock 可视化预览实现</h2><p>前面我们已经顺利带大家实现了在自定义编辑器中看猫的功能。当然了，我们的最终目标可不是看黑猫敲代码。这一章我们将挑战最后的 Boss：实现一个可以搜索的 yarn.lock 依赖 Json 树。</p><h3 id="解析-yarn-lock-文件"><a href="#解析-yarn-lock-文件" class="headerlink" title="解析 yarn.lock 文件"></a>解析 yarn.lock 文件</h3><p>解决了技术问题，现在我们来看下业务问题。我们的痛点是 yarn.lock 文件是纯文本的，阅读起来比较困难，需要一个更好的展示形式。那我们可以第一步肯定是将文本文件转成更易处理的资源，作为前端，当然首选 JSON。借助 Yarn 官方的 <a href="https://www.npmjs.com/package/@yarnpkg/lockfile">@yarnpkg&#x2F;lockfile</a> 工具我们就可以实现这个功能。我们来编写 demo 试一下。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> lockfile <span class="keyword">from</span> <span class="string">&#x27;@yarnpkg/lockfile&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YarnLockEditorProvider</span> <span class="keyword">implements</span> vscode.<span class="property">CustomTextEditorProvider</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当自定义编辑器打开时调用。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">resolveCustomTextEditor</span>(</span><br><span class="line">    <span class="attr">document</span>: vscode.<span class="property">TextDocument</span>,</span><br><span class="line">    <span class="attr">webviewPanel</span>: vscode.<span class="property">WebviewPanel</span>,</span><br><span class="line">    <span class="attr">_token</span>: vscode.<span class="property">CancellationToken</span></span><br><span class="line">  ): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 获取纯文本并解析成 json 数据</span></span><br><span class="line">    <span class="keyword">const</span> json = lockfile.<span class="title function_">parse</span>(<span class="variable language_">document</span>.<span class="title function_">getText</span>()).<span class="property">object</span>;</span><br><span class="line">    <span class="comment">// 将 JSON 字符串传递给 HTML 拼装方法展示</span></span><br><span class="line">    webviewPanel.<span class="property">webview</span>.<span class="property">html</span> = <span class="variable language_">this</span>.<span class="title function_">getHtmlForWebview</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(json));</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">getHtmlForWebview</span>(<span class="attr">json</span>: <span class="built_in">string</span>): <span class="built_in">string</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">`</span></span><br><span class="line"><span class="string">        &lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="string">        &lt;html lang=&quot;en&quot;&gt;</span></span><br><span class="line"><span class="string">        &lt;head&gt;</span></span><br><span class="line"><span class="string">            &lt;meta charset=&quot;UTF-8&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span></span><br><span class="line"><span class="string">            &lt;title&gt;Cat Coding&lt;/title&gt;</span></span><br><span class="line"><span class="string">        &lt;/head&gt;</span></span><br><span class="line"><span class="string">        &lt;body&gt;</span></span><br><span class="line"><span class="string">          &lt;h1&gt;JSON 数据&lt;/h1&gt;</span></span><br><span class="line"><span class="string">          &lt;p&gt;<span class="subst">$&#123;json&#125;</span>&lt;/p&gt;</span></span><br><span class="line"><span class="string">        &lt;/body&gt;</span></span><br><span class="line"><span class="string">        &lt;/html&gt;</span></span><br><span class="line"><span class="string">    `</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果如下：</p><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/979363c7be8c42d59e2aa564cf687c26~tplv-k3u1fbpfcp-watermark.image" alt="Kapture 2021-09-14 at 18.59.12.gif"></p><h3 id="webview-集成-umijs"><a href="#webview-集成-umijs" class="headerlink" title="webview 集成 umijs"></a>webview 集成 umijs</h3><p>参考 <a href="https://juejin.cn/post/7000589186898231333/#heading-9">《# 从零开发一款基于 webview 的 vscode 扩展》</a> 和 <a href="https://github.com/youngjuning/vscode-juejin-me">vscode-juejin-me</a> 初始化 umijs 项目并做一些修剪适配工作。然后使用 <code>@luozhu/vscode-utils</code> 的 <code>getUmiHTMLContent</code> 方法获取 HTML 内容：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">webviewPanel.<span class="property">webview</span>.<span class="property">html</span> = <span class="title function_">getUmiHTMLContent</span>(<span class="variable language_">this</span>.<span class="property">context</span>, webviewPanel, &#123;</span><br><span class="line">  <span class="attr">title</span>: <span class="string">&#x27;Yarn Lock Preview&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="webview-内容更新"><a href="#webview-内容更新" class="headerlink" title="webview 内容更新"></a>webview 内容更新</h3><p>集成 umijs 后我们通过 <code>webviewPanel.webview.html</code> 设置的初始内容是空的。如果我们想要将文本传递从插件传递到 webview，我们需要进行一次通信。VS Code 中由于种种限制造成了编写通信的代码很繁琐。基本依赖 webview 的插件都会将通信机制给封装了。我这里的封装思路是借鉴了 <a href="https://www.npmjs.com/package/js-channel">js-channel</a> 实现了一个使用起来心智负担最小的 <a href="https://github.com/youngjuning/luozhu/tree/main/packages/vscode-channel#readme">@luozhu&#x2F;vscode-channel</a>。借助这个工具我们可以很方便地实现更新 webview 的操作：</p><p><strong>插件侧发送更新消息：</strong></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Channel</span> <span class="keyword">from</span> <span class="string">&#x27;@luozhu/vscode-channel&#x27;</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">YarnLockEditorProvider</span> <span class="keyword">implements</span> vscode.<span class="property">CustomTextEditorProvider</span> &#123;</span><br><span class="line">  <span class="keyword">async</span> <span class="title function_">resolveCustomTextEditor</span>(</span><br><span class="line">    <span class="attr">document</span>: vscode.<span class="property">TextDocument</span>,</span><br><span class="line">    <span class="attr">webviewPanel</span>: vscode.<span class="property">WebviewPanel</span>,</span><br><span class="line">    <span class="attr">_token</span>: vscode.<span class="property">CancellationToken</span></span><br><span class="line">  ): <span class="title class_">Promise</span>&lt;<span class="built_in">void</span>&gt; &#123;</span><br><span class="line">    <span class="comment">// 给 webview 设置初始内容</span></span><br><span class="line">    webviewPanel.<span class="property">webview</span>.<span class="property">options</span> = &#123;</span><br><span class="line">      <span class="attr">enableScripts</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    webviewPanel.<span class="property">webview</span>.<span class="property">html</span> = <span class="title function_">getUmiHTMLContent</span>(<span class="variable language_">this</span>.<span class="property">context</span>, webviewPanel, &#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;Yarn Lock Preview&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个 channel 对象</span></span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">new</span> <span class="title class_">Channel</span>(<span class="variable language_">this</span>.<span class="property">context</span>, webviewPanel);</span><br><span class="line">    <span class="keyword">const</span> json = lockfile.<span class="title function_">parse</span>(<span class="variable language_">document</span>.<span class="title function_">getText</span>()).<span class="property">object</span>;</span><br><span class="line">    <span class="comment">// 触发 updateWebview 事件，并将文本作为参数传入</span></span><br><span class="line">    channel.<span class="title function_">call</span>(<span class="string">&#x27;updateWebview&#x27;</span>, json);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>webview 侧监听消息：</strong></p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">Channel</span> <span class="keyword">from</span> <span class="string">&#x27;@luozhu/vscode-channel&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">HomePage</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> [data, setData] = <span class="title class_">React</span>.<span class="title function_">useState</span>(&#123;&#125;);</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    channel.<span class="title function_">bind</span>(<span class="string">&#x27;updateWebview&#x27;</span>, <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">setData</span>(message.<span class="property">params</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,[])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文本内容同步"><a href="#文本内容同步" class="headerlink" title="文本内容同步"></a>文本内容同步</h3><p>前面一章我们实现了初始内容的同步，但是内容不是一成不变的，<code>yarn.lock</code> 很可能会变化，这时候我们也需要相应地更新我们内容，这个需求我们需要借助 <code>vscode.workspace.onDidChangeTextDocument</code> 事件监听来实现：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 仍然是在 resolveCustomTextEditor 方法中实现</span></span><br><span class="line"><span class="comment">// 由于需要对 json 数据处理和重复调用更新方法，封装了此方法</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">updateWebview</span>(<span class="params">textDocument: vscode.TextDocument</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> json = lockfile.<span class="title function_">parse</span>(textDocument.<span class="title function_">getText</span>());</span><br><span class="line">  <span class="keyword">switch</span> (json.<span class="property">type</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;merge&#x27;</span>:</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 处理 merge type</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;conflict&#x27;</span>:</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> 处理 conflict type</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">      json = json.<span class="property">object</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  channel.<span class="title function_">call</span>(<span class="string">&#x27;updateWebview&#x27;</span>, json);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册钩子事件处理程序，这样我们就可以使 webview 与文本文档同步。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 文本文件作为我们的模型，所以我们必须将文件中的变化同步到我们的编辑器。</span></span><br><span class="line"><span class="comment">// 请记住，一个文本文件也可以在多个自定义编辑器之间共享（例如，当你分割一个自定义编辑器时就会发生这种情况）。</span></span><br><span class="line"><span class="keyword">const</span> changeDocumentSubscription = vscode.<span class="property">workspace</span>.<span class="title function_">onDidChangeTextDocument</span>(<span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (e.<span class="property">document</span>.<span class="property">uri</span>.<span class="title function_">toString</span>() === <span class="variable language_">document</span>.<span class="property">uri</span>.<span class="title function_">toString</span>()) &#123;</span><br><span class="line">    <span class="title function_">updateWebview</span>(e.<span class="property">document</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 确保当我们的编辑器关闭时，移除了监听器。</span></span><br><span class="line">webviewPanel.<span class="title function_">onDidDispose</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  changeDocumentSubscription.<span class="title function_">dispose</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="实现可搜索的-JSON-View"><a href="#实现可搜索的-JSON-View" class="headerlink" title="实现可搜索的 JSON View"></a>实现可搜索的 JSON View</h3><p>搜索实现不复杂，大家感兴趣可以直接阅读源码，UI 用的是 umi 自带的 antd。JSON View 我选用了 <code>react-json-view</code>，这个有几点比较有意思可以讲一下。</p><ol><li>数据量过大时渲染性能差需要判断是否折叠</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactJson</span> <span class="keyword">from</span> <span class="string">&#x27;react-json-view&#x27;</span>;</span><br><span class="line">...</span><br><span class="line">&lt;<span class="title class_">ReactJson</span></span><br><span class="line">  shouldCollapse=&#123;<span class="function"><span class="params">filed</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 除了根目录都折叠</span></span><br><span class="line">    <span class="keyword">if</span> (filed.<span class="property">name</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>样式符合当前主题</li></ol><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactJson</span> <span class="keyword">from</span> <span class="string">&#x27;react-json-view&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getCssVar</span> = (<span class="params">cssVar: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> htmlStyle = <span class="variable language_">document</span>.<span class="property">documentElement</span>.<span class="property">style</span>;</span><br><span class="line">  <span class="keyword">return</span> htmlStyle.<span class="title function_">getPropertyValue</span>(cssVar).<span class="title function_">trim</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">&lt;<span class="title class_">ReactJson</span></span><br><span class="line">  style=&#123;&#123;</span><br><span class="line">    <span class="attr">backgroundColor</span>: <span class="title function_">getCssVar</span>(<span class="string">&#x27;--vscode-editor-background&#x27;</span>),</span><br><span class="line">    <span class="attr">fontSize</span>: <span class="title function_">getCssVar</span>(<span class="string">&#x27;--vscode-editor-font-size&#x27;</span>),</span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li>亮暗主题适配</li></ol><p>完美的适配肯定是要随着主题的更改切换 ReactJson 的主题，我们需要在插件侧发起通知：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始主题</span></span><br><span class="line">channel.<span class="title function_">call</span>(<span class="string">&#x27;updateColorTheme&#x27;</span>, vscode.<span class="property">window</span>.<span class="property">activeColorTheme</span>);</span><br><span class="line"><span class="comment">// 监听主题改变事件</span></span><br><span class="line">vscode.<span class="property">window</span>.<span class="title function_">onDidChangeActiveColorTheme</span>(<span class="function"><span class="params">colorTheme</span> =&gt;</span> &#123;</span><br><span class="line">  channel.<span class="title function_">call</span>(<span class="string">&#x27;updateColorTheme&#x27;</span>, colorTheme);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>然后在 webview 侧监听 <code>updateColorTheme</code> 事件：</p><figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [theme, setTheme] = <span class="title class_">React</span>.<span class="property">useState</span>&lt;<span class="title class_">ThemeKeys</span>&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">useEffect</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">channel.<span class="title function_">bind</span>(<span class="string">&#x27;updateColorTheme&#x27;</span>, <span class="function"><span class="params">message</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; kind &#125; = message.<span class="property">params</span>;</span><br><span class="line">  <span class="title function_">setTheme</span>(kind === <span class="number">1</span> ? <span class="string">&#x27;rjv-default&#x27;</span> : <span class="string">&#x27;monokai&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">&#125;, []);</span><br><span class="line">...</span><br><span class="line">&lt;<span class="title class_">ReactJson</span></span><br><span class="line">  theme=&#123;theme&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p>文章开头已经演示了用户界面，这里放一张黑色主题效果吧：</p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8449b0b270aa423da2ede94f4ad10805~tplv-k3u1fbpfcp-watermark.image" alt="image.png"></p><h2 id="涉及-API-附录"><a href="#涉及-API-附录" class="headerlink" title="涉及 API 附录"></a>涉及 API 附录</h2><p>VS Code 插件开发涉及知识点比较多，每种插件类型都有自己的套路和 API。基于关注分离原则，这里列出了和自定义编辑器相关的一些 API，方便大家以及未来的我查阅。</p><h3 id="vscode-commands-registerCommand"><a href="#vscode-commands-registerCommand" class="headerlink" title="vscode.commands.registerCommand"></a>vscode.commands.registerCommand</h3><p>注册一个可以被键映射、菜单项、动作或直接调用的命令。用一个现有的命令标识符注册两次一个命令将导致错误。</p><h3 id="vscode-TextDocument"><a href="#vscode-TextDocument" class="headerlink" title="vscode.TextDocument"></a>vscode.TextDocument</h3><h3 id="vscode-window-registerCustomEditorProvider"><a href="#vscode-window-registerCustomEditorProvider" class="headerlink" title="vscode.window.registerCustomEditorProvider"></a>vscode.window.registerCustomEditorProvider</h3><p>为 <code>customEditors</code> 扩展功能点贡献的 <code>viewType</code> 注册一个自定义编辑器的 Provider。</p><p>当打开一个自定义编辑器被时，会触发一个 <code>onCustomEditor:viewType</code> 活动事件。你的扩展必须为 <code>viewType</code> 注册一个 <code>CustomTextEditorProvider</code>、<code>CustomReadonlyEditor</code>  或 <code>CustomEditorProvider</code> 作为激活的一部分。</p><h3 id="vscode-CustomTextEditorProvider"><a href="#vscode-CustomTextEditorProvider" class="headerlink" title="vscode.CustomTextEditorProvider"></a>vscode.CustomTextEditorProvider</h3><p>基于文本的自定义编辑器 provider。</p><p>基于文本的自定义编辑器使用 TextDocument 作为其数据模型。因为它允许编辑器处理许多常见的操作，如撤销和备份。provider 负责在 webview 和 TextDocument 之间同步文本变化。</p><h4 id="CustomTextEditorProvider-resolveCustomTextEditor"><a href="#CustomTextEditorProvider-resolveCustomTextEditor" class="headerlink" title="CustomTextEditorProvider.resolveCustomTextEditor"></a>CustomTextEditorProvider.resolveCustomTextEditor</h4><p>根据给定文本资源解析一个自定义编辑器。该方法将在用户第一次为 <code>CustomTextEditorProvider</code> 打开一个资源时，或者他们使用这个 <code>CustomTextEditorProvider</code> 重新打开已经存在的编辑器时被调用。</p><h3 id="vscode-CustomReadonlyEditorProvider"><a href="#vscode-CustomReadonlyEditorProvider" class="headerlink" title="vscode.CustomReadonlyEditorProvider"></a>vscode.CustomReadonlyEditorProvider</h3><p>使用自定义文档模型的只读自定义编辑器 Provider。</p><p>自定义只读编辑器使用 <code>CustomDocument</code>，而不是 <code>TextDocument</code>。</p><p>当处理二进制文件或者更复杂的场景时，你应该使用这个类型的自定义编辑器。简单的基于文本的文档请使用 <code>CustomTextEditorProvider</code>。</p><h3 id="vscode-CustomEditorProvider"><a href="#vscode-CustomEditorProvider" class="headerlink" title="vscode.CustomEditorProvider"></a>vscode.CustomEditorProvider</h3><p>使用自定义文档模型的可编辑自定义编辑器的 provider。</p><p>自定义编辑器使用 <code>CustomDocument</code>，而不是 <code>TextDocument</code>。这使得扩展程序可以完全控制编辑、保存和备份等操作。</p><p>当处理二进制文件或者更复杂的场景时，你应该使用这个类型的自定义编辑器。简单的基于文本的文档请使用 <code>CustomTextEditorProvider</code>。</p><h3 id="vscode-WebviewPanel"><a href="#vscode-WebviewPanel" class="headerlink" title="vscode.WebviewPanel"></a>vscode.WebviewPanel</h3><p>一个包含 webview 的面板。</p><blockquote><p>本文首发于 <a href="https://juejin.cn/user/325111174662855/posts">掘金专栏</a>，同步于 <a href="https://youngjuning.js.org/">洛竹的博客</a> 和公众号 <a href="https://cdn.jsdelivr.net/gh/youngjuning/images/20210418112129.jpeg">洛竹早茶馆</a>。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=youngjuning.yarn-lock-preview&quot;&gt;Yarn Lock Preview&lt;/a&gt; 插件已发布，亲测已比</summary>
      
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="VS Code" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/VS-Code/"/>
    
    
    <category term="VS Code" scheme="https://youngjuning.js.org/tags/VS-Code/"/>
    
    <category term="yarn.lock" scheme="https://youngjuning.js.org/tags/yarn-lock/"/>
    
  </entry>
  
  <entry>
    <title>hexo-theme-butterfly 魔改与美化</title>
    <link href="https://youngjuning.js.org/3f81e8c6ddd1/"/>
    <id>https://youngjuning.js.org/3f81e8c6ddd1/</id>
    <published>2023-02-22T06:18:09.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<!-- DRAFT hexo-theme-butterfly 魔改与美化 --><blockquote><p>当前魔改基于 hexo 6.3.0 和 hexo-theme-butterfly 4.7.0</p></blockquote><h1 id="patch-package-配置"><a href="#patch-package-配置" class="headerlink" title="patch-package 配置"></a>patch-package 配置</h1><p>patch-package 可以将你的魔改记录保存到 <code>patches</code> 文件夹下，方便下次更新主题后应用魔改。按照下面的代码修改 package.json 即可：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line"><span class="addition">+    &quot;postinstall&quot;: &quot;npx patch-package&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你想直接应用我的魔改，可以直接复制本文的代码到 <code>patches/hexo-theme-butterfly+4.7.0.patch</code></p><h1 id="两个小人"><a href="#两个小人" class="headerlink" title="两个小人"></a>两个小人</h1><div class="tabs" id="两个小人"><ul class="nav-tabs"><li class="tab active"><button type="button" data-href="#两个小人-1">改动点</button></li><li class="tab"><button type="button" data-href="#两个小人-2">效果预览</button></li></ul><div class="tab-contents"><div class="tab-item-content active" id="两个小人-1"><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug b/node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug</span></span><br><span class="line"><span class="comment">index 9e63627..905342a 100644</span></span><br><span class="line"><span class="comment">--- a/node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug</span></span><br><span class="line"><span class="comment">+++ b/node_modules/hexo-theme-butterfly/layout/includes/widget/card_announcement.pug</span></span><br><span class="line"><span class="meta">@@ -4,3 +4,4 @@</span> if theme.aside.card_announcement.enable</span><br><span class="line">       i.fas.fa-bullhorn.fa-shake</span><br><span class="line">       span= _p(&#x27;aside.card_announcement&#x27;)</span><br><span class="line">     .announcement_content!= theme.aside.card_announcement.content</span><br><span class="line"><span class="addition">+      .twopeople!= &#x27;&lt;div class=&quot;twopeople&quot;&gt;&lt;div class=&quot;container&quot; style=&quot;height:200px;&quot;&gt;&lt;canvas class=&quot;illo&quot; width=&quot;800&quot; height=&quot;800&quot; style=&quot;max-width: 200px; max-height: 200px; touch-action: none; width: 640px; height: 640px;&quot;&gt;&lt;/canvas&gt;&lt;/div&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/zdog.dist.js&quot;&gt;&lt;/script&gt;&lt;script id=&quot;rendered-js&quot; src=&quot;https://cdn.jsdelivr.net/gh/Justlovesmile/CDN/js/twopeople.js&quot;&gt;&lt;/script&gt;&lt;style&gt;.twopeople&#123;margin: 0;align-items: center;justify-content: center;text-align: center;&#125;canvas &#123;display: block;margin: 0 auto;cursor: move;&#125;&lt;/style&gt;&lt;/div&gt;&#x27;</span></span><br></pre></td></tr></table></figure><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div><div class="tab-item-content" id="两个小人-2"><p><img src="https://picbed.qunarzz.com/f3d661e2088ea4fd706709ee1024adce.png" alt="效果预览"></p><button type="button" class="tab-to-top" aria-label="scroll to top"><i class="fas fa-arrow-up"></i></button></div></div></div><blockquote><p>鸣谢 <a href="https://guole.fun/posts/butterfly-custom/">https://guole.fun/posts/butterfly-custom/</a></p></blockquote><h1 id="站点-Logo-圆角"><a href="#站点-Logo-圆角" class="headerlink" title="站点 Logo 圆角"></a>站点 Logo 圆角</h1><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">diff --git a/node_modules/hexo-theme-butterfly/source/css/_layout/head.styl b/node_modules/hexo-theme-butterfly/source/css/_layout/head.styl</span></span><br><span class="line"><span class="comment">index ade0db3..956a69e 100644</span></span><br><span class="line"><span class="comment">--- a/node_modules/hexo-theme-butterfly/source/css/_layout/head.styl</span></span><br><span class="line"><span class="comment">+++ b/node_modules/hexo-theme-butterfly/source/css/_layout/head.styl</span></span><br><span class="line"><span class="meta">@@ -289,6 +289,7 @@</span></span><br><span class="line">       margin-right: 6px</span><br><span class="line">       height: 36px</span><br><span class="line">       vertical-align: middle</span><br><span class="line"><span class="addition">+      border-radius: 50%</span></span><br><span class="line"></span><br><span class="line">   #toggle-menu</span><br><span class="line">     display: none</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文将介绍本站对 hexo-theme-butterfly 进行的一些美化和魔改。</summary>
    
    
    
    <category term="站点运营" scheme="https://youngjuning.js.org/categories/%E7%AB%99%E7%82%B9%E8%BF%90%E8%90%A5/"/>
    
    
    <category term="hexo" scheme="https://youngjuning.js.org/tags/hexo/"/>
    
    <category term="hexo-theme-butterfly" scheme="https://youngjuning.js.org/tags/hexo-theme-butterfly/"/>
    
    <category term="魔改" scheme="https://youngjuning.js.org/tags/%E9%AD%94%E6%94%B9/"/>
    
    <category term="美化" scheme="https://youngjuning.js.org/tags/%E7%BE%8E%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>信息系统项目管理师备考笔记</title>
    <link href="https://youngjuning.js.org/e896d9d3a8e1/"/>
    <id>https://youngjuning.js.org/e896d9d3a8e1/</id>
    <published>2023-02-19T15:40:41.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<!-- DRAFT 信息系统项目管理师备考笔记 --><h1 id="信息化和信息系统"><a href="#信息化和信息系统" class="headerlink" title="信息化和信息系统"></a>信息化和信息系统</h1><h2 id="信息系统与信息化"><a href="#信息系统与信息化" class="headerlink" title="信息系统与信息化"></a>信息系统与信息化</h2><h3 id="信息的基本概念"><a href="#信息的基本概念" class="headerlink" title="信息的基本概念"></a>信息的基本概念</h3><details class="toggle" ><summary class="toggle-button" style="">1、信息的定义</summary><div class="toggle-content"><p>信息就是用来消除不确定性的东西。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">2、信息的特征</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">信息的特征</summary><div class="toggle-content"><ol><li><strong>客观性</strong>：信息是客观事物在人脑中的反映，而反映的对象则有主观和客观的区别，因此，信息可分为主观信息（例如，决策、指令和计划等）和客观信息（例如，国际形式、经济发展和一年四季等）。主观信息必然要转化成客观信息，例如，决策和计划等主观信息要转化成实际行动。</li><li><strong>普遍性</strong>：物质具有普遍性，信息属于物质，物质的普遍性决定了信息的普遍存在。</li><li><strong>无限性</strong>：客观世界是无限的，信息是客观事物&#x2F;世界在人脑中的反映，反映客观世界的信息自然也是无限的。无限性可分为两个层次，一是无限的事物产生无限的信息，即信息的总量是无限的；二是每个具体事物或有限个食物的集合所能产生的信息也可以是无限的。</li><li><strong>动态性</strong>：信息是随着时间的变化而变化的。</li><li><strong>相对性</strong>：不同的认识主体从同一事物中获取的信息及信息量可能是不同的。这会取决于认识主体的生长环境、教育、工作环境、工作性质等外界因素。</li><li><strong>依附性</strong>：信息的依附性可以从两个方面来解释，一方面，信息是客观世界的反映，任何信息必然由客观事物所产生，不存在无源的信息；另一方面，任何信息都要依附于一定的载体而存在，需要有物质的承担者，信息不能完全脱离物质而独立存在。</li><li><strong>变换性</strong>：信息通过处理可以实现变化或转换，使其形式和内容发生变化，以适应特定的需要。比较明显的是数据可视化分过程，实现信息从文字到表格，最终到图表的展示，通过变化，信息的可读性越来越强。</li><li><strong>传递性</strong>：信息在时间上的传递就是存储，在空间上的传递就是转移或扩散。</li><li><strong>层次性</strong>：客观世界是分层次的，反映它的信息也是分层次的。</li><li><strong>系统性</strong>：信息可以表示为一种合集，不同类别的信息可以形成不同的整体。因此，可以形成与现实世界相对应的信息系统。例如：经济领域中的商业系统和金融系统，自然界中的水利系统和生态系统等。</li><li><strong>转化性</strong>：信息的产生不能没有物质，信息的传递不能没有能量，但有效地使用信息，可以使信息转化为物质或能量。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">信息质量属性⭐</summary><div class="toggle-content"><ol><li><strong>精确性</strong>：对事物状态描述的精准程度。</li><li><strong>完整性</strong>：对事物状态描述的全面程度，完整信息应包括所有重要事实。</li><li><strong>可靠性</strong>：指信息的来源、采集方法、传输过程是可以信任的，符合预期。</li><li><strong>及时性</strong>，指获得信息的时刻与事件发生时刻的间隔长短。</li><li><strong>经济性</strong>，指信息获取、传输带来的成本在可以接受的范围之内。</li><li><strong>可验证性</strong>：指信息的主要质量属性可以被证实或者证伪的程度。</li><li><strong>安全性</strong>：指在信息的生命周期中，信息可以被非授权访问的可能性，可能性越低，安全性越高。</li></ol></div></details></div></details><details class="toggle" ><summary class="toggle-button" style="">3、信息的功能</summary><div class="toggle-content"><p>无重要考点</p></div></details><details class="toggle" ><summary class="toggle-button" style="">4、信息的传输模型⭐</summary><div class="toggle-content"><ul><li><strong>信源</strong>：产生信息的实体，信息产生后，由这个实体向外传播。</li><li><strong>信宿</strong>：信息的归宿或者接受者。</li><li><strong>信道</strong>：传送信息的通道。</li><li><strong>编码器</strong>：在信息论中是泛指所有变换信号的设备，实际上就是终端机的发送部分。它包括从信源到信道的所有设备，如量化器、压缩编码器、调制器等，使信源输出的信号转换成适用于信道传送的信号。</li><li><strong>译码器</strong>：译码器是编码器的逆变换设备，把信道上传来的信号（原始信号与噪声的叠加）转换成信宿能接受的信号。</li><li><strong>噪声</strong>：噪声可以理解为干扰。</li></ul><p><img src="https://picbed.qunarzz.com/771ed4f1600bfe927bc97c5f5e6e2512.png" alt="信息传输模型"></p></div></details><h3 id="信息系统的基本概念"><a href="#信息系统的基本概念" class="headerlink" title="信息系统的基本概念"></a>信息系统的基本概念</h3><details class="toggle" ><summary class="toggle-button" style="">1、系统的特性</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">总体特性</summary><div class="toggle-content"><ol><li><strong>目的性</strong>：定义一个系统、组成一个系统或者抽象出一个系统，都有明确的目标或者目的，目标性决定了系统的功能。</li><li><strong>整体性</strong>：系统是一个整体，元素是为了达到一定的目的，按照一定的原则，有序地排列起来组成系统，从而产生出系统的特定功能。</li><li><strong>层次性</strong>：系统化是由多个元素组成的，系统和元素是相对的概念。元素是相对于它所处的系统而言的。系统是从它包含元素的角度来看的，如果研究问题的角度变一变，系统就成为更高一级的元素，也成为子系统。</li><li><strong>稳定性</strong>：是规则的约束，系统的内部结构和秩序应该是可以预见的；系统的状态以及演化路径有限并能被预测；系统的功能发生作用导致的后果也是可以预估的。稳定性强的系统使得系统在受到外部作用的同时，内部结构和秩序仍然能够保持。</li><li><strong>突变性</strong>：突变性是指系统通过失稳，从一种状态进入另一种状态的一种剧烈变化过程，它是系统质变的一种基本形式。</li><li><strong>自组织性</strong>：开放系统在系统内外因素的作用下，自发组织起来，使系统从无序到有序，从低级有序到高级有序。</li><li><strong>相似性</strong>：系统具有同构和同态的性质，体现在系统结构、存在方式和演化过程具有共同性。系统具有相似性，根本原因在于世界的物质统一性。</li><li><strong>相关性</strong>：元素是可分的和相互联系的，组成系统的元素必须有明确的边界，可以与别的元素区分开来。另外，元素之间是相互联系的，不是哲学上所说的那种普遍联系，而是实实在在的、具体的联系。</li><li><strong>适应环境性</strong>：系统总处在一定的环境中，与环境发生相互作用。系统和环境之间总是在发生着一定的物质和能量交换。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">突出特征</summary><div class="toggle-content"><ol><li>开放性：系统的开放性是指系统的可访问性。</li><li>脆弱性🔥：这个特性与系统的稳定性相应，即系统可能存在着丧失结构、功能、秩序的特性，这个特性往往是隐藏不易被外界感知的。</li><li>健壮性：系统具有能够抵御出现非预期状态的特性称为健壮性，也称鲁棒性（robustness）。要求具有高可用性的信息系统，会采用冗余技术、容错技术、身份识别技术、可靠性技术等来抵御系统出现的非预期的状态，保持系统的稳定性。</li></ol></div></details></div></details><details class="toggle" ><summary class="toggle-button" style="">2、信息系统</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">定义</summary><div class="toggle-content"><p>简单地说，信息系统就是输入数据，通过加工处理，产生信息的系统。</p></div></details><p>信息系统可以是手工的，也可以是计算机化的。</p><details class="toggle" ><summary class="toggle-button" style="">信息系统集成</summary><div class="toggle-content"><p>采用现代管理理论（例如，软件工程、项目管理等）作为计划、设计、控制的方法论，将硬件、软件、数据库、网络等部件按照规划的结构和秩序，有机地整合一个有清晰边界的信息系统中，以达到既定系统的目标，这个过程称为信息系统集成。</p></div></details></div></details><h3 id="信息化的基本概念"><a href="#信息化的基本概念" class="headerlink" title="信息化的基本概念"></a>信息化的基本概念</h3><details class="toggle" ><summary class="toggle-button" style="">1、信息化从“小”到“大”的五个层次⭐️</summary><div class="toggle-content"><ol><li><strong>产品信息化</strong></li><li><strong>企业信息化</strong></li><li><strong>产业信息化</strong></li><li><strong>国民经济信息化</strong></li><li><strong>社会生活信息化</strong></li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">2、信息化的内涵🔥</summary><div class="toggle-content"><ol><li><strong>信息化的主体</strong>：<strong>全体社会成员</strong>，包括政府、企业、事业、团体和个人。</li><li><strong>时域</strong>：一个长期的过程</li><li><strong>空域</strong>：政治、经济、文化、军事和社会的一切领域</li><li><strong>手段</strong>：基于现代信息技术的先进社会生产工具</li><li><strong>途径</strong>：是创建信息时代的社会生产力，推动社会生产关系及社会上层建筑的改革</li><li><strong>目标</strong>：使国家的综合实力、社会的文明素质和人民的生活质量全面提升</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">3、国家级信息系统</summary><div class="toggle-content"><ul><li>两网：是指政务内网和政务外网</li><li>一站：是指政府门户网站</li><li>四库：即建立人口、法人单位、空间地理和自然资源、宏观经济等四大基础数据库。</li><li>十二金</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">4、信息化的六要素🔥</summary><div class="toggle-content"><ol><li><strong>信息资源</strong>：信息资源的开发和利用是国家信息化的核心人任务，是国家信息化建设取得实效的关键，也是我国信息化的薄弱环节。（信息技术、设备、设施、信息生产者等）</li><li><strong>信息网络</strong>：信息网络是信息资源开发和利用的基础设施，包括电信网，广播电视和计算机网络。</li><li><strong>信息技术应用</strong>：是指把信息技术广泛应用于经济和社会各个领域，他直接反映了效率、效果、效益。信息技术应用是信息化体系六要素中的龙头，是国家信息化建设的主阵地，集中体现了国家信息化建设的需求与效益。</li><li><strong>信息技术与产业</strong>：是信息化的物质基础</li><li><strong>信息化人才</strong>：人才是信息化的成功之本</li><li><strong>信息化政策法规和标准规范</strong>：信息化政策和法规、标准、规范用于规范和协调信息化体系要素之间的关系，是国家信息化快速，有序，健康和持续发展的保障。</li></ol><p><img src="https://picbed.qunarzz.com/81eb01b74890743fd48386c1e2d6c876.png" alt="信息化的六要素"></p></div></details><h3 id="信息系统生命周期"><a href="#信息系统生命周期" class="headerlink" title="信息系统生命周期"></a>信息系统生命周期</h3><details class="toggle" ><summary class="toggle-button" style="">4 大方面</summary><div class="toggle-content"><ol><li>立项（系统规划）</li><li>开发（系统分析、系统设计、系统实施）</li><li>运维（运行维护）</li><li>消亡</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">5 小方面</summary><div class="toggle-content"><ol><li>系统规划</li><li>系统分析</li><li>系统设计</li><li>系统实施</li><li>运行维护</li></ol></div></details><h2 id="信息系统开发方法"><a href="#信息系统开发方法" class="headerlink" title="信息系统开发方法"></a>信息系统开发方法</h2><h3 id="结构化方法"><a href="#结构化方法" class="headerlink" title="结构化方法"></a>结构化方法</h3><p><img src="https://picbed.qunarzz.com/b5330d132e19a9931bfb32134f234fdf.png" alt="孵小鸡"></p><details class="toggle" ><summary class="toggle-button" style="">1、定义</summary><div class="toggle-content"><p>也称为生命周期法，是一种传统的信息系统开发方法。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">2、组成</summary><div class="toggle-content"><ul><li>结构分析（Structured Analysis，SA）</li><li>结构化设计（Structured Design，SD）</li><li>结构化程序设计（Structured Programming，SP）</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3、精髓🔥</summary><div class="toggle-content"><p>自顶向下、逐步求精和模块化设计</p></div></details><details class="toggle" ><summary class="toggle-button" style="">4、主要特点</summary><div class="toggle-content"><ol><li>开发目标清晰化</li><li>开发工作阶段化</li><li>开发文档规范化</li><li>设计方法结构化</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">5、适用场景</summary><div class="toggle-content"><p>特别适合于数据处理领域的问题</p></div></details><details class="toggle" ><summary class="toggle-button" style="">6、不适用场景</summary><div class="toggle-content"><p>不适用于规模较大、比较复杂的系统开发</p></div></details><details class="toggle" ><summary class="toggle-button" style="">7、缺点</summary><div class="toggle-content"><ol><li>开发周期较长</li><li>难以适应需求变化</li><li>很少考虑数据结构</li></ol></div></details><h3 id="面向对象方法"><a href="#面向对象方法" class="headerlink" title="面向对象方法"></a>面向对象方法</h3><p><img src="https://picbed.qunarzz.com/e66b60d74e7b7591ca378194405f3841.png" alt="面向对象-面向小鸡"></p><details class="toggle" ><summary class="toggle-button" style="">1、定义</summary><div class="toggle-content"><p>面向对象（OO）方法认为，客观世界是由各种对象组成的（一切皆对象）。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">2、与结构化方法的联系</summary><div class="toggle-content"><p>与结构化方法类似，OO 方法也划分阶段，但其中的系统分析、系统设计和系统实现三个阶段之间已经没有“缝隙”，也就是说，这三个阶段的界限变得不明确。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">3、OO 优点🔥</summary><div class="toggle-content"><ol><li>符合人们的思维习惯</li><li>有利于系统开发过程中用户与开发人员的沟通与交流，缩短开发周期</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">4、OO 缺点🔥</summary><div class="toggle-content"><p>必须依靠一定的 OO 技术支持，在大型项目开发上具有一定的局限性，不能涉足系统分析以前的开发环节。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">5、应用场景</summary><div class="toggle-content"><p>当前，一些大型信息系统的开发，通常是将结构化方法和 OO 方法结合起来，首先，使用结构化方法进行自顶向下的整体划分；然后，自底向上地采用 OO 方法进行开发。</p></div></details><h3 id="原型化方法"><a href="#原型化方法" class="headerlink" title="原型化方法"></a>原型化方法</h3><p><img src="https://picbed.qunarzz.com/1c7a2ea4d0e571de005d72cf898a1352.png" alt="原型化方法"></p><details class="toggle" ><summary class="toggle-button" style="">1、定义</summary><div class="toggle-content"><p>原型化方法也称为快速原型法，或者简称原型法。它是一种根据用户初步需求，利用系统开发工具，快速建立一个系统模型给用户，在此基础上与用户交流，最终实现用户需求的信息系统快速的开发方法。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">2、分类</summary><div class="toggle-content"><p>按是否实现功能划分：水平原型、垂直原型<br>按最终结果划分：抛弃式原型、演化式原型</p></div></details><details class="toggle" ><summary class="toggle-button" style="">3、开发过程🔥</summary><div class="toggle-content"><ol><li>确定用户的基本需求</li><li>设计系统原型</li><li>试用和评价原型</li><li>修改和完善原型</li><li>整理原型、提供文档</li></ol><p><img src="https://picbed.qunarzz.com/8a4081f6975446bb19470ea120cd78b1.png" alt="原型法的开发过程"></p></div></details><details class="toggle" ><summary class="toggle-button" style="">4、特点🔥</summary><div class="toggle-content"><ol><li>原型法可以使系统开发的周期缩短，成本和风险降低，速度加快，获得较高的综合开发效益。</li><li>原型法是以用户为中心来开发系统，用户参与的程度大大提高，开发的系统符合用户的需求，因而增加客户的满意度，提高了系统开发的成功率。</li><li>由于用户参与了系统开发的全过程，对系统的功能和结构容易理解和接受，有利于系统的移交，有利于系统的运行和维护。</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">5、不足🔥</summary><div class="toggle-content"><ol><li>开发环境要求高</li><li>管理水平要求高</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">6、适用场景🔥</summary><div class="toggle-content"><ol><li>原型法适用于那些需求不明确的系统开发</li><li>事实上，对于分析层面难度大，技术层面难度不大的系统，适用于原型法开发</li><li>而对于技术层面的困难远大于其分析层面的系统，则不宜用原型法。</li></ol></div></details><h3 id="面向服务"><a href="#面向服务" class="headerlink" title="面向服务"></a>面向服务</h3><p><img src="https://picbed.qunarzz.com/145bb50bf142fc865414fc290012e273.png" alt="面向服务"></p><details class="toggle" ><summary class="toggle-button" style="">1、产生的背景</summary><div class="toggle-content"><p>OO 的应用构建在类和对象上，随后发展起来的建模技术将相关对象按业务功能进行分组，就形成了构件（Component）的概念。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">2、交互的方式</summary><div class="toggle-content"><p>对于跨构件的功能调用，则采用<strong>接口</strong>的形式暴露出来。进一步将接口的定义与实现进项解耦，则催生了服务和面向服务（Service-Oriented，SO）的开发方法。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">3、优点</summary><div class="toggle-content"><ol><li>提高系统可复用性</li><li>信息资源共享</li><li>系统之间的互操作性</li></ol></div></details><h2 id="常规信息系统集成技术"><a href="#常规信息系统集成技术" class="headerlink" title="常规信息系统集成技术"></a>常规信息系统集成技术</h2><h3 id="网络标准与网络协议"><a href="#网络标准与网络协议" class="headerlink" title="网络标准与网络协议"></a>网络标准与网络协议</h3><details class="toggle" ><summary class="toggle-button" style="">1、OSI 协议</summary><div class="toggle-content"><ol><li>物理层</li></ol><ul><li>定义：盖层包括物理联网媒介，比如电缆连线连接器。</li><li>协议：RS232、V.35、<strong>RJ-45</strong>（水晶头）、FDDI<br>2.数据链路层</li><li>定义：它控制网络层与物理层之间的通信。</li><li>协议：<strong>IEEE 802.3&#x2F;.2</strong>、AHDLC、PPP、TM</li></ul><ol start="3"><li>网络层</li></ol><ul><li>定义：其主要功能是将网络地址（例如：IP 地址）翻译成对应的物理地址（例如：MAC 地址），并决定如何将数据从发送方路由到接收方。</li><li>协议：<strong>IP</strong>、<strong>ICMP</strong>、<strong>IGMP</strong>、IPX、<strong>ARP</strong>、<strong>RARP</strong></li></ul><ol start="4"><li>传输层</li></ol><ul><li>定义：主要负责确保数据可靠、顺序、无错地从 A 传输到 B 点。</li><li>协议：<strong>TCP</strong>、<strong>UDP</strong>、SPX</li></ul><ol start="5"><li>会话层</li></ol><ul><li>定义：负责在网络中的两个节点之间建立和维持通信，以及提供交互会话的管理功能。如三种数据流方向控制，即一路交互、两路交互和两路同时会话模式。</li><li>协议：RPC、SQL、NFS</li></ul><ol start="6"><li>表示层</li></ol><ul><li>定义：如同应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用的网络的类型不同而不同。表示层管理数据的解密加密、数据转换、格式化和文本压缩。</li><li>协议：<strong>JPEG</strong>、<strong>ASCLL</strong>、<strong>GIF</strong>、<strong>DES</strong>、<strong>MPEG</strong></li></ul><ol start="7"><li>应用层</li></ol><ul><li>定义：负责对软件提供接口以使程序能使用网路服务，如事务处理程序、文件传送协议和网络管理等。</li><li>协议：<strong>FTP</strong>、<strong>TFTP</strong>、<strong>HTTP</strong>、<strong>SMTP</strong>、<strong>DHCP</strong>、<strong>Telnet</strong>、<strong>DNS</strong>、<strong>SNMP</strong></li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">2、网络协议与标准</summary><div class="toggle-content"><ul><li>IEEE 802.3（局域网协议）</li><li>IEEE 802.11（无线局域网协议）</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">3、TCP/IP</summary><div class="toggle-content"><p>TCP&#x2F;IP 协议是 Internet 的核心</p><ol><li>应用层协议</li></ol><ul><li><strong>FTP</strong>（File Transport Protocol，文件传输协议）：运行在<em>TCP</em>之上，FTP 在客户端与服务器之间需要建立两条 TCP 连接，一条用于传输控制信息（使用 21 号端口）：另外一条用于传送文件内容（使用 20 端口）。</li><li><strong>TFTP</strong>（Trivial File Transfer Protocol），简单文件传输协议），建立在<em>UDP</em>之上，提供不可靠的数据流传输服务。</li><li><strong>HTTP</strong>（HyperText Transfer Protocol，超文本传输协议）：是用于从 WWW 服务器传输超文本到本地浏览器的传输协议，建立在<em>TCP</em>之上。</li><li><strong>SMTP</strong>（Simple Mail Transfer Protocol，简单邮件传输协议）：建立在<em>TCP</em>之上，是一种提供可靠且有效的电子邮件传输协议。</li><li><strong>DHCP</strong>（Dynamic Host Configuration Protocol，动态主机配置协议）：建立在<em>UDP</em>之上，基于客户端&#x2F;服务器模型设计的。所有的 IP 网络设定数据都由 DHCP 服务器集中管理，并负责客户端的 DHCP 请求。</li><li><strong>Telnet</strong>（远程登录协议）：是登录和仿真程序，建立在<em>TCP</em>之上，他的基础功能是允许用户登录进入远程计算机。</li><li><strong>DNS</strong>（Domain Name System，域名系统）：实现域名解析，建立在<em>UDP</em>之上。</li><li><strong>SNMP</strong>（Simple Network Management Protocol，简单网络管理协议）：由一组网络管理的标准组成，包含一个应用层协议、数据库模型和一组资源对象。该协议能够支持网络管理系统，用以监测连接到网络上的设备是否有任何引起管理上注意的情况。</li></ul><ol start="2"><li>传输层协议</li></ol><ul><li><strong>TCP</strong>（Transmission Control Protocol，传输控制协议）：TCP 提供了一个可靠的，面向连接的，全双工的数据传输服务。TCP 一般用于传输数据量比较少，且对可靠性要求高的场合。</li><li><strong>UDP</strong>（User Datagram Protocol，用户数据报协议）：UDP 是一种不可靠的，无连接的协议，可以保证应用程序间的通信，与 TCP 相比，UDP 是一种无连接的协议，它的错误检测功能要弱的多，UDP 协议一般用于传输数据量大，对于可靠性要求不是很高，但要求速度快的场合。</li></ul><ol start="3"><li>网络层协议</li></ol><ul><li><strong>IP</strong>（Internet Protocol，互联网协议）：所提供的服务是无连接和可靠的。</li><li><strong>ICMP</strong>（Internet Control Message Protocol，互联网控制报文协议）：一种专门用于发送错误报文的协议，即传送的数据可能丢失、重复、延迟或乱序传递，所以需要一种尽量避免差错并能在发生差错时报告的机制，这就是 ICMP 的功能。</li><li><strong>IGMP</strong>（Internet Group Management Protocol，互联网组管理协议）：允许在 Internet 中的计算机参加多播，是计算机用做向相邻多路由器报告多目组成员的协议。</li><li><strong>ARP</strong>（Address Resolution Protocol，地址解析协议）：用于动态地完成 IP 到物理地址的转换。</li><li><strong>RARP</strong> （Reverse Address Resolution Protocol，反向地址解析协议）：用于动态地完成物理地址到 IP 地址的转换。</li></ul></div></details><h3 id="网络设备"><a href="#网络设备" class="headerlink" title="网络设备"></a>网络设备</h3><details class="toggle" ><summary class="toggle-button" style="">1、网络交换</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">定义</summary><div class="toggle-content"><p>通过一定的设备，如交换机等，将不同的信号或者信号转换为对方可识别的信号类型从而达到通信目的的一种交换形式。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">分类</summary><div class="toggle-content"><ol><li>物理交换（如电话网）</li><li>链路层交换（二层交换，对 MAC 地址进行变更🔥）</li><li>网络层交换（三层交换，对 IP 地址进行变更）</li><li>传输层交换（四层交换，对端口进行变更，比较少见）</li><li>应用层交换</li></ol></div></details></div></details><details class="toggle" ><summary class="toggle-button" style="">2、互联设备</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">定义</summary><div class="toggle-content"><p>在网络互连时，各节点一般不能简单地直接相连，而是需要通过一个中间设备来实现。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">分类</summary><div class="toggle-content"><ol><li>中继器（实现物理层协议转换，在电缆间进行二进制信号）</li><li>网桥（实现物理层和数据链路层协议转换）</li><li>路由器（实现网络层协议和以下各层协议的转换）（🔥在网络层）</li><li>网关（提供从最底层到传输层或以上各层的协议转换）</li><li>交换机</li></ol></div></details></div></details><details class="toggle" ><summary class="toggle-button" style="">3、无线网络设备</summary><div class="toggle-content"><ol><li>无线网卡</li><li>无线 AP</li><li>无线网桥</li><li>无线路由器</li></ol></div></details><h3 id="网络服务器"><a href="#网络服务器" class="headerlink" title="网络服务器"></a>网络服务器</h3><blockquote><p>无重要考点</p></blockquote><h3 id="网络存储技术"><a href="#网络存储技术" class="headerlink" title="网络存储技术"></a>网络存储技术</h3><details class="toggle" ><summary class="toggle-button" style="">DAS🔥</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">定义</summary><div class="toggle-content"><p>直接附加存储（Direct Attached Storage），DAS 将存储设备通过 SCSI 电缆直接连到服务器，其本身是硬件的堆叠，存储依赖于服务器，不带有任何存储操作系统。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">缺点🔥</summary><div class="toggle-content"><p>当存储容量增加时，DAS 方式很难扩展，这对存储容量的升级是一个巨大的瓶颈。</p></div></details></div></details><details class="toggle" ><summary class="toggle-button" style="">NAS🔥</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">定义</summary><div class="toggle-content"><p>网络附加存储（Network Attached Storage），通过网络接口与网络相连，由用户通过网络访问。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">工作原理🔥</summary><div class="toggle-content"><p>NAS 技术支持多种 TCP&#x2F;IP 网络协议，主要是 NFS（网络文件存储系统）和 CIFS（通用 Internet 文件）来进行文件访问。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">特点🔥</summary><div class="toggle-content"><ul><li>即插即用</li><li>小文件级的共享存取</li></ul></div></details><p><img src="https://picbed.qunarzz.com/7bb699e595dcd42ffa6d6a6b9ad5e982.png" alt="NAS 存储系统的结构"></p></div></details><details class="toggle" ><summary class="toggle-button" style="">SAN🔥</summary><div class="toggle-content"><details class="toggle" ><summary class="toggle-button" style="">定义</summary><div class="toggle-content"><p>存储区域网络（Storage Area Network），通过专用交换机将磁盘阵列与服务器连接起来的高速专用子网。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">技术分类</summary><div class="toggle-content"><ol><li><strong>FC SAN</strong>：光纤通道的主要特性有：热插拔性、高速带宽、远程连接数量大。</li><li><strong>IP SAN</strong>：基于 IP 网络实现数据块级别存储方式的存储网络。</li><li><strong>IB SAN</strong>：是一种交换结构 I&#x2F;O 技术，其设计思路是通过一套中心机构在远程存储器、网络以及服务器等设备之间建立一个单一的连接链路，并由 IB 交换机来指挥流量。</li></ol></div></details><p><img src="https://picbed.qunarzz.com/61c61873ce628e907c850fe99eb9fe3a.png"></p></div></details><h3 id="网络接入技术"><a href="#网络接入技术" class="headerlink" title="网络接入技术"></a>网络接入技术</h3><details class="toggle" ><summary class="toggle-button" style="">1、有线接入</summary><div class="toggle-content"><ol><li>PSTN</li><li>ISDN</li><li>ADSL</li><li>FTTX+LAN</li><li>HFC<br>1.3.5网络接入技术</li></ol></div></details><details class="toggle" ><summary class="toggle-button" style="">2、无线接入</summary><div class="toggle-content"><p>无线网络是指以无线电波作为信息传输媒介🔥</p><p><strong>技术分类：</strong></p><ol><li>GPRS</li><li>无线接入</li><li>3G</li><li>4G</li><li>WIFI</li></ol></div></details><h3 id="网络规划与设计"><a href="#网络规划与设计" class="headerlink" title="网络规划与设计"></a>网络规划与设计</h3><details class="toggle" ><summary class="toggle-button" style="">1、网路分层设计🔥</summary><div class="toggle-content"><ul><li><strong>核心层🔥</strong>：主要目的通过<strong>高速的转发通信</strong>，提供优化，可靠的骨干传输结构，因此，核心层交换机应拥有更高的可靠性，性能和吞吐量。</li><li><strong>汇聚层🔥</strong>：是核心层与接入层的分界面，完成<strong>网络访问策略控制，数据包处理、过滤、寻址</strong>、以及其他的数据处理任务。</li><li><strong>接入层🔥</strong>：目的是允许终端用户连接到网络，因此，接入层交换机（或路由器）接入层具有<strong>低成</strong>本和<strong>高密度</strong>特性。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/youngjuning/images@main/1677082670910.png" alt="网络规划分层"></p></div></details><details class="toggle" ><summary class="toggle-button" style="">1、网络设计工作</summary><div class="toggle-content"><ol><li>网络拓扑结构设计</li><li>主干网络设计（核心层）设计</li><li>汇聚层和接入层设计</li><li>广域网连接与远程访问设计</li><li>无线网络设计</li><li>网络安全设计</li></ol><ul><li>信息安全的基本要素🔥</li></ul><ol start="7"><li>设备选型</li></ol><details class="toggle" ><summary class="toggle-button" style="">信息安全的基本要素🔥</summary><div class="toggle-content"><ol><li><strong>机密性🔥</strong>：确保信息不暴露给未授权的实体或进程</li><li><strong>完整性🔥</strong>：只有得到允许的人才能修改数据，并且能够判别出来数据是否已被篡改。</li><li><strong>可用性🔥</strong>：得到授权的实体在需要的时候可访问数据，即攻击者不能占用所有的资源而阻碍授权者的工作</li><li><strong>可控性🔥</strong>：可以控制授权范围内的信息流向及行为方式</li><li><strong>可审查性🔥</strong>：对出现的网络安全问题提供调查的依据和手段</li></ol></div></details></div></details><h3 id="数据库管理系统"><a href="#数据库管理系统" class="headerlink" title="数据库管理系统"></a>数据库管理系统</h3><details class="toggle" ><summary class="toggle-button" style="">关系型数据库</summary><div class="toggle-content"><ul><li><strong>Oracle</strong></li><li><strong>MySQL</strong></li><li><strong>SqlServer</strong></li><li>DB2</li><li>PostgreSQL</li><li>SQLite</li><li>Access</li></ul></div></details><details class="toggle" ><summary class="toggle-button" style="">非关系型数据库</summary><div class="toggle-content"><ul><li><strong>MongoDB</strong></li><li>Redis</li><li>HBase</li><li>Neo4j</li><li>Elasticsearch</li></ul></div></details><h3 id="数据仓库技术"><a href="#数据仓库技术" class="headerlink" title="数据仓库技术"></a>数据仓库技术</h3><details class="toggle" ><summary class="toggle-button" style="">特点🔥</summary><div class="toggle-content"><p>数据仓库是一个面向主题的，集成的，非易失的，且随时间变化的数据集合，用于支持管理决策。</p></div></details><details class="toggle" ><summary class="toggle-button" style="">体系结构</summary><div class="toggle-content"><ol><li><strong>数据源</strong>：是数据仓库系统的基础，是整个系统数据源泉。</li><li><strong>数据的存储与管理</strong>：是整个系统数据仓库系统的核心。</li><li><strong>OLAP（Online Analysis Processor，联机分析处理）服务器</strong>：对分析需要的数据进行有效集成，按多维模型予以组织，以便进行多角度、多层次的分析，并发现趋势。</li><li><strong>前端工具</strong>：主要包括各种查询工具，报表工具，分析工具，数据挖掘工具以及各种基于数据仓库或数据集的应用开发工具。其中数据分析工具主要针对OLAP，报表工具，数据挖掘工具主要针对数据仓库。</li></ol></div></details><p><img src="https://cdn.jsdelivr.net/gh/youngjuning/images@main/1677083599886.png" alt="数据仓库体系结构"></p><h3 id="中间件技术"><a href="#中间件技术" class="headerlink" title="中间件技术"></a>中间件技术</h3><details class="toggle" ><summary class="toggle-button" style="">1、定义</summary><div class="toggle-content"></div></details><details class="toggle" ><summary class="toggle-button" style="">2、分类</summary><div class="toggle-content"></div></details><details class="toggle" ><summary class="toggle-button" style="">3、中间件的选择</summary><div class="toggle-content"></div></details><h3 id="高可用性和高可靠性的规划与设计"><a href="#高可用性和高可靠性的规划与设计" class="headerlink" title="高可用性和高可靠性的规划与设计"></a>高可用性和高可靠性的规划与设计</h3><h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><h2 id="练一练"><a href="#练一练" class="headerlink" title="练一练"></a>练一练</h2><p>1、对象和类是面向对象中两个重要的概念，关于对象和类，不正确的是（）。 <em>19年11月第1题</em></p><p>A、对象是类的实例<br>B、类是对象的抽象<br>C、一个类只能产生一个对象<br>D、类中包含方法和属性</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>C</strong><br>【解析】一个类可以产生多个对象</p></div></div><hr><p>2、TCP&#x2F;IP 模型中，Telnet 属于（）协议。 <em>19年5月19题</em></p><p>A、接口层<br>B、网络层<br>C、传输层<br>D、应用层</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>D</strong><br>【解析】Telnet 是应用层协议。</p></div></div><hr><p>3、在信息系统的生命周期中，开发阶段不包括（）。 <em>19年5月3题</em></p><p>A、系统规划<br>B、系统设计<br>C、系统分析<br>D、系统实施</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>A</strong><br>【解析】系统规划是立项阶段的，高级教材第三版 P10。</p></div></div><hr><p>4、（）的设计方法满足了信息系统快速响应需求与环境的变化，组织内部、组织之间各种应用系统的互相通信要求，提高了系统可复用性、信息资源共享和系统之间的互操作性。 <em>18年11月28题</em></p><p>A、面向对象<br>B、面向过程<br>C、基于构件<br>D、面向服务</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>D</strong><br>【解析】从应用的角度来看，组织内部、组织之间各种应用系统的互相通信和互操作性直接影响着组织<br>对信息的掌握程度和处理速度。如何使信息系统快速响应需求与环境变化，提高系统可复用性、信息资<br>源共享和系统之间的互操作性，成为影响信息化建设效率的关键问题，而SO的思维方式恰好满足了这<br>种需求。</p></div></div><hr><p>5、在OSI七层协议中，UDP是（）的协议。 <em>18年11月第19题</em></p><p>A、网络层<br>B、传输层<br>C、会话层<br>D、应用层</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>B</strong><br>【解析】(4)传输层：主要负责确保数据可靠、顺序、无错地从A点传输到B点。如提供建立、维护相拆<br>除传送连接的功能；选择网络层提供最合适的服务；在系统之间提供可靠的透明的数据传送，提供端到<br>端的错误恢复和流量控制。在TCP&#x2F;IP协议中，具体协议有TCP、UDP、SPX。</p></div></div><hr><p>6、（）的任务是：根据系统说明书规定的功能要求，考虑实际条件，具体设计实现逻辑模型的技术方<br>案。 <em>18年11月第3题</em></p><p>A、系统规划阶段<br>B、系统分析阶段<br>C、系统设计阶段<br>D、系统实施阶段</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>C</strong><br>【解析】简单地说，系统分析阶段的任务是回答系统“做什么”的问题，而系统设计阶段要回答的问题<br>是“怎么做”。该阶段的任务是根据系统说明书中规定的功能要求，考虑实际条件，具体设计实现逻辑<br>模型的技术方案，也就是设计新系统的物理模型。这个阶段又称为物理设计阶段，可分为总体设计（概<br>要设计）和详细设计两个子阶段。这个阶段的技术文档是系统设计说明书。</p></div></div><hr><p>7、IEEE 802 规范定义了网卡如何访问传输介质，以及如何在传输介质上传输数据的方法。其中，（）<br>是重要的局域网协议。 <em>18年5月第11题</em></p><p>A、IEEE 802.1<br>B、IEEE 802.3<br>C、IEEE 802.6<br>D、IEEE 802.11</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>B</strong><br>【解析】 IEEE 802.3 ：以太网介质访问控制协议 （CSMA&#x2F;CD）及物理层技术规范 [2]。<br>IEEE 802.11：无线局域网（WLAN）的介质访问控制协议及物理层技术规范。</p></div></div><hr><p>8、在开放系统互连参考模型(OSI)中，（ ）的主要功能是将网络地址翻译成对应的物理地址，并决定如<br>何将数据从发送方经路由送达到接收方。 <em>18年5月第20题</em></p><p>A、数据链路层<br>B、物理层<br>C、网络层<br>D、传输层</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>C</strong><br>【解析】网络层中的协议主要有IP、ICMP、IGMP、ARP、和RARP等。 （1）IP，所提供的服务是无连接和不可靠的。<br>（2）ICMP(Internet Control Message Protocol，网络控制报文协议)，一种专门用于发送错报文的<br>协议，即传送的数据可能丢失、重复、延迟、或乱序传递，所以需要一种尽量避免差错并能发生差错时<br>报告的机制，这就是ICMP的功能。<br>（3）IGMP(Internet Group Management Protocol，网际组管理协议)允许在Internet中的计算机参<br>加多播，是计算机用做向相邻多路由器报告多目组成员的协议。<br>（4）ARP(Address Resolution Protocol，地址解析协议) 用于动态地完成IP到物理地址的转换。<br>（5）RARP(Reverse Address Resolution Protocol，反向地址解析协议)用于动态完成物理地址向IP<br>地址的转换。</p></div></div><hr><p>9、 TCP&#x2F;IP是internet的核心协议，应用程序通过用应用层协议利用网络完成数据交互的任务，其中，<br>（）是用来在客户机与服务器之间进行简单文件的传输的协议，提供不复杂，开销不大的文件传输服务。 <em>18年5月第19题</em></p><p>A、FTP<br>B、TFTP<br>C、HTTP<br>D、SMTP</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>B</strong><br>【解析】TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP&#x2F;IP协议族中的一个用来在客<br>户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。</p></div></div><hr><p>10、某快消品连锁企业委托科技公司A开发部署电子商务平台，A公司根据系统设计任务书所确定的范<br>围，确定系统的基本目标和逻辑功能要求，提出新系统的逻辑模型，这属于信息系统生命周期中（）阶<br>段的工作。 <em>18年5月第3题</em></p><p>A、系统规划<br>B、系统分析<br>C、系统设计<br>D、系统实施</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>B</strong><br>【解析】系统分析阶段的任务是根据系统设计任务书所确定的范围，对现行系统进行详细调查，描述现<br>行系统的业务流程，指出现行系统的局限性和不足之处，确定新系统的基本目标和逻辑功能要求，即提<br>出新系统的逻辑模型。</p></div></div><hr><p>11、在软件需求分析中，（）分别用来表示功能模型和行为模型。 <em>19年11月第7题</em></p><p>A、数据流图、状态转换图<br>B、状态转换图、E-R图<br>C、状态转换图、数据流图<br>D、E-R图、状态转换图</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>A</strong><br>【解析】E-R图是用来表示数据模型的，行为一般与状态有关。</p></div></div><hr><p>12、中间件是一种独立的系统软件或服务程序，（）不属于中间件。 <em>19年11月第2题</em><br>A、Tomcat<br>B、Websphere<br>C、ODBC<br>D、Python</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>D</strong><br>【解析】Python 属于开发语言</p></div></div><hr><p>13、项目成员张工绘制了四张类图，其中不正确的是（）。 <em>19年5月第27题</em></p><p><img src="https://cdn.jsdelivr.net/gh/youngjuning/images@main/1677084628615.png"></p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【答案】<strong>B</strong></p></div></div><hr><p>14、在 UML 的顺序图中，通常由左向右分层排列各个对象，正确的排列方法是（）。<em>19年5月第26题</em></p><p>A、执行者角色、控制类、用户接口、业务层、后台数据库<br>B、执行者角色、用户接口、控制类、业务层、后台数据库<br>C、执行者角色、控制类、用户接口、后台数据库、业务层<br>D、执行者角色、用户接口、业务层、控制类、后台数据库</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>A</strong></p></div></div><hr><p>15、执行者与用例之间的关系是（）。 <em>19年5月第25题</em></p><p>A、包含关系<br>B、泛化关系<br>C、关联关系<br>D、扩展关系</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】C<br>【解析】在用例图中执行者与用例之间是关联关系。</p></div></div><hr><p>16、UML的（）描述了一个特定对象的所有可能状态以及由于各种事件的发生而引起的状态之间的转移。 <em>18年11月第27题</em></p><p>A、控制图<br>B、状态图<br>C、协作图<br>D、序列图</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>B</strong><br>【解析】状态图（state diagram）：状态图描述一个状态机，它由状态、转移、事件和活动组成。状态图给出了对象的动态视图。它对于接口、类或协作的行为建模尤为重要，而且它强调事件导致的对象行为，这非常有助于对反应式系统建模。</p></div></div><hr><p>17、某企业要建设信息系统平台，要求系统可用性达到99.99%。系统A平均无故障时间10000小时，故<br>障平均维修时间1小时：系统B平均无故障时间14000小时，故障平均维修时间1.5小时。以下说法中，<br>正确的是（）。 <em>18年11月第22题</em></p><p>A、只有系统A符合可用性要求<br>B、系统A和系统B均符合可用性要求<br>C、只有系统B符合可用性要求<br>D、系统A和系统B都不符合可用性要求</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>A</strong><br>【解析】计算机系统的可用性用平均无故障时间(MTTF)来度量，即计算机系统平均能够正常运行多长<br>时间，才发生一次故障。系统的可用性越高，平均无故障时间越长。可维护性用平均维修时间(MTTR)<br>来度量，即系统发生故障后维修和重新恢复正常运行平均花费的时间。系统的可维护性越好，平均维修<br>时间越短。计算机系统的可用性定义为：MTTF&#x2F; (MTTF+MTTR) ,kl00%。由此可见，计算机系统的可<br>用性定义为系统保持正常运行时间的百分比。所以，想要提高一个系统的可用性，要么提升系统的单次<br>正常工作的时长，要么减少故障修复时间。<br>A的可用性&#x3D;10000&#x2F;10001&#x3D;99.99%<br>B的可用性&#x3D;14000&#x2F;14001.5 &#x3D; 99.98%<br>只有系统A负荷可用性要求</p></div></div><hr><p>18、关于网络存储技术的描述，正确的是：（）。<br>A、DAS 是一种易于扩展的存储技术<br>B、NAS 系统与 DAS 系统相同，都没有自己的文件系统<br>C、NAS 可以使用 TCP&#x2F;IP 作为其网络传输协议<br>D、SAN 采用了文件共享存取方式</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>C</strong><br>【解析】NAS 技术支持多种 TCP&#x2F;IP 网络协议，主要是NFS (Net File System，网络文件系统)和 CIFS<br>（Common Internet File System，通用 Internet 文件系统）来进行文件访问，所以 NAS 的性能特点是<br>进行小文件级的共享存取。在具体使用时，NAS设备通常配置为文件服务器，通过使用基于 Web 的管<br>理界面来实现系统资源的配置、用户配置管理和用户访问登录等。</p></div></div><hr><p>19、软件需求是多层次的，包括业务需求、用户需求、系统需求，其中业务需求（）。 <em>18年11月第7题</em></p><p>A、反应了企业或客户对系统高层次的目标需求<br>B、描述了用户具体目标或者用户要求系统必须完成的任务<br>C、从系统角度来说明软件的需求，包括功能需求、非功能需求和设计约束<br>D、描述了用户任务系统应该具备的功能和性能</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>A</strong><br>【解析】业务需求。业务需求是指反映企业或客户对系统高层次的目标要求，通常来自项目投资人、购买产品的客户、客户单位的管理人员、市场营销部门或产品策划部门等。通过业务需求可以确定项目视图和范围，项目视图和范围文档把业务需求集中在一个简单、紧凑的文档中，该文档为以后的开发工作奠定了基础。</p></div></div><hr><p>20、UML图不包括（）。 <em>18年5月第27题</em></p><p>A、用例图<br>B、序列图<br>C、组件图<br>D、继承图</p><div class="hide-block"><button type="button" class="hide-button" style="">答案解析    </button><div class="hide-content"><p>【重要性】一定要掌握<br>【答案】<strong>D</strong><br>【解析】类图表示类、接口和它们之间的协作关系，没有继承图</p></div></div>]]></content>
    
    
    <summary type="html">信息系统项目管理师考试属于全国计算机技术与软件专业技术资格考试中的一个高级考试。</summary>
    
    
    
    <category term="软考" scheme="https://youngjuning.js.org/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="信息系统项目管理师" scheme="https://youngjuning.js.org/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"/>
    
    <category term="信息化" scheme="https://youngjuning.js.org/tags/%E4%BF%A1%E6%81%AF%E5%8C%96/"/>
    
    <category term="信息系统" scheme="https://youngjuning.js.org/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="高项" scheme="https://youngjuning.js.org/tags/%E9%AB%98%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>信息系统项目管理师备考指南</title>
    <link href="https://youngjuning.js.org/9698ac1384d7/"/>
    <id>https://youngjuning.js.org/9698ac1384d7/</id>
    <published>2023-02-15T16:04:55.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<h2 id="考试介绍"><a href="#考试介绍" class="headerlink" title="考试介绍"></a>考试介绍</h2><p>全国计算机技术与软件专业技术资格考试设三个级别层次，五个专业，共有 27 种岗位资格考试。而<strong>信息系统项目管理师</strong>考试属于全国计算机技术与软件专业技术资格考试中的一个<strong>高级考试</strong>。</p><h2 id="报考条件"><a href="#报考条件" class="headerlink" title="报考条件"></a>报考条件</h2><p>信息系统项目管理师考试报考条件不设学历与资历条件、年龄以及专业等限制，考生可根据自己的技术水平选择合适的级别以及合适的资格进行报考。</p><blockquote><p>注意：每次考试每个人只允许报考一种资格。</p></blockquote><h2 id="考试流程"><a href="#考试流程" class="headerlink" title="考试流程"></a>考试流程</h2><ol><li><a href="https://bm.ruankao.org.cn/sign/welcome">报名</a>（2月 - 3月）</li><li>打印准考证（考前一周）</li><li>考试（5 月 27 日）</li><li>公布成绩（考后一个月左右）</li><li>领取证书（9 月份左右）</li></ol><h2 id="考题分析"><a href="#考题分析" class="headerlink" title="考题分析"></a>考题分析</h2><table><thead><tr><th align="center">科目</th><th align="center">内容</th><th align="center">时长</th><th align="center">考试时间</th></tr></thead><tbody><tr><td align="center">综合知识</td><td align="center">75道选择题，知识范围很广，包含：IT 知识、时事政治、项目管理、5 分的运筹学、5 分英语题</td><td align="center">150 分钟</td><td align="center">上午<br />9:00 - 11:00</td></tr><tr><td align="center">案例分析</td><td align="center">3 道大题：1 道计算题，2 道分析题</td><td align="center">90 分钟</td><td align="center">下午<br />1:30 - 3:00</td></tr><tr><td align="center">论文写作</td><td align="center">1 道论文题，考试范围：<strong>十大管理</strong>、安全管理、合同管理、招投标</td><td align="center">120 分钟</td><td align="center">下午<br />3:20 - 5:20</td></tr></tbody></table><h2 id="学习计划"><a href="#学习计划" class="headerlink" title="学习计划"></a>学习计划</h2><p>计划共历时 100 天，每天投入 2 - 3 小时，总投入预计 200 - 300 小时。</p><ul><li>第一阶段（35 天）(2023&#x2F;2&#x2F;15 - 2023&#x2F;3&#x2F;21)<ul><li>基础知识</li><li>计算专题</li></ul></li><li>第二阶段（50 天）(2023&#x2F;3&#x2F;22 - 2023&#x2F;5&#x2F;10)<ul><li>历年真题</li><li>案例分析</li><li>写作专题</li></ul></li><li>第三阶段 (15 天)（2023&#x2F;5&#x2F;11 - 2023&#x2F;5&#x2F;26）<ul><li>考前冲刺</li></ul></li></ul><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><ul><li><a href="https://www.ruankao.org.cn/">中国计算机技术资格网</a></li><li>软考真题 App<ul><li><a href="https://apps.apple.com/hk/app/%E8%BD%AF%E8%80%83%E7%9C%9F%E9%A2%98-2022%E4%BF%A1%E6%81%AF%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%B3%BB%E7%BB%9F%E9%9B%86%E6%88%90/id1468131830">iOS</a></li><li><a href="https://www.wandoujia.com/apps/7873801">Android</a></li></ul></li><li>软考通 App<ul><li><a href="https://apps.apple.com/cn/app/%E8%BD%AF%E8%80%83%E9%80%9A-2022%E5%B9%B4%E8%BD%AF%E4%BB%B6%E6%B0%B4%E5%B9%B3%E8%80%83%E8%AF%95%E6%8F%90%E5%88%86%E7%A5%9E%E5%99%A8/id1498444438">iOS</a></li><li><a href="https://www.wandoujia.com/apps/8095598">Android</a></li></ul></li><li>软考刷题王<ul><li>#小程序:&#x2F;&#x2F;软考刷题王&#x2F;I4Jk3d4HRskRbaw</li></ul></li><li><img src="https://cdn.jsdelivr.net/gh/youngjuning/images@main/1677062492249.png" alt="杭州 E 类人才福利"></li></ul>]]></content>
    
    
    <summary type="html">信息系统项目管理师考试属于全国计算机技术与软件专业技术资格考试中的一个高级考试。</summary>
    
    
    
    <category term="软考" scheme="https://youngjuning.js.org/categories/%E8%BD%AF%E8%80%83/"/>
    
    
    <category term="信息系统项目管理师" scheme="https://youngjuning.js.org/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/"/>
    
    <category term="信息化" scheme="https://youngjuning.js.org/tags/%E4%BF%A1%E6%81%AF%E5%8C%96/"/>
    
    <category term="信息系统" scheme="https://youngjuning.js.org/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="高项" scheme="https://youngjuning.js.org/tags/%E9%AB%98%E9%A1%B9/"/>
    
    <category term="计算机" scheme="https://youngjuning.js.org/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>word-wrap 和 word-break</title>
    <link href="https://youngjuning.js.org/c607ec2b5110/"/>
    <id>https://youngjuning.js.org/c607ec2b5110/</id>
    <published>2023-02-13T05:47:56.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<p>word-wrap 和 word-break 是一对用于单词断句的双生属性，但是又有微妙的区别，每次要用的时候还要重新翻一下 MDN 文档，本文力求通过一张流程图快速记忆两者如何使用。</p><h2 id="word-wrap"><a href="#word-wrap" class="headerlink" title="word-wrap"></a>word-wrap</h2><p>css 的 word-wrap 属性用来标明是否允许浏览器在单词内进行断句，这是为了防止当一个字符串太长而找不到它的自然断句点时产生溢出现象。</p><ul><li>normal：就是大家平常见得最多的正常的换行规则。</li><li>break-word：一行单词中实在没有其他靠谱的换行点的时候在单词内换行。</li></ul><h2 id="word-break"><a href="#word-break" class="headerlink" title="word-break"></a>word-break</h2><p>css 的 word-break 属性用来标明怎么样进行单词内的断句。</p><ul><li>normal：使用默认的换行规则，即如果一个单词很长，导致一行中剩下的空间已经放不下它时，则浏览器会把这个单词挪到下一行去。</li><li>break-all：允许单词断行，即如果一个单词很长，导致一行中剩下的空间已经放不下它时，则浏览器不会把这个单词挪到下一行去，而是在单词内换行。</li></ul><h2 id="搭配使用，换行不累"><a href="#搭配使用，换行不累" class="headerlink" title="搭配使用，换行不累"></a>搭配使用，换行不累</h2><p><img src="https://picbed.qunarzz.com/3d7e329ab089d28c7bde5be75573f1d3.png"></p><blockquote><p>参考资料来自 <a href="https://www.cnblogs.com/2050/archive/2012/08/10/2632256.html">你真的了解word-wrap和word-break的区别吗？</a> 和 <a href="https://www.zhangxinxu.com/wordpress/2015/11/diff-word-break-break-all-word-wrap-break-word/">word-break:break-all和word-wrap:break-word的区别</a></p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;word-wrap 和 word-break 是一对用于单词断句的双生属性，但是又有微妙的区别，每次要用的时候还要重新翻一下 MDN 文档，本文力求通过一张流程图快速记忆两者如何使用。&lt;/p&gt;
&lt;h2 id=&quot;word-wrap&quot;&gt;&lt;a href=&quot;#word-wrap&quot; </summary>
      
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="CSS" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/CSS/"/>
    
    
    <category term="CSS" scheme="https://youngjuning.js.org/tags/CSS/"/>
    
    <category term="word-wrap" scheme="https://youngjuning.js.org/tags/word-wrap/"/>
    
    <category term="word-break" scheme="https://youngjuning.js.org/tags/word-break/"/>
    
  </entry>
  
  <entry>
    <title>OpenAI 推出超神 ChatGPT 注册攻略来了</title>
    <link href="https://youngjuning.js.org/d744d1d3d1e8/"/>
    <id>https://youngjuning.js.org/d744d1d3d1e8/</id>
    <published>2023-02-06T07:58:31.000Z</published>
    <updated>2023-03-07T10:29:44.640Z</updated>
    
    <content type="html"><![CDATA[<p>OpenAI 推出超神 ChatGPT，非常火爆。但是呢，因为不可抗力原因，大部分人无法体验到。这里我分享一下注册的攻略。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><ul><li>首先能能访问 Google（前置条件，不能明确说，懂得都懂）</li><li>你得有一个国外手机号，GV 号肯定不行。<ul><li>如果你没有国外手机号，推荐sms-activate.org</li></ul></li></ul><h3 id="注册短信平台并充值"><a href="#注册短信平台并充值" class="headerlink" title="注册短信平台并充值"></a>注册短信平台并充值</h3><ul><li>先行注册sms-activate.org</li><li>注册好之后进行对应的充值</li></ul><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8acaf6d767714b1d82122cd3206f4ba7~tplv-k3u1fbpfcp-watermark.image"></p><p>接码费用一次为 10.5 卢布，大约1.2 人民币。因为充值默认为美元，可以选择充值 1 美元进去，</p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5c507b1564d1442d8dfab0ebc8d481e1~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="注册OpenAI账号"><a href="#注册OpenAI账号" class="headerlink" title="注册OpenAI账号"></a>注册OpenAI账号</h3><ul><li>打开<a href="https://beta.openai.com/signup">https://beta.openai.com/signup</a> 页面进行相应的注册。<ul><li>这里同样需要你能访问Google且 ip 不是香港，最好是美国、新加坡等等，不然会提示不能在当前国家服务。</li></ul></li><li>注册成功进入下面填写手机号的页面<ul><li>下面记得切换下国家区号，这里的区号默认是你代理的。</li></ul></li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/d50d22c04df0430aa0b2afca70a55beb~tplv-k3u1fbpfcp-watermark.image"></p><h3 id="准备接码"><a href="#准备接码" class="headerlink" title="准备接码"></a>准备接码</h3><blockquote><p>这里需要注意下的就是，目前好像就只有巴西支持了，之前我选的印尼，是可以收到码的。</p></blockquote><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/79235be8d7104175a6dda1cc63f46937~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c2e4434858ab4cbaaa9e1d8249305547~tplv-k3u1fbpfcp-watermark.image"></p><ul><li>然后再刚刚填写手机号码的页面填入申请的手机号</li></ul><h3 id="开始使用ChatGPT"><a href="#开始使用ChatGPT" class="headerlink" title="开始使用ChatGPT"></a>开始使用ChatGPT</h3><p>注册完后，我们去ChatGPT网站去登陆。<a href="https://chat.openai.com/auth/login">https://chat.openai.com/auth/login</a></p><p><img src="https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/3e474b55d15d4b8ea3c56e7deb5ce8f9~tplv-k3u1fbpfcp-watermark.image"></p><p><img src="https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bf36cc1afc9b45539f543211739c9f83~tplv-k3u1fbpfcp-watermark.image"></p><h4 id="12-月-6-日更新"><a href="#12-月-6-日更新" class="headerlink" title="12 月 6 日更新"></a>12 月 6 日更新</h4><ul><li>如果你的页面出现下面提示，说明你代理不行~~</li></ul><p><img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/bc290c2a7abf4c9faee9a392819d16e4~tplv-k3u1fbpfcp-watermark.image"></p><ul><li>接不到码，可以在那个有效期内退回换个号试试。<ul><li>有人直接把发的电话输入框里，没去掉区号也可以收到</li></ul></li><li>这个接码网站很全面，我演示充值是 1 美元，你也可以冲一个 0.18美元</li><li>目前完全支持的是印度+巴西。你也可以选择其他国家的 any+other 选择合适的费用即可。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;OpenAI 推出超神 ChatGPT，非常火爆。但是呢，因为不可抗力原因，大部分人无法体验到。这里我分享一下注册的攻略。&lt;/p&gt;
&lt;h3 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h3&gt;&lt;ul&gt;</summary>
      
    
    
    
    <category term="人工智能" scheme="https://youngjuning.js.org/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
    
    <category term="OPenAI" scheme="https://youngjuning.js.org/tags/OPenAI/"/>
    
    <category term="Chatgpt" scheme="https://youngjuning.js.org/tags/Chatgpt/"/>
    
    <category term="Chatgpt 注册" scheme="https://youngjuning.js.org/tags/Chatgpt-%E6%B3%A8%E5%86%8C/"/>
    
    <category term="人工智能" scheme="https://youngjuning.js.org/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>2023 年度计划</title>
    <link href="https://youngjuning.js.org/cb03d5cd6dce/"/>
    <id>https://youngjuning.js.org/cb03d5cd6dce/</id>
    <published>2023-01-31T03:50:26.000Z</published>
    <updated>2023-03-07T10:29:44.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="上半年"><a href="#上半年" class="headerlink" title="上半年"></a>上半年</h1><h2 id="继续教育-40"><a href="#继续教育-40" class="headerlink" title="继续教育 40%"></a>继续教育 40%</h2><blockquote><p>每天至少抽出两个小时备考</p></blockquote><ul><li>信息系统项目管理师</li></ul><h2 id="生活娱乐-30"><a href="#生活娱乐-30" class="headerlink" title="生活娱乐 30%"></a>生活娱乐 30%</h2><blockquote><p>每天至少 15 分钟的运动</p></blockquote><ul><li>备孕</li><li>落户杭州：为了以后孩子上学</li><li>减重到 145</li><li>带媳妇去一个海滨城市旅游</li></ul><h2 id="持续学习-30"><a href="#持续学习-30" class="headerlink" title="持续学习 30%"></a>持续学习 30%</h2><p>每天至少抽出一个小时学习</p><ul><li>《JavaScript 高级程序设计》复习一遍并产出一篇学习笔记</li><li>《React 设计》读一遍并产出一篇学习笔记</li><li>《JavaScript 数据结构与算法》读一遍并产出一篇学习笔记</li><li>力扣 200 两日刷一题</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>翻译完成 <a href="https://github.com/vscode-cn/vscode-api-cn">Vs Code API 中文文档</a></li><li>翻译完成 <a href="https://youngjuning.js.org/react-interview">React 面试必知必会</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;上半年&quot;&gt;&lt;a href=&quot;#上半年&quot; class=&quot;headerlink&quot; title=&quot;上半年&quot;&gt;&lt;/a&gt;上半年&lt;/h1&gt;&lt;h2 id=&quot;继续教育-40&quot;&gt;&lt;a href=&quot;#继续教育-40&quot; class=&quot;headerlink&quot; title=&quot;继续教育 40</summary>
      
    
    
    
    <category term="漫谈" scheme="https://youngjuning.js.org/categories/%E6%BC%AB%E8%B0%88/"/>
    
    
    <category term="程序员" scheme="https://youngjuning.js.org/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"/>
    
    <category term="杭州" scheme="https://youngjuning.js.org/tags/%E6%9D%AD%E5%B7%9E/"/>
    
    <category term="年度计划" scheme="https://youngjuning.js.org/tags/%E5%B9%B4%E5%BA%A6%E8%AE%A1%E5%88%92/"/>
    
  </entry>
  
  <entry>
    <title>NPM 常用命令</title>
    <link href="https://youngjuning.js.org/8e944d3670b0/"/>
    <id>https://youngjuning.js.org/8e944d3670b0/</id>
    <published>2022-11-17T04:02:58.000Z</published>
    <updated>2023-03-07T10:29:44.640Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全局"><a href="#全局" class="headerlink" title="全局"></a>全局</h2><ul><li><code>npm root --location=global</code>：查看全局包安装路径<blockquote><p>Mac 下默认的全局路径是：<code>/usr/local/lib/node_modules</code><br>Ubuntu 下默认的全局路径是: <code>/usr/lib/node_modules</code></p></blockquote></li><li><code>npm ls --location=global</code>：查看全局包列表<ul><li><code>npm ls --location=global --depth 0</code>：仅查看一级包</li><li><code>npm ls --location=global --depth 0 | grep packageName</code>：查看一级包并搜索相关包</li></ul></li></ul><h2 id="owner"><a href="#owner" class="headerlink" title="owner"></a>owner</h2><p>管理已经发布的包的所有权</p><ul><li><code>npm owner add &lt;user&gt; [&lt;@scope&gt;/]&lt;pkg&gt;</code>：给某个包添加用户</li><li><code>npm owner rm &lt;user&gt; [&lt;@scope&gt;/]&lt;pkg&gt;</code>：删除某个包的某个用户</li><li><code>npm owner ls [&lt;@scope&gt;/]&lt;pkg&gt;</code>：列出某个包的所有用户</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;全局&quot;&gt;&lt;a href=&quot;#全局&quot; class=&quot;headerlink&quot; title=&quot;全局&quot;&gt;&lt;/a&gt;全局&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm root --location=global&lt;/code&gt;：查看全局包安装路径&lt;blockquote&gt;
&lt;p</summary>
      
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="npm" scheme="https://youngjuning.js.org/tags/npm/"/>
    
    <category term="命令" scheme="https://youngjuning.js.org/tags/%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>2023 常用 NPM 包推荐</title>
    <link href="https://youngjuning.js.org/db7a22999938/"/>
    <id>https://youngjuning.js.org/db7a22999938/</id>
    <published>2022-11-02T07:58:31.000Z</published>
    <updated>2023-03-07T10:29:44.640Z</updated>
    
    <content type="html"><![CDATA[<p>帮助开发者从 NPM 包选型的角度感知和建立前端工程化体系。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><p><a href="https://www.npmjs.com/package/tape">tape</a></p><h2 id="编译工具"><a href="#编译工具" class="headerlink" title="编译工具"></a>编译工具</h2><ul><li><a href="https://www.npmjs.com/package/babel">babel</a></li></ul><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><ul><li><a href="https://www.npmjs.com/package/webpack">webpack</a></li><li><a href="https://www.npmjs.com/package/rollup">rollup</a></li><li><a href="https://www.npmjs.com/package/esbuild">esbuild</a></li></ul><h2 id="dotenv"><a href="#dotenv" class="headerlink" title="dotenv"></a>dotenv</h2><ul><li><a href="https://www.npmjs.com/package/dotenv">dotenv</a></li></ul><h2 id="Node-js-CLI"><a href="#Node-js-CLI" class="headerlink" title="Node.js CLI"></a>Node.js CLI</h2><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><ul><li><a href="https://www.npmjs.com/package/commander">commander</a>: Node.js命令行界面的完整解决方案,受Ruby Commander启发。 前端开发node cli 必备技能。</li><li><a href="https://www.npmjs.com/package/yargs">yargs</a>: 功能比较全，但是使用起来比较复杂。</li></ul><h3 id="命令行参数解析"><a href="#命令行参数解析" class="headerlink" title="命令行参数解析"></a>命令行参数解析</h3><ul><li><a href="https://www.npmjs.com/package/yargs-parser">yargs-parser</a>：yargs 命令行框架内置的命令行参数解析库，功能比较全，比较适合工程化实用。</li><li><a href="https://www.npmjs.com/package/minimist">minimist</a>：如果你喜欢轻量级的技术，那么 minimist 足够简单好用，代码量也很少（只有几百行），非常适合研读。</li><li>inquire.js</li><li>chalk: 美化命令行的模块</li><li>ora: 优雅的 spinner</li><li>ncp: 异步的拷贝文件，包含空文件夹</li><li>recursive-readdir: 递归地列出目录和子目录下的所有文件，不包含目录本身。</li><li>shelljs: 在 Node.js 中执行 Unix shell 命令</li><li>log-symbols: 打印日志的特殊标志</li><li><a href="https://www.npmjs.com/package/download-git-repo">download-git-repo</a>: Download and extract a git repository (GitHub, GitLab, Bitbucket) from node</li><li><a href="https://www.npmjs.com/package/global-prefix">global-prefix</a>: 获取 npm 全局安装的前缀</li><li><a href="https://www.npmjs.com/package/exec-sh">exec-sh</a>: 执行 shell 命令转发所有 stdio 流，比 shelljs exec 命令好用</li><li><a href="https://www.npmjs.com/package/wml">wml</a>: wml 侦听某个文件夹中的更改（使用 watchman），然后将更改的文件复制到另一个文件夹中。</li><li><a href="https://blog.ihaiu.com/cmd-open/">cmd-open</a>: 扩展 Windows 命令 open</li><li><a href="https://github.com/shelljs/shx">shx</a>: shx is a wrapper around ShellJS Unix commands, providing an easy solution for simple Unix-like, cross-platform commands in npm package scripts.</li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="css-modules"><a href="#css-modules" class="headerlink" title="css modules"></a>css modules</h3><ul><li><a href="https://www.npmjs.com/package/clsx">clsx</a></li><li><a href="https://www.npmjs.com/package/classnames">classnames</a></li></ul><h3 id="css-in-js"><a href="#css-in-js" class="headerlink" title="css-in-js"></a>css-in-js</h3><ul><li><a href="https://www.npmjs.com/package/styled-components">styled-components</a></li></ul><h2 id="React"><a href="#React" class="headerlink" title="React"></a>React</h2><h3 id="状态管理"><a href="#状态管理" class="headerlink" title="状态管理"></a>状态管理</h3><ul><li><a href="https://www.npmjs.com/package/redux">redux</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;帮助开发者从 NPM 包选型的角度感知和建立前端工程化体系。&lt;/p&gt;
&lt;h2 id=&quot;测试&quot;&gt;&lt;a href=&quot;#测试&quot; class=&quot;headerlink&quot; title=&quot;测试&quot;&gt;&lt;/a&gt;测试&lt;/h2&gt;&lt;h3 id=&quot;单元测试&quot;&gt;&lt;a href=&quot;#单元测试&quot; class</summary>
      
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="NPM" scheme="https://youngjuning.js.org/tags/NPM/"/>
    
    <category term="前端" scheme="https://youngjuning.js.org/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="前端工程化" scheme="https://youngjuning.js.org/tags/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/"/>
    
    <category term="前端开发" scheme="https://youngjuning.js.org/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>前端无感知刷新 Token</title>
    <link href="https://youngjuning.js.org/ac2c22966f31/"/>
    <id>https://youngjuning.js.org/ac2c22966f31/</id>
    <published>2022-10-31T05:43:33.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<p>为了安全考虑，一般后端都要求在请求接口时传递登录的 Token。为了防止 Token 泄漏的风险，服务器的 Token 一般不会设置太长时间，比如我最近联调的，两个小时就会过期，token 过期就需要重新登陆。频繁要求登陆会造成用户体验差，所以后端同时会提供刷新 Token 的接口，本文就是记录一下几种无感知刷新的方法。</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>在登录时，后端返回过期时间，前端每次请求就判断 token 的过期时间，如果快到过期时间，就去调用刷新 token 接口，我们可以封装一个 refreshToken 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">refreshToken</span> = <span class="keyword">async</span> (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="title function_">dayjs</span>().<span class="title function_">diff</span>(<span class="params">LOCAL_REFRESH_TIME &gt; LOCAL_EXPIRE</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">global</span>.<span class="property">workPromise</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">global</span>.<span class="property">workPromise</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">global</span>.<span class="property">workPromise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">async</span> (resolve) =&gt; &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">        <span class="attr">url</span>: <span class="string">`https://api.com/login`</span>,</span><br><span class="line">        <span class="comment">// other config</span></span><br><span class="line">        <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">// 更新 LOCAL_REFRESH_TIME</span></span><br><span class="line">      <span class="variable language_">global</span>.<span class="property">workPromise</span> = <span class="literal">null</span>;</span><br><span class="line">      <span class="title function_">resolve</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">global</span>.<span class="property">workPromise</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Access</span>_Token</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法主要原理是通过将 refresh 接口请求存在全局的 workPromise 中来保证在并发请求接口时只存在一个请求。</p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>登录时设置定时器刷新 token 接口，请求的时候判断当前是否有 workPromise 存在，如果存在就等刷新完成。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 登录后设置定时器</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">global</span>.<span class="property">workPromise</span> = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="keyword">async</span> (resolve) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;data&#125; = <span class="keyword">await</span> <span class="title function_">request</span>(&#123;</span><br><span class="line">      <span class="attr">url</span>: <span class="string">`https://api.com/login`</span>,</span><br><span class="line">      <span class="comment">// other config</span></span><br><span class="line">      <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    cookies.<span class="title function_">set</span>(<span class="string">&#x27;refresh_time&#x27;</span>)</span><br><span class="line">    <span class="variable language_">global</span>.<span class="property">workPromise</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="title function_">resolve</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="variable constant_">EXPIRE</span> / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">request</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">global</span>.<span class="property">workPromise</span>) &#123;</span><br><span class="line">    <span class="keyword">await</span> <span class="variable language_">global</span>.<span class="title function_">workPromise</span>()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方案由于有定时器一直存在，会额外消耗资源，不推荐使用。</p><h2 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h2><p>如果使用了 axios，可以在请求响应拦截器中拦截，判断 token 返回过期后，调用刷新 token 接口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否正在刷新的标记</span></span><br><span class="line"><span class="keyword">let</span> isRefreshing = <span class="literal">false</span></span><br><span class="line"><span class="comment">//重试队列</span></span><br><span class="line"><span class="keyword">let</span> requests = []</span><br><span class="line">service.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">//约定code 409 token 过期</span></span><br><span class="line">    <span class="keyword">if</span> (response.<span class="property">data</span>.<span class="property">code</span> === <span class="number">409</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!isRefreshing) &#123;</span><br><span class="line">        isRefreshing = <span class="literal">true</span></span><br><span class="line">        <span class="comment">//调用刷新token的接口</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title function_">refreshToken</span>().<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; token &#125; = res.<span class="property">data</span></span><br><span class="line">          <span class="comment">// 替换token</span></span><br><span class="line">          <span class="title function_">setToken</span>(token)</span><br><span class="line">          response.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="string">`<span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">           <span class="comment">// token 刷新后将数组的方法重新执行</span></span><br><span class="line">          requests.<span class="title function_">forEach</span>(<span class="function">(<span class="params">cb</span>) =&gt;</span> <span class="title function_">cb</span>(token))</span><br><span class="line">          requests = [] <span class="comment">// 重新请求完清空</span></span><br><span class="line">          <span class="keyword">return</span> <span class="title function_">service</span>(response.<span class="property">config</span>)</span><br><span class="line">        &#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">//跳到登录页</span></span><br><span class="line">          <span class="title function_">removeToken</span>()</span><br><span class="line">          router.<span class="title function_">push</span>(<span class="string">&#x27;/login&#x27;</span>)</span><br><span class="line">          <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">        &#125;).<span class="title function_">finally</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          isRefreshing = <span class="literal">false</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 返回未执行 resolve 的 Promise</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="comment">// 用函数形式将 resolve 存入，等待刷新后再执行</span></span><br><span class="line">          requests.<span class="title function_">push</span>(<span class="function"><span class="params">token</span> =&gt;</span> &#123;</span><br><span class="line">            response.<span class="property">headers</span>.<span class="property">Authorization</span> = <span class="string">`<span class="subst">$&#123;token&#125;</span>`</span></span><br><span class="line">            <span class="title function_">resolve</span>(<span class="title function_">service</span>(response.<span class="property">config</span>))</span><br><span class="line">          &#125;)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response &amp;&amp; response.<span class="property">data</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(error)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;为了安全考虑，一般后端都要求在请求接口时传递登录的 Token。为了防止 Token 泄漏的风险，服务器的 Token 一般不会设置太长时间，比如我最近联调的，两个小时就会过期，token 过期就需要重新登陆。频繁要求登陆会造成用户体验差，所以后端同时会提供刷新 Token</summary>
      
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="网络编程" scheme="https://youngjuning.js.org/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 隐式类型转换之相等操作符</title>
    <link href="https://youngjuning.js.org/f1f7395da421/"/>
    <id>https://youngjuning.js.org/f1f7395da421/</id>
    <published>2022-04-16T09:32:32.000Z</published>
    <updated>2023-03-07T10:29:44.640Z</updated>
    
    <content type="html"><![CDATA[<p>隐式类型转换多存在于使用 <code>==</code> 进行比较的场景，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a == b&#x27;</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>不同类型的值用相等运算符比较后的结果，可以用下表总结。</p><p><img src="https://s2.loli.net/2022/04/16/WZboPTdBRmXQkja.png"></p><p><code>toNumber</code> 方法对不同类型返回的结果如下。</p><p><img src="https://s2.loli.net/2022/04/17/VQ7BxmTqcOFUh34.png"></p><p><code>toPrimitive()</code>：如果对象的 <code>valueOf</code> 方法的结果是原始值，返回原始值；如果对象的 <code>toString</code> 方法返回原始值，就返回这个值；其他情况都返回一个错误。</p><p>用例子来验证一下表格中的结果。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> == <span class="string">&#x27;true&#x27;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><ul><li>首先，布尔值会被 <code>toNumber</code> 方法转换为数字，因此得到 <code>true == 1</code></li><li>其次，用 <code>toNumber</code> 转换字符串值。因为字符串包含字母，所以会被转成 <code>NaN</code>，因此表达式就变成了 <code>1 == NaN</code>，结果就是 false。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;隐式类型转换多存在于使用 &lt;code&gt;==&lt;/code&gt; 进行比较的场景，例如：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;</summary>
      
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="JavaScript" scheme="https://youngjuning.js.org/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>for-in 和 for-of 的区别</title>
    <link href="https://youngjuning.js.org/124e984dfd7e/"/>
    <id>https://youngjuning.js.org/124e984dfd7e/</id>
    <published>2022-04-12T09:13:30.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="迭代的输入不同"><a href="#迭代的输入不同" class="headerlink" title="迭代的输入不同"></a>迭代的输入不同</h1><ul><li><code>for...in</code> 可以对任何对象进行操作；它通常被用作检查对象的属性。</li><li><code>for...of</code> 只能对可迭代对象进行操作；它通常被用作迭代数组的元素。</li></ul><h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">c</span>: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(key); <span class="comment">// &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> obj) &#123; <span class="comment">// Uncaught TypeError: obj is not iterable</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="迭代的输出不同"><a href="#迭代的输出不同" class="headerlink" title="迭代的输出不同"></a>迭代的输出不同</h1><ul><li><code>for...in</code> 返回被迭代对象的键列表</li><li><code>for...of</code> 返回被迭代对象的数字属性的值列表</li></ul><h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例"></a>代码示例</h2><h3 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> list = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">list.<span class="property">foo</span> = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> list) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> list) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(i); <span class="comment">// &quot;&quot;4&quot;, &quot;5&quot;, &quot;6&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p><img src="https://s2.loli.net/2022/04/12/RycBMqHSUPr8uXg.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pets = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="string">&#x27;cat&#x27;</span>, <span class="string">&#x27;dog&#x27;</span>, <span class="string">&#x27;bat&#x27;</span>]);</span><br><span class="line">pets[<span class="string">&quot;species&quot;</span>] = <span class="string">&quot;mammal&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pet <span class="keyword">in</span> pets) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pet); <span class="comment">// &quot;species&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pet <span class="keyword">of</span> pets) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pet); <span class="comment">// &quot;cat&quot;, &quot;dog&quot;, &quot;bat&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><img src="https://s2.loli.net/2022/04/12/x3WkK54cEUq2pDn.png"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> pets = <span class="keyword">new</span> <span class="title class_">Map</span>([[<span class="string">&quot;1&quot;</span>, <span class="string">&quot;cat&quot;</span>],[<span class="string">&quot;2&quot;</span>, <span class="string">&quot;dog&quot;</span>],[<span class="string">&quot;3&quot;</span>, <span class="string">&quot;bat&quot;</span>]]);</span><br><span class="line">pets[<span class="string">&quot;species&quot;</span>] = <span class="string">&quot;mammal&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pet <span class="keyword">in</span> pets) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pet); <span class="comment">// &quot;species&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pet <span class="keyword">of</span> pets) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(pet); <span class="comment">// [&quot;1&quot;, &quot;cat&quot;], [&quot;2&quot;, &quot;dog&quot;], [&quot;3&quot;, &quot;bat&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://stackoverflow.com/questions/29285897/what-is-the-difference-between-for-in-and-for-of-statements">What is the difference between ( for… in ) and ( for… of ) statements?</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;迭代的输入不同&quot;&gt;&lt;a href=&quot;#迭代的输入不同&quot; class=&quot;headerlink&quot; title=&quot;迭代的输入不同&quot;&gt;&lt;/a&gt;迭代的输入不同&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;for...in&lt;/code&gt; 可以对任何对象进行操作；它通常被用作检查对象</summary>
      
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="JavaScript" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/JavaScript/"/>
    
    
    <category term="面试题" scheme="https://youngjuning.js.org/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>MongoDB 学习笔记</title>
    <link href="https://youngjuning.js.org/69a1dcb04fe1/"/>
    <id>https://youngjuning.js.org/69a1dcb04fe1/</id>
    <published>2022-04-12T08:55:53.000Z</published>
    <updated>2023-03-07T10:29:44.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="MongoDB-介绍"><a href="#MongoDB-介绍" class="headerlink" title="MongoDB 介绍"></a>MongoDB 介绍</h1><blockquote><p>一个面向文档对象的数据库。</p></blockquote><p>MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写。旨在为 WEB 应用提供可扩展的高性能数据存储解决方案。</p><p>MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。</p><h1 id="管理-MongoDB"><a href="#管理-MongoDB" class="headerlink" title="管理 MongoDB"></a>管理 MongoDB</h1><h2 id="安装-MongoDB"><a href="#安装-MongoDB" class="headerlink" title="安装 MongoDB"></a>安装 MongoDB</h2><p>首先确保你的包是最新的：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br></pre></td></tr></table></figure><p>然后安装 MongoDB：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install mongodb</span><br></pre></td></tr></table></figure><p>检查 mongodb 服务的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status mongodb</span><br></pre></td></tr></table></figure><p><img src="https://s2.loli.net/2022/04/13/YX7SqhNajgwHuZv.png"></p><p>可以看到，服务正常启动了。</p><h2 id="管理-MongoDB-1"><a href="#管理-MongoDB-1" class="headerlink" title="管理 MongoDB"></a>管理 MongoDB</h2><h3 id="服务状态管理"><a href="#服务状态管理" class="headerlink" title="服务状态管理"></a>服务状态管理</h3><p>MongoDB 目前是一个 <code>systemd</code> 服务，因此我们使用 <code>systemctl</code> 来检查和修改它的状态，使用以下命令：</p><ul><li>查看运行状态：<code>sudo systemctl status mongodb</code></li><li>停止服务状态：<code>sudo systemctl stop mongodb</code></li><li>启动服务状态：<code>sudo systemctl start mongodb</code></li><li>重启服务状态：<code>sudo systemctl restart mongodb</code></li><li>启用开机自启动：<code>sudo systemctl enable mongodb</code></li><li>禁用开机自启动：<code>sudo systemctl disable mongodb</code></li></ul><h3 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理"></a>配置管理</h3><ul><li>查看配置文件：<code>sudo nano /etc/mongodb.conf</code></li></ul><h3 id="日志管理"><a href="#日志管理" class="headerlink" title="日志管理"></a>日志管理</h3><ul><li>查看日志：<code>sudo journalctl -u mongodb</code></li><li>查看错误日志：<code>sudo journalctl -u mongodb --no-pager -n 100 -f | grep -i error</code></li><li>查看警告日志：<code>sudo journalctl -u mongodb --no-pager -n 100 -f | grep -i warning</code></li><li>查看提示日志：<code>sudo journalctl -u mongodb --no-pager -n 100 -f | grep -i notice</code></li></ul><h3 id="卸载-MongoDB"><a href="#卸载-MongoDB" class="headerlink" title="卸载 MongoDB"></a>卸载 MongoDB</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl stop mongodb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt purge mongodb</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo apt autoremove</span></span><br></pre></td></tr></table></figure><h2 id="远程管理-MongoDB"><a href="#远程管理-MongoDB" class="headerlink" title="远程管理 MongoDB"></a>远程管理 MongoDB</h2><p>默认无法远程访问 MongoDB，我们需要先在服务器安全组中开放 <code>27017</code> 端口，然后再进行配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo /etc/mongodb.conf</span></span><br></pre></td></tr></table></figure><p>修改  <code>bind_ip = 0.0.0.0</code> 为 <code>bind_ip = 0.0.0.0</code>，然后重启服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo systemctl restart mongodb</span></span><br></pre></td></tr></table></figure><p>安装 <a href="https://studio3t.com/free">Studio 3T for Free</a>，然后连接：</p><p><img src="https://s2.loli.net/2022/04/13/tUBEgnVpSAc715F.png"></p><h2 id="安全管理"><a href="#安全管理" class="headerlink" title="安全管理"></a>安全管理</h2><p>默认我们不需要认证即可连接 MongoDB，这是很危险的，我们需要设置一个管理员用户来认证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mongo</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">use admin</span></span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db.createUser(&#123;user:<span class="string">&quot;admin&quot;</span>, <span class="built_in">pwd</span>:<span class="string">&quot;123456&quot;</span>, roles:[&#123;role:<span class="string">&quot;userAdminAnyDatabase&quot;</span>, db:<span class="string">&quot;admin&quot;</span>&#125;]&#125;)</span></span><br></pre></td></tr></table></figure><p>然后配置 MongoDB 的安全策略：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">sudo nano /etc/mongodb.conf</span></span><br></pre></td></tr></table></figure><p>将 <code>security.authorization = enabled</code> 写入文件，然后重启服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mongodb</span><br></pre></td></tr></table></figure><p>在 Studio 3T 中配置用户名密码即可，需要注意的是 Authentication DB 需要填写对应的。</p><p><img src="https://s2.loli.net/2022/04/13/fLhd9t1sZ8KTaRA.png"></p><p>更多安全知识参考 <a href="https://help.aliyun.com/document_detail/112035.html">MongoDB数据库未授权访问漏洞防御最佳实践</a></p><h1 id="MongoDB-概念"><a href="#MongoDB-概念" class="headerlink" title="MongoDB 概念"></a>MongoDB 概念</h1><ul><li>database：数据库，是 MongoDB 的核心，用来存储数据，每个数据库都有自己的集合，集合中存储的是数据。</li><li>collection：集合，相当于关系型数据库中的表（table）</li><li>document：文档，相当于关系型数据库中的行（row）</li><li>field：字段，相当于关系型数据库中的列（column）</li><li>index：索引，相当于关系型数据库中的索引</li><li>primary key：主键，相当于关系型数据库中的主键，MongoDB 中主键的名称默认为 <code>_id</code></li></ul><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>一个 mongodb 中可以建立多个数据库。 MongoDB 的默认数据库为 <code>db</code>，该数据库存储在 data 目录中。</p><p>MongoDB 的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限，不同的数据库也防止在不同的文件中。</p><p><code>show dbs</code> 命令可以显示所有数据的列表。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">mongo</span></span><br><span class="line">MongoDB shell version v3.6.3</span><br><span class="line">connecting to: mongodb://127.0.0.1:27017</span><br><span class="line">MongoDB server version: 3.6.3</span><br><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">show dbs</span></span><br><span class="line">admin   0.000GB</span><br><span class="line">config  0.000GB</span><br><span class="line">local   0.000GB</span><br></pre></td></tr></table></figure><p>运行 <code>use</code> 命令可以切换数据库，如果不存在则会自动创建。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">use <span class="built_in">test</span></span></span><br><span class="line">switched to db test</span><br></pre></td></tr></table></figure><p>执行 <code>db</code> 命令可以显示当前数据库对象或集合。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt; </span><span class="language-bash">db</span></span><br><span class="line">test</span><br></pre></td></tr></table></figure><h3 id="数据库命名规范"><a href="#数据库命名规范" class="headerlink" title="数据库命名规范"></a>数据库命名规范</h3><ul><li>不能是空字符</li><li>不能含有 <code>&#39; &#39;</code>（空格）、<code>.</code>、<code>/</code>、<code>\</code> 和 <code>\0</code>（空字符）</li><li>应全部小写</li><li>最多 64 字节</li></ul><h3 id="默认数据库"><a href="#默认数据库" class="headerlink" title="默认数据库"></a>默认数据库</h3><ul><li>admin：从权限的角度来看，这是 root 数据库。要是将一个用户添加到这个数据库，这个用户自动继承所有数据库的权限。一些特定的服务器端命令也只能从这个数据库运行，比如列出所有的数据库或者关闭服务器。</li><li>local：这个数据永远不会被复制，可以用来存储限于本地单台服务器的任意集合。</li><li>config：当 Mongo 用于分片设置时，config 数据库在内部使用，用于保存分片的相关信息。</li></ul><h1 id="连接-MongoDB"><a href="#连接-MongoDB" class="headerlink" title="连接 MongoDB"></a>连接 MongoDB</h1><p>标准 URI 连接语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]</span><br></pre></td></tr></table></figure><ul><li><code>mongodb://</code>：这是固定的格式，必须指定</li><li><code>username:password@</code>：可选项，如果设置，在连接数据库服务器之后，驱动都会尝试登录这个数据库</li><li><code>host1</code>：必须的，指定至少一个 host，host1 是这个 URI 唯一要填写的。它指定了要连接服务器的地址。如果要连接复制集，请指定多个主机地址。</li><li><code>portX</code>：可选的指定端口，如果不填，默认为 27017</li><li><code>/database</code>：如果指定 <code>username:password@</code>，连接并验证登录指定数据库。若不指定，默认打开 test 数据库。</li><li><code>?options</code>：是连接选项。如果不使用 <code>/database</code>，则前面需要加上 <code>/</code>。所有连接选项都是键值对 <code>name=value</code>，键值对之间通过 <code>&amp;</code> 或 <code>;</code> 隔开</li></ul><h2 id="nodejs"><a href="#nodejs" class="headerlink" title="nodejs"></a>nodejs</h2><h3 id="安装驱动"><a href="#安装驱动" class="headerlink" title="安装驱动"></a>安装驱动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">yarn add mongodb</span></span><br></pre></td></tr></table></figure><h3 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h3><p>要在 MongoDB 中创建一个数据库，首先我们需要创建一个 MongoClient 对象，然后配置好指定的 URL 和端口号。</p><p>如果数据库不存在，MongoDB 将创建数据库并建立连接。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MongoClient</span> = <span class="built_in">require</span>(<span class="string">&#x27;mongodb&#x27;</span>).<span class="property">MongoClient</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;mongodb://localhost:27017/luozhu&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url, <span class="keyword">function</span>(<span class="params">err, db</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;数据库已创建！&quot;</span>);</span><br><span class="line">  db.<span class="title function_">close</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="创建集合"><a href="#创建集合" class="headerlink" title="创建集合"></a>创建集合</h3><p>我们可以使用 <code>createCollection()</code> 方法来创建一个集合，这个集合可以是空的，也可以包含数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MongoClient</span> = <span class="built_in">require</span>(<span class="string">&#x27;mongodb&#x27;</span>).<span class="property">MongoClient</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;mongodb://localhost:27017/luozhu&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url, <span class="keyword">function</span>(<span class="params">err, db</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">var</span> dbo = db.<span class="title function_">db</span>(<span class="string">&quot;luozhu&quot;</span>);</span><br><span class="line">  dbo.<span class="title function_">createCollection</span>(<span class="string">&quot;site&quot;</span>, <span class="keyword">function</span>(<span class="params">err, res</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;集合已创建！&quot;</span>);</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><p>以下实例我们连接数据库 luozhu 的 site 表，并插入一条数据。使用 <code>insertOne()</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MongoClient</span> = <span class="built_in">require</span>(<span class="string">&#x27;mongodb&#x27;</span>).<span class="property">MongoClient</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;mongodb://localhost:27017/luozhu&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url, <span class="keyword">function</span>(<span class="params">err, db</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="keyword">var</span> dbo = db.<span class="title function_">db</span>(<span class="string">&quot;luozhu&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> myobj = &#123; <span class="attr">name</span>: <span class="string">&quot;Google&quot;</span>, <span class="attr">address</span>: <span class="string">&quot;https://google.com&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">  dbo.<span class="title function_">collection</span>(<span class="string">&quot;site&quot;</span>).<span class="title function_">insertOne</span>(myobj, <span class="keyword">function</span>(<span class="params">err, res</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;文档插入成功&quot;</span>);</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果要插入多条数据，可以使用 <code>insertMany()</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MongoClient</span> = <span class="built_in">require</span>(<span class="string">&quot;mongodb&quot;</span>).<span class="property">MongoClient</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;mongodb://localhost:27017/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url, <span class="keyword">function</span>(<span class="params">err, db</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  <span class="keyword">var</span> dbo = db.<span class="title function_">db</span>(<span class="string">&quot;luozhu&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> myobj = [</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Facebook&#x27;</span>, <span class="attr">website</span>: <span class="string">&#x27;https://www.facebook.com/&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">name</span>: <span class="string">&#x27;Github&#x27;</span>, <span class="attr">website</span>: <span class="string">&#x27;https://github.com&#x27;</span>&#125;</span><br><span class="line">  ]</span><br><span class="line">  dbo.<span class="title function_">collection</span>(<span class="string">&quot;site&quot;</span>).<span class="title function_">insertMany</span>(myobj, <span class="keyword">function</span>(<span class="params">err, res</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;文档插入成功&quot;</span>, res.<span class="property">insertedCount</span>);</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="查询所有数据"><a href="#查询所有数据" class="headerlink" title="查询所有数据"></a>查询所有数据</h4><p>可以使用 <code>find()</code> 来查找数据。<code>find()</code> 可以返回符合条件的所有数据。如果未指定条件，<code>find()</code> 返回集合中的所有数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MongoClient</span> = <span class="built_in">require</span>(<span class="string">&quot;mongodb&quot;</span>).<span class="property">MongoClient</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;mongodb://localhost:27017/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url, <span class="keyword">function</span>(<span class="params">err, db</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  <span class="keyword">var</span> dbo = db.<span class="title function_">db</span>(<span class="string">&quot;luozhu&quot;</span>);</span><br><span class="line"></span><br><span class="line">  dbo.<span class="title function_">collection</span>(<span class="string">&quot;site&quot;</span>).<span class="title function_">find</span>(&#123;&#125;).<span class="title function_">toArray</span>(<span class="keyword">function</span>(<span class="params">err, result</span>) &#123; <span class="comment">// 返回集合中所有数据</span></span><br><span class="line">    <span class="keyword">if</span>(err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="查询指定条件的数据"><a href="#查询指定条件的数据" class="headerlink" title="查询指定条件的数据"></a>查询指定条件的数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MongoClient</span> = <span class="built_in">require</span>(<span class="string">&quot;mongodb&quot;</span>).<span class="property">MongoClient</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;mongodb://localhost:27017/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url, <span class="keyword">function</span>(<span class="params">err, db</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  <span class="keyword">var</span> dbo = db.<span class="title function_">db</span>(<span class="string">&quot;luozhu&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> whereStr = &#123;<span class="string">&quot;name&quot;</span>:<span class="string">&#x27;Github&#x27;</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">  dbo.<span class="title function_">collection</span>(<span class="string">&quot;site&quot;</span>).<span class="title function_">find</span>(whereStr).<span class="title function_">toArray</span>(<span class="keyword">function</span>(<span class="params">err, result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(result);</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><h4 id="更新一条文档"><a href="#更新一条文档" class="headerlink" title="更新一条文档"></a>更新一条文档</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MongoClient</span> = <span class="built_in">require</span>(<span class="string">&quot;mongodb&quot;</span>).<span class="property">MongoClient</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;mongodb://localhost:27017/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url, <span class="keyword">function</span>(<span class="params">err, db</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  <span class="keyword">var</span> dbo = db.<span class="title function_">db</span>(<span class="string">&quot;luozhu&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> whereStr = &#123; <span class="string">&quot;name&quot;</span>: <span class="string">&#x27;Github&#x27;</span> &#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">  <span class="keyword">var</span> updateStr = &#123; <span class="attr">$set</span>:&#123; <span class="string">&quot;website&quot;</span>: <span class="string">&quot;https://github.com/youngjuning&quot;</span> &#125;&#125;;  <span class="comment">// 更新内容</span></span><br><span class="line">  dbo.<span class="title function_">collection</span>(<span class="string">&quot;site&quot;</span>).<span class="title function_">updateOne</span>(whereStr, updateStr, <span class="keyword">function</span> (<span class="params">err, res</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;文档更新成功&quot;</span>, res.<span class="property">matchedCount</span>);</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行成功后，进入 mongo 管理工具查看数据已修改：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; db.site.find(&#123; name: <span class="string">&quot;GitHub&quot;</span> &#125;).<span class="function"><span class="title">pretty</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;_id&quot;</span> : ObjectId(<span class="string">&quot;5a794e36763eb821b24db854&quot;</span>),</span><br><span class="line">    <span class="string">&quot;name&quot;</span> : <span class="string">&quot;Github&quot;</span>,</span><br><span class="line">    <span class="string">&quot;url&quot;</span> : <span class="string">&quot;https://www.github.com&quot;</span>     <span class="comment"># 已修改为 https</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更新多条文档"><a href="#更新多条文档" class="headerlink" title="更新多条文档"></a>更新多条文档</h4><p>如果要跟新所有符合条件的文档数据，可以使用 <code>updateMany()</code> 。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MongoClient</span> = <span class="built_in">require</span>(<span class="string">&#x27;mongodb&#x27;</span>).<span class="property">MongoClient</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;mongodb://localhost:27018/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url, <span class="function">(<span class="params">err, db</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  <span class="keyword">var</span> dbo = db.<span class="title function_">db</span>(<span class="string">&quot;luozhu&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> whereStr = &#123;<span class="string">&quot;country&quot;</span>: <span class="string">&#x27;us&#x27;</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">  <span class="keyword">var</span> updateStr = &#123;<span class="attr">$set</span>: &#123; <span class="string">&quot;country&quot;</span> : <span class="string">&quot;American&quot;</span> &#125;&#125;;</span><br><span class="line">  dbo.<span class="title function_">collection</span>(<span class="string">&quot;site&quot;</span>).<span class="title function_">updateMany</span>(whereStr, updateStr, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">modifiedCount</span> + <span class="string">&quot; 条文档被更新&quot;</span>);</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>res.modifiedCount</code> 属性返回修改的文档数量。</p><h3 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h3><h4 id="删除一条数据"><a href="#删除一条数据" class="headerlink" title="删除一条数据"></a>删除一条数据</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MongoClient</span> = <span class="built_in">require</span>(<span class="string">&#x27;mongodb&#x27;</span>).<span class="property">MongoClient</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;mongodb://localhost:27018/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url, <span class="function">(<span class="params">err, db</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span>(err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  <span class="keyword">var</span> dbo = db.<span class="title function_">db</span>(<span class="string">&quot;luozhu&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> whereStr = &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&#x27;Github&#x27;</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">  dbo.<span class="title function_">collection</span>(<span class="string">&quot;site&quot;</span>).<span class="title function_">deleteOne</span>(whereStr, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">deletedCount</span> + <span class="string">&quot; 条文档被删除&quot;</span>);</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="删除多条数据"><a href="#删除多条数据" class="headerlink" title="删除多条数据"></a>删除多条数据</h4><p>如果要删除多条语句可以使用 <code>deleteMany()</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">MongoClient</span> = <span class="built_in">require</span>(<span class="string">&#x27;mongodb&#x27;</span>).<span class="property">MongoClient</span>;</span><br><span class="line"><span class="keyword">var</span> url = <span class="string">&quot;mongodb://localhost:27018/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">MongoClient</span>.<span class="title function_">connect</span>(url, <span class="keyword">function</span>(<span class="params">err, db</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">  <span class="keyword">var</span> dbo = db.<span class="title function_">db</span>(<span class="string">&quot;luozhu&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> whereStr = &#123;<span class="attr">country</span>: <span class="string">&quot;American&quot;</span>&#125;;  <span class="comment">// 查询条件</span></span><br><span class="line">  dbo.<span class="title function_">collection</span>(<span class="string">&quot;site&quot;</span>).<span class="title function_">deleteMany</span>(whereStr, <span class="function">(<span class="params">err, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err) <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res.<span class="property">deletedCount</span>, <span class="string">&quot;条文档被删除&quot;</span>);</span><br><span class="line">    db.<span class="title function_">close</span>();</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>res.deletedCount</code> 属性返回删除的文档数量。</p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://zhuanlan.zhihu.com/p/76349679">如何在 Ubuntu 上安装 MongoDB</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;MongoDB-介绍&quot;&gt;&lt;a href=&quot;#MongoDB-介绍&quot; class=&quot;headerlink&quot; title=&quot;MongoDB 介绍&quot;&gt;&lt;/a&gt;MongoDB 介绍&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;一个面向文档对象的数据库。&lt;/p&gt;
&lt;/block</summary>
      
    
    
    
    <category term="全栈" scheme="https://youngjuning.js.org/categories/%E5%85%A8%E6%A0%88/"/>
    
    
    <category term="MongoDB" scheme="https://youngjuning.js.org/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>code-server 尝鲜</title>
    <link href="https://youngjuning.js.org/dfd0faf39738/"/>
    <id>https://youngjuning.js.org/dfd0faf39738/</id>
    <published>2022-03-19T10:00:00.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="WebIDE-概述"><a href="#WebIDE-概述" class="headerlink" title="WebIDE 概述"></a>WebIDE 概述</h1><h2 id="WebIDE-介绍"><a href="#WebIDE-介绍" class="headerlink" title="WebIDE 介绍"></a>WebIDE 介绍</h2><p>WebIDE 是基于 H5 支持多语言的在线集成开发环境。相较于传统的本地 IDE，WebIDE 是开箱即用的，你不用配置 git 环境、node 环境、react 环境甚至 React Native 环境。</p><h2 id="WebIDE-发展与现状"><a href="#WebIDE-发展与现状" class="headerlink" title="WebIDE 发展与现状"></a>WebIDE 发展与现状</h2><ul><li>基于 <a href="https://codemirror.net/">CodeMirror</a> 和 <a href="https://ace.c9.io/">Ace</a> 实现编辑器部分，其余部分自己实现</li><li>以 <a href="https://codesandbox.io/">CodeSandbox</a> 为代表的的在线代码编辑器服务，私有部署较麻烦</li><li><a href="https://gitlab.com/youngjuning/react">Gitlab ide</a>：集成在 Gitlab 中的 IDE</li><li><a href="https://github.com/facebook/react/">Github ide</a>：基于 vscode 实现的与 github 结合的 IDE，限制是命令行使用有限制，</li><li><a href="https://codingcorp.cloudstudio.net/ws/qmbngm">Cloud Studio</a>：可以理解为国产 CodeSandbox，以前是基于 Ace 做的，现在也改成了基于 vscode，自定义功能通过 vscode 的插件体系来做</li></ul><p>通过比对市场上常见的 WebIDE 产品，我们能发现趋势都趋于统一了，就是依托 vscode 强大的能力来实现的，扩展能力也是基于 vscode 来实现。</p><h2 id="WebIDE-通用架构"><a href="#WebIDE-通用架构" class="headerlink" title="WebIDE 通用架构"></a>WebIDE 通用架构</h2><p><img src="https://s2.loli.net/2022/03/23/UfjaX4QpTmg5MKu.png"></p><h2 id="WebIDE-的优势"><a href="#WebIDE-的优势" class="headerlink" title="WebIDE 的优势"></a>WebIDE 的优势</h2><ul><li>在具有一致开发环境的任何设备上编写代码</li><li>使用云服务器加速测试、编译、下载等来节省旅途中的笔记本电量</li><li>所有密集型任务都在您的服务器上运行，节省笔记本内存</li></ul><h2 id="工程化意义"><a href="#工程化意义" class="headerlink" title="工程化意义"></a>工程化意义</h2><ul><li>安全性：服务部署在内网，完全不用担心安全问题，且插件服务也可以内网部署。</li><li>规范性：通过定制编辑器，我们可以规范开发阶段的流程与环境</li><li>提效性：通过实时预览技术，可以实现开发阶段通过 mock 数据即可预览面板。另外由于是针对 OS 业务定制，所以开发套件都是定制好的，开发只需要关心代码</li><li>平台化：可以和内部任何平台打通交互，比如一键打包、一键发布</li></ul><h1 id="基于-code-server-搭建-WebIDE-平台"><a href="#基于-code-server-搭建-WebIDE-平台" class="headerlink" title="基于 code-server 搭建 WebIDE 平台"></a>基于 code-server 搭建 WebIDE 平台</h1><p>code-server 是一个免费的基于浏览器的 IDE，它是基于 vscode 封装的跨平台 IDE。</p><h2 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h2><h3 id="安装-nodejs"><a href="#安装-nodejs" class="headerlink" title="安装 nodejs"></a>安装 nodejs</h3><p><strong>安装源</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https://deb.nodesource.com/setup_14.x | sudo -E bash -</span><br></pre></td></tr></table></figure><p><strong>安装 nodejs</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure><p><strong>更新 npm</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g npm</span><br></pre></td></tr></table></figure><h3 id="安装-code-server"><a href="#安装-code-server" class="headerlink" title="安装 code-server"></a>安装 code-server</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://code-server.dev/install.sh | sh</span><br></pre></td></tr></table></figure><p>执行下面的命令以支持 systemd 方式启动并开始开机自启动：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> --now code-server@<span class="variable">$USER</span></span><br></pre></td></tr></table></figure><p>之后如果修改了配置文件，就可以使用 <code>sudo systemctl restart code-server@$USER</code> 重启服务。</p><p>或者你不需要后台服务，你可以执行下面的命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">code-server</span><br></pre></td></tr></table></figure><h3 id="nginx-反向代理"><a href="#nginx-反向代理" class="headerlink" title="nginx 反向代理"></a>nginx 反向代理</h3><p>安装 nginx：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y nginx</span><br></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen 80;</span><br><span class="line">    listen [::]:80;</span><br><span class="line">    server_name mydomain.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">      proxy_pass http://localhost:8080/;</span><br><span class="line">      proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">      proxy_set_header Upgrade <span class="variable">$http_upgrade</span>;</span><br><span class="line">      proxy_set_header Connection upgrade;</span><br><span class="line">      proxy_set_header Accept-Encoding gzip;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><ul><li><a href="https://www.zhihu.com/question/41050429">要实现一个Web IDE 需要哪些前端技术？</a></li><li><a href="https://developer.aliyun.com/article/646273">WebIDE 使用指南 - 阿里云</a></li><li><a href="https://docs.gitlab.com/ee/user/project/web_ide/">网络IDE - GitLab</a></li><li><a href="https://www.youtube.com/watch?v=lfYo4mfOyM8">What is CodeSandbox</a></li><li><a href="https://juejin.cn/post/7008428269317914661">如何在团队快速落地 WebIDE</a></li><li><a href="https://learnku.com/articles/42581">Ubuntu 安装最新版本 Node.js</a></li><li><a href="https://www.jianshu.com/p/648c48f146c6">腾讯云登录Root用户</a></li><li><a href="https://youngjuning.js.org/21bdf0b4bd15/">写给前端的Linux实战教程</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;WebIDE-概述&quot;&gt;&lt;a href=&quot;#WebIDE-概述&quot; class=&quot;headerlink&quot; title=&quot;WebIDE 概述&quot;&gt;&lt;/a&gt;WebIDE 概述&lt;/h1&gt;&lt;h2 id=&quot;WebIDE-介绍&quot;&gt;&lt;a href=&quot;#WebIDE-介绍&quot; class</summary>
      
    
    
    
    <category term="前端" scheme="https://youngjuning.js.org/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
    <category term="vscode" scheme="https://youngjuning.js.org/tags/vscode/"/>
    
    <category term="ide" scheme="https://youngjuning.js.org/tags/ide/"/>
    
    <category term="code-sever" scheme="https://youngjuning.js.org/tags/code-sever/"/>
    
  </entry>
  
  <entry>
    <title>使用 MetaMask 连接到币安智能链(BSC)</title>
    <link href="https://youngjuning.js.org/5cb0c0ce25b8/"/>
    <id>https://youngjuning.js.org/5cb0c0ce25b8/</id>
    <published>2021-12-30T02:36:17.000Z</published>
    <updated>2023-03-07T10:29:44.644Z</updated>
    
    <content type="html"><![CDATA[<p>币安智能链是目前世界上最大的以太坊交易所，MetaMask 则是专注服务于以太坊的钱包应用。</p><h2 id="入口"><a href="#入口" class="headerlink" title="入口"></a>入口</h2><p><img src="https://cdn.jsdelivr.net/gh/youngjuning/images/202112301451827.png"></p><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul><li>网络名称: <code>币安智能链</code></li><li>RPC URL: <code>https://bsc-dataseed1.binance.org/</code></li><li>链 ID: <code>56</code></li><li>Currency Symbol: <code>WBNB</code></li><li>区块浏览器: <code>https://bscscan.com/</code></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://academy.binance.com/zh/articles/connecting-metamask-to-binance-smart-chain">在币安智能链中关联MetaMask钱包</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;币安智能链是目前世界上最大的以太坊交易所，MetaMask 则是专注服务于以太坊的钱包应用。&lt;/p&gt;
&lt;h2 id=&quot;入口&quot;&gt;&lt;a href=&quot;#入口&quot; class=&quot;headerlink&quot; title=&quot;入口&quot;&gt;&lt;/a&gt;入口&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https:</summary>
      
    
    
    
    <category term="区块链" scheme="https://youngjuning.js.org/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="MetaMask" scheme="https://youngjuning.js.org/tags/MetaMask/"/>
    
  </entry>
  
</feed>
