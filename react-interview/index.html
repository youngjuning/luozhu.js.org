<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>2023 React 面试题与答案 | 紫竹的博客</title><meta name="author" content="紫竹"><meta name="copyright" content="紫竹"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="前 500 个 ReactJS 面试必知必会问题与答案，是紫竹诚意翻译的前端 React 面试必备系列。">
<meta property="og:type" content="website">
<meta property="og:title" content="2023 React 面试题与答案">
<meta property="og:url" content="https://youngjuning.js.org/react-interview/">
<meta property="og:site_name" content="紫竹的博客">
<meta property="og:description" content="前 500 个 ReactJS 面试必知必会问题与答案，是紫竹诚意翻译的前端 React 面试必备系列。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://s2.loli.net/2023/07/17/eS6iXfpscLyUhVC.png">
<meta property="article:published_time" content="2023-03-06T11:30:00.000Z">
<meta property="article:modified_time" content="2023-09-12T14:49:20.935Z">
<meta property="article:author" content="紫竹">
<meta property="article:tag" content="React.js 面试题">
<meta property="article:tag" content="React 面试题">
<meta property="article:tag" content="React 面试">
<meta property="article:tag" content="React 面试题与答案">
<meta property="article:tag" content="前端面试">
<meta property="article:tag" content="前端面试题">
<meta property="article:tag" content="React 教程">
<meta property="article:tag" content="React.js 教程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pbs.twimg.com/profile_images/1628559000953565186/HVtTFoKv_x96.jpg">
<meta name="twitter:creator" content="@luozhu2021">
<meta name="twitter:site" content="https://twitter.com/luozhu2021"><link rel="shortcut icon" href="https://s2.loli.net/2023/07/17/K91TsgdoRabMtvw.png"><link rel="canonical" href="https://youngjuning.js.org/react-interview/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="ohZ0A8YKJu755suq7WOIJkLGDfj3BGU4isb8RKI5Cj8"/><meta name="baidu-site-verification" content="codeva-seFAiiGXVd"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle = window.adsbygoogle || []).push({
  google_ad_client: 'ca-pub-7962287588031867',
  enable_page_level_ads: 'true'
});</script><script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-M7KEMBRVPJ"></script><script>window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', 'G-M7KEMBRVPJ');
</script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":-1,"unescape":true,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":400},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":80,"languages":{"author":"作者: 紫竹","link":"链接: ","source":"来源: 紫竹的博客","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#59C173","bgDark":"#1f1f1f","position":"bottom-left"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '2023 React 面试题与答案',
  isPost: false,
  isHome: false,
  isHighlightShrink: false,
  isToc: false,
  postUpdate: '2023-09-12 22:49:20'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/custom.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="紫竹的博客" type="application/atom+xml">
<link rel="alternate" href="/rss2.xml" title="紫竹的博客" type="application/rss+xml">
</head><body><script>window.paceOptions = {
  restartOnPushState: false
}

document.addEventListener('pjax:send', () => {
  Pace.restart()
})
</script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/pace-js/themes/blue/pace-theme-minimal.min.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/07/17/K91TsgdoRabMtvw.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">160</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">523</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">57</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-fw fas fa-lines-leaning"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fas fa-random"></i><span> 逛逛</span></a></div><div class="menus_item"><a class="site-page" href="/stack/"><i class="fa-fw fas fa-location-arrow"></i><span> 导航</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://travellings.vercel.app/"><i class="fa-fw fas fa-paper-plane"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heart"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/album/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-spa"></i><span> 关于</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></li></ul></div></div></div></div><div class="page" id="body-wrap"><header class="not-home-page" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/youngjuning/images@main/1681097427413.png')"><nav id="nav"><span id="blog-info"><a href="/" title="紫竹的博客"><img class="site-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/07/17/K91TsgdoRabMtvw.png"/><span class="site-name">紫竹的博客</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fa-fw fas fa-lines-leaning"></i><span> 文章</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fas fa-random"></i><span> 逛逛</span></a></div><div class="menus_item"><a class="site-page" href="/stack/"><i class="fa-fw fas fa-location-arrow"></i><span> 导航</span></a></div><div class="menus_item"><a class="site-page" target="_blank" rel="noopener external nofollow noreferrer" href="https://travellings.vercel.app/"><i class="fa-fw fas fa-paper-plane"></i><span> 开往</span></a></div><div class="menus_item"><a class="site-page" href="/friends/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-heart"></i><span> 我的</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/album/"><i class="fa-fw fas fa-images"></i><span> 相册</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-spa"></i><span> 关于</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i><span> 阅读</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="page-site-info"><h1 id="site-title">2023 React 面试题与答案</h1></div></header><main class="layout" id="content-inner"><div id="page"><div id="article-container"><details class="folding-tag" green><summary> 1. 什么是 React？ </summary>
              <div class='content'>
              <p>React 是一个<strong>开源前端 JavaScript 库</strong>，用于构建用户界面，尤其是单页应用程序。它用于处理 Web 和移动应用程序的视图层。React 是由 Facebook 的软件工程师 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jordwalke">乔丹·沃克</a> 创建的。React 于 2011 年在 Facebook 的 News Feed 上首次发布，2012 年首次在 Instagram 发布。</p>
              </div>
            </details>

<details class="folding-tag" green><summary> 2. React 的主要特性是什么？ </summary>
              <div class='content'>
              <p>React 的主要特性是:</p><ul><li>考虑到 DOM 操作内存开销大，React 使用<strong>虚拟 DOM（VirtualDOM）</strong> 替代了真实 DOM（RealDOM）</li><li>支持<strong>服务端渲染</strong></li><li>遵循<strong>单向</strong>数据流或数据绑定</li><li>使用<strong>可复用&#x2F;可组合</strong>的 UI 组件来进行视图开发</li></ul>
              </div>
            </details>

<details class="folding-tag" green><summary> 3. 什么是 JSX？ </summary>
              <div class='content'>
              <p>JSX 是 ECMAScript 的类似 XML 的语法扩展（缩写是 JavaScript XML）。实际上，它只是为 <code>React.createElement()</code> 函数提供语法糖，为我们提供了在 JavaScript 中使用类 HTML 模板语法的能力。</p><p>下面的示例中，<code>&lt;h1&gt;</code> 标签内的文本会作为 JavaScript 函数（<code>React.createElement()</code>）的返回值返回给 render 函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#x27;Welcome to React world!&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" green><summary> 4. 元素（Element）和组件（Component）的区别是什么？ </summary>
              <div class='content'>
              <p>元素是一个普通的对象，它描述了你希望以 DOM 节点或其他组件的形式出现在屏幕上的内容。元素可以在其 props 中包含其他 元素。创建一个 React 元素开销很小。一旦创建了元素，就永远不会对其进行修改。</p><p>React Element 的对象表示如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;login-btn&#x27;</span> &#125;, <span class="string">&#x27;Login&#x27;</span>);</span><br></pre></td></tr></table></figure><p>上面的 <code>React.createElement()</code> 函数会返回一个如下的对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&#x27;Login&#x27;</span>,</span><br><span class="line">    <span class="attr">id</span>: <span class="string">&#x27;login-btn&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终，它会使用 <code>ReactDOM.render()</code> 将元素渲染到 DOM：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;login-btn&quot;</span>&gt;</span>Login<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而<strong>组件</strong>可以用几种不同的方式声明。它可以是带有 <code>render()</code> 方法的类。或者，你可以简单地将其定义为一个函数。无论哪种情况，它都将 props 作为输入，并返回 JSX 树作为输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">&#123; onLogin &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">login-btn</span>&#x27;&#125; <span class="attr">onClick</span>=<span class="string">&#123;onLogin&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    Login</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>然后将 JSX 编译成 <code>React.createElement()</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">Button</span> = (<span class="params">&#123; onLogin &#125;</span>) =&gt;</span><br><span class="line">  <span class="title class_">React</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;login-btn&#x27;</span>, <span class="attr">onClick</span>: onLogin &#125;, <span class="string">&#x27;Login&#x27;</span>);</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" green><summary> 5. 如何在 React 中创建组件？ </summary>
              <div class='content'>
              <p>这里有两种可以用方式来创建一个组件：</p><ol><li><strong>函数组件：</strong> 这是创建组件最简单的方式。它们是纯 JavaScript 函数，接受 props 对象作为第一个参数并返回 React 元素：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Greeting</span>(<span class="params">&#123; message &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Hello, $&#123;message&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>类组件：</strong> 你也可以使用 ES6 的 class 语法来定义一个组件。上面的函数组件可以被改写为：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Greeting</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Hello, $&#123;this.props.message&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" green><summary> 6. 何时选择类组件或函数组件 </summary>
              <div class='content'>
              <p>如果一个组件需要状态或者生命周期方法，则使用类组件，否则使用函数组件。</p><p>然而，从 React 16.8 引入 Hooks 后，你可以在函数组件中使用之前只在类组件中有的特性，比如状态和生命周期方法。</p>
              </div>
            </details>

<details class="folding-tag" green><summary> 7. Pure Components 是什么？ </summary>
              <div class='content'>
              <p><code>React.PureComponent</code> 与 <code>React.Component</code> 几乎完全相同，不同之处在于它为你处理了 <code>shouldComponentUpdate()</code> 方法。当 props 和 state 改变时，PureComponent 将对 props 和 state 进行浅表比较。另一方面，Component 初始不会将当前 props 和 state 与 nextPorps 和 nextState 进行比较。因此，每当调用 <code>shouldComponentUpdate</code> 时，组件将默认重新渲染。</p>
              </div>
            </details>

<details class="folding-tag" green><summary> 8. React 中的 state 是什么？ </summary>
              <div class='content'>
              <p>组件的状态是一个对象，其中包含一些在组件的生命周期中可能会发生变化的信息。我们应该始终尝试使状态尽可能简单，并最大程度减少有状态组件的数量。</p><p>让我们来创建一个带有 message 状态的 user 组件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&#x27;Welcome to React world&#x27;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;this.state.message&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/8472c6438dfe48068002c5fdf1fbf098~tplv-k3u1fbpfcp-zoom-1.image" alt="state"></p><p>状态类似于 Props，但它是私有的，并由组件完全控制。也就是说除了拥有和设置它的组件之外，其他任何组件都无法访问它。</p>
              </div>
            </details>

<details class="folding-tag" green><summary> 9. React 中的 props 是什么 </summary>
              <div class='content'>
              <p>Props 是组件的输入。它们是单个值或包含一组值的对象，这些对象在创建时会使用类似于 HTML 标签属性的命名约定传递给组件。它们是从父组件传递到子组件的数据。</p><p>React 中 props 的主要目的是提供以下组件功能：</p><ol><li>将自定义数据传递到你的组件。</li><li>触发状态更改。</li><li>通过组件的 <code>render()</code> 方法中的 <code>this.props.reactProp</code> 使用。</li></ol><p>举个例子，让我们创建一个带有 <code>reactProp</code> 属性的元素：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">Element</span> reactProp=&#123;<span class="string">&#x27;1&#x27;</span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>然后，这个 <code>reactProp</code>（或你想出的任何名称）成为附加到 React 的本地 props 对象的属性，该对象最初已经存在于使用 React 库创建的所有组件上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.<span class="property">reactProp</span>;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" green><summary> 10. state 和 props 的区别是什么？ </summary>
              <div class='content'>
              <p>props 和 state 都是普通的 JavaScript 对象。尽管它们两者都拥有影响渲染输出的信息，但它们在组件层面的功能却有所不同。将 props 传递给组件类似于传递参数给函数，而 state 则类似于函数中声明的变量一样在组件内进行管理。</p>
              </div>
            </details>

<details class="folding-tag" green><summary> 11. 为什么我们不能直接更新状态？ </summary>
              <div class='content'>
              <p>如果你尝试直接更新状态，React 组件并不会重新渲染。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误❌</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">message</span> = <span class="string">&#x27;Hello world&#x27;</span>;</span><br></pre></td></tr></table></figure><p>正确的做法是使用 <code>setState()</code> 方法。它会计划一个对组件状态对象的更新。当状态更改时，组件通过重新渲染进行响应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确✅</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">message</span>: <span class="string">&#x27;Hello World&#x27;</span> &#125;);</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong>你可以使用构造函数或者最新的 javascript class 字段声明语法直接将其分配给状态对象。</p></blockquote>
              </div>
            </details>

<details class="folding-tag" yellow><summary> 12. 回调函数作为 `setState()` 的参数的目的是什么？ </summary>
              <div class='content'>
              <p>setState 完成并重新渲染组件后，将调用回调函数。由于 setState() 是异步的，因此回调函数可用于任何后续操作。</p><blockquote><p><strong>注意：</strong>我们建议使用生命周期方法而不是这个回调函数</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">setState</span>(&#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span> &#125;, <span class="function">() =&gt;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The name has updated and component re-rendered&#x27;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" yellow><summary> 13. HTML 和 React 的事件处理有什么不同？ </summary>
              <div class='content'>
              <p>下面是一些 HTML 和 React 的事件处理的主要不同：</p><ol><li>在 HTML 中，事件名应该是全小写的：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;activateLasers()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然而在 React 中事件名遵循小驼峰 格式：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;activateLasers&#125;&gt;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 HTML 中，你应该返回 <code>false</code> 来阻止默认行为：</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">onclick</span>=<span class="string">&#x27;console.log(&quot;The link was clicked.&quot;); return false;&#x27;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>然后在 React 中你必须明确地调用 <code>preventDefault()</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">handleClick</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;The link was clicked.&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>在 HTML 中，你调用函数时需要加上 <code>()</code>：</li></ol><p>然后在 React 中你不应该在函数名后带上 <code>()</code>。（比如前面示例中的 <code>activateLasers</code> 函数）</p>
              </div>
            </details>

<details class="folding-tag" yellow><summary> 14. 如何在 JSX 回调函数中绑定方法或事件处理器 </summary>
              <div class='content'>
              <p>这里有 3 个方法做到这一点：</p><ol><li><strong>在构造器中绑定：</strong> 在 JavaScript 类中，默认情况下不绑定方法。同样的事情也适用于定义为类方法的 React 事件处理器。通常我们将它们绑定在构造函数中。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Component</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleClick</span> = <span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleClick</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>类的公共字段语法：</strong> 如果你不喜欢使用绑定的方式，也可以使用类的公共字段语法来正确绑定回调：</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this is:&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>&#125;&gt;&#123;<span class="string">&#x27;Click me&#x27;</span>&#125;&lt;/button&gt;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>箭头函数作为回调：</strong> 你可以直接在回调中使用箭头函数</li></ol><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function"><span class="params">event</span> =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">handleClick</span>(event)&#125;&gt;&#123;<span class="string">&#x27;Click me&#x27;</span>&#125;&lt;/button&gt;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong> 如果回调作为 prop 传递给子组件，这些组件可能会触发额外的重渲染。在这些场景中，考虑到性能因素，最佳的选择是使用 <code>.bind()</code> 或类的公共字段语法。</p></blockquote>
              </div>
            </details>

<details class="folding-tag" yellow><summary> 15. 如何传递参数给事件处理器或回调？ </summary>
              <div class='content'>
              <p>你可以使用一个箭头函数来包裹一个事件处理器并传递参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">handleClick</span>(id)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>这等价于调用 <code>.bind</code> 函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="property">handleClick</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>, id)&#125; /&gt;</span><br></pre></td></tr></table></figure><p>除了这两种办法，你也可以传递参数给一个箭头函数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onClick=&#123;<span class="variable language_">this</span>.<span class="title function_">handleClick</span>(id)&#125; /&gt;;</span><br><span class="line">handleClick = <span class="function"><span class="params">id</span> =&gt;</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Hello, your ticket number is&#x27;</span>, id);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" yellow><summary> 16. React 中的合成事件是什么？ </summary>
              <div class='content'>
              <p><code>SyntheticEvent</code> 是基于浏览器本地事件的跨浏览器包装。它的 API 与浏览器的本地事件相同，包括 <code>stopPropagation()</code> 和 <code>preventDefault()</code>，但事件在所有浏览器中的表现均一致。</p>
              </div>
            </details>

<details class="folding-tag" yellow><summary> 17. 什么是内联条件表达式？ </summary>
              <div class='content'>
              <p>你可以使用 JS 可用的 <code>if</code> 语句或三元表达式来有条件地渲染表达式。 除了这些方法之外，还可以通过将所有表达式括在花括号中然后在其后跟 JS 逻辑运算符 <code>&amp;&amp;</code> 来将任何表达式嵌入 JSX。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;h1&gt;<span class="title class_">Hello</span>!&lt;/h1&gt;;</span><br><span class="line">&#123;</span><br><span class="line">  messages.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; !isLogin ? (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>You have &#123;messages.length&#125; unread messages.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  ) : (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>You don&#x27;t have unread messages.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" yellow><summary> 18. 什么是 `key` prop？在元素数组中使用它的好处是什么？ </summary>
              <div class='content'>
              <p><code>key</code> 是当你创建一个元素数组时应该包含的一个特殊的字符串属性。<code>key</code> prop 会帮助 React 识别具体哪一项被修改、添加或被移除。</p><p>通常，我们将数据中的 ID 用作 <code>key</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.<span class="title function_">map</span>(<span class="function"><span class="params">todo</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;todo.id&#125;</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span>);</span><br></pre></td></tr></table></figure><p>如果呈现的项目没有稳定的 ID，退而求其次，我们可以将 <code>index</code> 作为 <code>key</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> todoItems = todos.<span class="title function_">map</span>(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index.toString()&#125;</span>&gt;</span>&#123;todo.text&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">));</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li>如果列表项可能改变，不建议使用 <code>indexes</code> 作为 <code>keys</code>。这可能会对性能产生负面影响，并可能导致组件状态出现问题。</li><li>如果你将列表项提取为单独的组件，则在列表组件上应用 <code>keys</code> 而不是 <code>li</code> 标签。</li><li>如果列表项中不存在 <code>key</code> prop，则控制台中将出现警告消息。</li></ol>
              </div>
            </details>

<details class="folding-tag" yellow><summary> 19. refs 有什么用？ </summary>
              <div class='content'>
              <p>refs 用于返回对该元素的引用。在大多数情况下，应避免使用它们，但是，当你需要直接访问 DOM 元素或组件的实例时，它们会很有用。</p>
              </div>
            </details>

<h2 id="20-如何创建-refs？"><a href="#20-如何创建-refs？" class="headerlink" title="20. 如何创建 refs？"></a>20. 如何创建 refs？</h2><p>这里有两种方式</p>
<p>1.这是最近添加的方法。使用 <code>React.createRef()</code> 方法创建 refs，并通过 ref 属性附加到 React 元素。为了在整个组件中使用 refs，只需将 ref 分配给构造函数中的 instance 属性。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">myRef</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>无论 React 版本如何，你都可以使用 ref 回调方法。例如，搜索栏组件的输入元素的访问方式如下。</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SearchBar</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">txtSearch</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">term</span>: <span class="string">&#x27;&#x27;</span> &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">setInputSearchRef</span> = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">txtSearch</span> = e;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">onInputChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">term</span>: <span class="variable language_">this</span>.<span class="property">txtSearch</span>.<span class="property">value</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">value</span>=<span class="string">&#123;this.state.term&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">onChange</span>=<span class="string">&#123;this.onInputChange.bind(this)&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">        <span class="attr">ref</span>=<span class="string">&#123;this.setInputSearchRef&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">      /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你也可以使用闭包在函数组件中使用 refs。</p>
<blockquote>
<p><strong>注意：</strong> 你也可以使用内联 ref 回调，即使这不是推荐的方法</p>
</blockquote>
<h2 id="21-refs-转发是什么？"><a href="#21-refs-转发是什么？" class="headerlink" title="21. refs 转发是什么？"></a>21. refs 转发是什么？</h2><p><em>Ref 转发</em> 是让某些组件可以使用它们接收的 <code>ref</code> 的特性，这些组件还可以进一步将其传递给子组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">ButtonElement</span> = <span class="title class_">React</span>.<span class="title function_">forwardRef</span>(<span class="function">(<span class="params">props, ref</span>) =&gt;</span> (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span> <span class="attr">className</span>=<span class="string">&quot;CustomButton&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;props.children&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create ref to the DOM button:</span></span><br><span class="line"><span class="keyword">const</span> ref = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">ButtonElement</span> <span class="attr">ref</span>=<span class="string">&#123;ref&#125;</span>&gt;</span>&#123;&#x27;Forward Ref&#x27;&#125;<span class="tag">&lt;/<span class="name">ButtonElement</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="22-refs-回调和-findDOMNode-哪个是首选项？"><a href="#22-refs-回调和-findDOMNode-哪个是首选项？" class="headerlink" title="22. refs 回调和 findDOMNode() 哪个是首选项？"></a>22. refs 回调和 <code>findDOMNode()</code> 哪个是首选项？</h2><p>最好使用 refs 回调 而不是 <code>findDOMNode()</code> API。因为 <code>findDOMNode()</code> 将来会阻止对 React 的某些改进。</p>
<p>使用 <code>findDOMNode</code> 的“传统”方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">findDOMNode</span>(<span class="variable language_">this</span>).<span class="title function_">scrollIntoView</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>推荐的方式是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span> = <span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">node</span>.<span class="property">current</span>.<span class="title function_">scrollIntoView</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&#123;this.node&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="23-为什么-Strings-Refs-被遗弃了？"><a href="#23-为什么-Strings-Refs-被遗弃了？" class="headerlink" title="23. 为什么 Strings Refs 被遗弃了？"></a>23. 为什么 Strings Refs 被遗弃了？</h2><p>如果你以前使用过 React，那么你可能会熟悉一个较旧的 API，其中的<code>ref</code> 属性是一个字符串，例如 <code>ref = &#123;textInput&#39;&#125;</code>，并且 DOM 节点作为<code>this.refs.textInput</code> 访问。我们建议你不要这样做，因为 String 引用有以下问题，并且被认为是旧版的。字符串引用已经在 <strong>React v16 中被删除</strong>。</p>
<ol>
<li><p>他们迫使 React 跟踪当前正在执行的组件。这是有问题的，因为它使 React 模块成为有状态的，并因此在打包 React 模块时冲突而引起奇怪的错误。</p>
</li>
<li><p>它们是“不可组合的” — 如果库在传递的子项上放置了引用，则用户不能在其上放置其他引用。回调引用完全可以组合。</p>
</li>
<li><p>他们不能和静态分析工具配合（比如 Flow）。Flow 无法猜测出框架 <code>this.refs</code> 上出现的字符串引用及其类型（可能不同）。 回调引用对静态分析更友好。</p>
</li>
<li><p>它无法像大多数人期望的那样使用“渲染回调”模式（例如）</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  renderRow = <span class="function"><span class="params">index</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// This won&#x27;t work. Ref will get attached to DataTable rather than MyComponent:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;</span>&#x27;<span class="attr">input-</span>&#x27; + <span class="attr">index</span>&#125; /&gt;</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This would work though! Callback refs are awesome.</span></span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">ref</span>=<span class="string">&#123;input</span> =&gt;</span> (this[&#x27;input-&#x27; + index] = input)&#125; /&gt;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">DataTable</span> <span class="attr">data</span>=<span class="string">&#123;this.props.data&#125;</span> <span class="attr">renderRow</span>=<span class="string">&#123;this.renderRow&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="24-虚拟-DOM-是什么？"><a href="#24-虚拟-DOM-是什么？" class="headerlink" title="24. 虚拟 DOM 是什么？"></a>24. 虚拟 DOM 是什么？</h2><p>_Virtual DOM_（VDOM）是<em>Real DOM</em>的内存表示形式。 UI 的表示形式保留在内存中，并与“真实” DOM 同步。 这是在调用渲染函数和在屏幕上显示元素之间发生的一步。 这整个过程称为 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://zh-hans.reactjs.org/docs/reconciliation.html">协调</a>。</p>
<h2 id="25-虚拟-DOM-原理"><a href="#25-虚拟-DOM-原理" class="headerlink" title="25. 虚拟 DOM 原理"></a>25. 虚拟 DOM 原理</h2><p>虚拟 DOM 工作原理只有三个简单的步骤。</p>
<ol>
<li>无论何时任何基础数据发生更改，整个 UI 都将以虚拟 DOM 表现形式重新呈现。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/9f8a99a43f7049feb7806a1bd54e5929~tplv-k3u1fbpfcp-zoom-1.image" alt="vdom"></p>
<ol start="2">
<li>然后，计算先前的 DOM 表现形式与新的 DOM 表现形式之间的差异。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://github.com/sudheerj/reactjs-interview-questions/raw/master/images/vdom2.png" alt="vdom2"></p>
<ol start="3">
<li>一旦完成计算，将只会更新内容真正改变的那部分真是 DOM。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/461ba77627524f96b2bf270c1935b969~tplv-k3u1fbpfcp-zoom-1.image" alt="vdom3"></p>
<h2 id="26-Shadow-DOM-和-Virtual-DOM-有什么区别？"><a href="#26-Shadow-DOM-和-Virtual-DOM-有什么区别？" class="headerlink" title="26. Shadow DOM 和 Virtual DOM 有什么区别？"></a>26. Shadow DOM 和 Virtual DOM 有什么区别？</h2><p>Shadow DOM 是一种浏览器技术，主要用于确定 web components 中的变量和 CSS。Virtual DOM 是由浏览器 API 之上的 JavaScript 库实现的概念。</p>
<h2 id="27-React-Fiber-是什么"><a href="#27-React-Fiber-是什么" class="headerlink" title="27. React Fiber 是什么?"></a>27. React Fiber 是什么?</h2><p>Fiber 是 React v16 中新的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://zh-hans.reactjs.org/docs/reconciliation.html">协调</a> 引擎或核心算法的重新实现。React Fiber 的目标是提高其在动画、布局、手势、暂停、中止或重用工作的能力，以及为不同类型的更新分配优先级等方面的适用性和新的并发原语。</p>
<h2 id="28-React-Fiber-的主要设计目的是什么？"><a href="#28-React-Fiber-的主要设计目的是什么？" class="headerlink" title="28. React Fiber 的主要设计目的是什么？"></a>28. React Fiber 的主要设计目的是什么？</h2><p>React Fiber 的目标是提高其对动画、布局和手势等领域的适用性。它的 headline 功能是<strong>增量渲染</strong>：能够将渲染工作拆分为多个块并将其分布到多个帧中。</p>
<h2 id="29-受控组件是什么？"><a href="#29-受控组件是什么？" class="headerlink" title="29. 受控组件是什么？"></a>29. 受控组件是什么？</h2><p>在用户输入后能够控制表单中输入元素的组件被称为“受控组件”，比如每一个状态概念都将有一个相关的处理函数</p>
<p>例如下面的例子中，为了将名字转换为全大写，我们使用 <code>handleChange</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;<span class="attr">value</span>: event.<span class="property">target</span>.<span class="property">value</span>.<span class="title function_">toUpperCase</span>()&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="30-非受控组件是什么？"><a href="#30-非受控组件是什么？" class="headerlink" title="30. 非受控组件是什么？"></a>30. 非受控组件是什么？</h2><p>非受控组件是那些把状态维护在其内部的组件，当你想要获得当前值时需要使用 ref 查询 DOM。这有一点像传统的 HTML。</p>
<p>在下面的 <code>UserProfile</code> 组件中，<code>name</code> 输入被使用 <code>ref</code> 获取：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserProfile</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">handleSubmit</span> = <span class="variable language_">this</span>.<span class="property">handleSubmit</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">input</span> = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">handleSubmit</span>(<span class="params">event</span>) &#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;A name was submitted: &#x27;</span> + <span class="variable language_">this</span>.<span class="property">input</span>.<span class="property">current</span>.<span class="property">value</span>);</span><br><span class="line">    event.<span class="title function_">preventDefault</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;&#x27;Name:&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.input&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="31-createElement-和-cloneElement-的区别是什么？"><a href="#31-createElement-和-cloneElement-的区别是什么？" class="headerlink" title="31. createElement 和 cloneElement 的区别是什么？"></a>31. createElement 和 cloneElement 的区别是什么？</h2><p>JSX 元素将被转换为 <code>React.createElement()</code> 函数以创建 React 元素，这些元素将用于 UI 的对象表示。而 <code>cloneElement</code> 用于克隆元素并将新的 <code>props</code> 传递给它。</p>
<p><strong>课后扩展：</strong></p>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zh-hans.reactjs.org/docs/react-api.html">React 顶层 API</a></li>
</ul>
<h2 id="32-React-中的状态提升是什么？"><a href="#32-React-中的状态提升是什么？" class="headerlink" title="32. React 中的状态提升是什么？"></a>32. React 中的状态提升是什么？</h2><p>当多个组件需要共享相同的变化数据时，建议将共享状态提升到它们最接近的共同祖先。这意味着，如果两个子组件共享来自其父组件的相同数据，则将状态移到父组件，而不是在两个子组件中都保持内部状态。</p>
<h2 id="33-组件生命周期有哪些不同阶段？"><a href="#33-组件生命周期有哪些不同阶段？" class="headerlink" title="33. 组件生命周期有哪些不同阶段？"></a>33. 组件生命周期有哪些不同阶段？</h2><p>组件生命周期具有三个不同的生命周期阶段。</p>
<ol>
<li><strong>Mounting：</strong> 组件已准备好安装在浏览器 DOM 中。这个阶段涵盖了生命周期方法 <code>constructor()</code>、<code>getDerivedStateFromProps()</code>、 <code>render()</code> 和 <code>componentDidMount()</code> 的初始化。</li>
<li><strong>Updating：</strong> 在此阶段，组件以两种方式进行更新，即发送新 <code>props</code> 和从 <code>setState()</code> 或 <code>forceUpdate()</code> 更新状态。此阶段涵盖了<code>getDerivedStateFromProps()</code>，<code>shouldComponentUpdate()</code>，<code>render()</code> 、<code>getSnapshotBeforeUpdate()</code> 和 <code>componentDidUpdate()</code> 生命周期方法。</li>
<li><strong>Unmounting：</strong> 在最后一个阶段，不再需要该组件并从浏览器 DOM 上卸载该组件。 这个阶段包括 <code>componentWillUnmount()</code> 生命周期方法。</li>
</ol>
<p>值得一提的是，在将更改应用于 DOM 时，React 内部具有阶段性概念。 它们分开如下</p>
<ol>
<li><strong>Render：</strong> 该组件将渲染而没有任何副作用。这适用于 Pure 组件，在此阶段，React 可以暂停、中止或重新启动渲染。</li>
<li><strong>Pre-commit：</strong> 在组件将更改实际应用于 DOM 之前，有一段时间可以让 React 通过 <code>getSnapshotBeforeUpdate()</code> 从 DOM 中读取内容。</li>
<li><strong>Commit：</strong> React 与 DOM 一起工作并分别执行最终的生命周期：<code>componentDidMount()</code> 用于安装，<code>componentDidUpdate()</code> 用于更新，以及 <code>componentWillUnmount()</code> 用于卸载。</li>
</ol>
<p>React 16.3+ (或者 <a target="_blank" rel="noopener external nofollow noreferrer" href="http://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">在线交互版本</a>)</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fac807b8490c4c11a9630a9f29e467d3~tplv-k3u1fbpfcp-zoom-1.image" alt="紫竹"></p>
<p>React 16.3 之前的版本：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/33a918a89bdd49c08e80732f5f6af367~tplv-k3u1fbpfcp-zoom-1.image" alt="phases 16.2"></p>
<h2 id="34-React-生命周期有哪些？"><a href="#34-React-生命周期有哪些？" class="headerlink" title="34. React 生命周期有哪些？"></a>34. React 生命周期有哪些？</h2><p>React 16.3 以前的版本：</p>
<ul>
<li><strong>componentWillMount：</strong> 在渲染之前执行，用于根组件中的应用程序级别配置。</li>
<li><strong>componentDidMount：</strong> 在首次渲染之后执行，所有 AJAX 请求，DOM 或状态更新以及设置事件侦听器都应在此执行。</li>
<li><strong>componentWillReceiveProps：</strong> 在特定属性更新以触发状态转换时执行。</li>
<li><strong>shouldComponentUpdate：</strong> 确定是否要更新组件。默认情况下，它返回 <code>true</code>。如果你确定在状态或属性更新后不需要渲染组件，则可以返回 <code>false</code> 值。这是提高性能的好地方，因为如果组件收到新的 <code>props</code>，它可以防止重新渲染。</li>
<li><strong>componentWillUpdate：</strong> 当有属性或状态改变被<code>shouldComponentUpdate()</code> 确认并返回 <code>true</code> 时，在重新渲染组件之前执行。</li>
<li><strong>componentDidUpdate：</strong> 通常，它用于响应属性或状态更改来更新 DOM。</li>
<li><strong>componentWillUnmount：</strong> 它将用于取消任何传出的网络请求，或删除与该组件关联的所有事件侦听器。</li>
</ul>
<p>React 16.3+ 版本</p>
<ul>
<li><strong>getDerivedStateFromProps：</strong> 在调用 <code>render()</code> 之前被调用，并且在每次渲染中都会被调用。对于需要派生状态的罕见用例，这是存在的。<a target="_blank" rel="noopener external nofollow noreferrer" href="https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html">如果您需要派生状态</a> 值得一读。</li>
<li><strong>componentDidMount：</strong> 在首次渲染之后执行，并且所有 AJAX 请求、DOM 或状态更新以及设置事件侦听器都应在此发生。</li>
<li><strong>shouldComponentUpdate：</strong> 确定是否将更新组件。默认情况下，它返回 <code>true</code>。如果你确定在状态或属性更新后不需要渲染组件，则可以返回 <code>false</code>值。这是提高性能的好地方，因为如果组件接收到新的属性，它可以防止重新渲染。</li>
<li><strong>getSnapshotBeforeUpdate：</strong> 在将呈现的输出提交给 DOM 之前立即执行。此方法返回的任何值都将传递到 <code>componentDidUpdate()</code> 中。 这对于从 DOM（即滚动位置）捕获信息很有用。</li>
<li><strong>componentDidUpdate：</strong> 通常，它用于响应属性或状态更改来更新 DOM。如果 <code>shouldComponentUpdate()</code> 返回 <code>false</code>，则不会触发。</li>
<li><strong>componentWillUnmount：</strong> 它将用于取消任何传出的网络请求，或删除与该组件关联的所有事件侦听器。</li>
</ul>
<h2 id="35-高阶组件是什么"><a href="#35-高阶组件是什么" class="headerlink" title="35. 高阶组件是什么"></a>35. 高阶组件是什么</h2><p>高阶组件（HOC）是接收组件并返回新组件的函数。基本上，这是从 React 的组成性质衍生出来的一种模式。</p>
<p>我们称它们为纯组件，因为它们可以接受任何动态提供的子组件，但是它们不会修改或复制其输入组件中的任何行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">EnhancedComponent</span> = <span class="title function_">higherOrderComponent</span>(<span class="title class_">WrappedComponent</span>);</span><br></pre></td></tr></table></figure>

<p>HOC 可以用到很多场景中：</p>
<ol>
<li>代码重用，逻辑和引导程序抽象。</li>
<li>渲染劫持。</li>
<li>状态抽象和操纵。</li>
<li>props 操作。</li>
</ol>
<h2 id="36-如何为-HOC-组件-创建-props-代理？"><a href="#36-如何为-HOC-组件-创建-props-代理？" class="headerlink" title="36. 如何为 HOC 组件 创建 props 代理？"></a>36. 如何为 HOC 组件 创建 props 代理？</h2><p>您可以使用属性代理模式添加或编辑传递给组件的属性，如下所示：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">HOC</span>(<span class="params">WrappedComponent</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">Test</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> newProps = &#123;</span><br><span class="line">        <span class="attr">title</span>: <span class="string">&#x27;New Header&#x27;</span>,</span><br><span class="line">        <span class="attr">footer</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">showFeatureX</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">showFeatureY</span>: <span class="literal">true</span>,</span><br><span class="line">      &#125;;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; &#123;<span class="attr">...newProps</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>课后扩展：</strong></p>
<ul>
<li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/6844903641074106381">react 高阶组件的代理模式</a></li>
</ul>
<h2 id="37-context-是什么？"><a href="#37-context-是什么？" class="headerlink" title="37. context 是什么？"></a>37. context 是什么？</h2><p><code>Context</code> 提供了一种通过组件树传递数据的方法，而不需要一层一层手动传递属性。</p>
<p>例如，需要由许多组件在应用程序中访问经过身份验证的用户，本地设置首选项，UI 主题等。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">Provider</span>, <span class="title class_">Consumer</span> &#125; = <span class="title class_">React</span>.<span class="title function_">createContext</span>(defaultValue);</span><br></pre></td></tr></table></figure>

<h2 id="38-什么是-children-属性？"><a href="#38-什么是-children-属性？" class="headerlink" title="38. 什么是 children 属性？"></a>38. 什么是 children 属性？</h2><p><code>Children</code> 是一个 prop（<code>this.props.children</code>），允许你将组件作为数据传递给其他组件，就像你使用的任何其他 prop 一样。放置在组件的开始标记和结束标记之间的组件树将作为 <code>children</code> 道具传递给该组件。</p>
<p>React API 中有许多方法可作为该属性。其中包括 <code>React.Children.map</code>、<code>React.Children.forEach</code>，<code>React.Children.count</code>、<code>React.Children.only</code> 和 <code>React.Children.toArray</code>。</p>
<p>children 的简单用法如下所示：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyDiv</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.children&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyDiv</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#x27;Hello&#x27;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#x27;World&#x27;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">MyDiv</span>&gt;</span></span>,</span><br><span class="line">  node,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="39-React-中如何写注释？"><a href="#39-React-中如何写注释？" class="headerlink" title="39. React 中如何写注释？"></a>39. React 中如何写注释？</h2><p>React JSX 中的注释和 JavaScript 的多行注释很像，但是用大括号括起来。</p>
<p><strong>单行注释：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;<span class="comment">/* 这里是单行注释 */</span>&#125;</span><br><span class="line">  &#123;<span class="string">`Welcome <span class="subst">$&#123;user&#125;</span>, let&#x27;s play React`</span>&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p><strong>多行注释：</strong></p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;<span class="comment">/* Multi-line comments for more than</span></span><br><span class="line"><span class="comment">   one line */</span>&#125;</span><br><span class="line">  &#123;<span class="string">`Welcome <span class="subst">$&#123;user&#125;</span>, let&#x27;s play React`</span>&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="40-在-constructor-中给-super-函数传递-props-的目的是什么？"><a href="#40-在-constructor-中给-super-函数传递-props-的目的是什么？" class="headerlink" title="40. 在 constructor 中给 super 函数传递 props 的目的是什么？"></a>40. 在 constructor 中给 <code>super</code> 函数传递 props 的目的是什么？</h2><p>一个子类构造器在 <code>super()</code> 方法调用之前是无法拿到 <code>this</code> 引用的。这同样也适用于 ES6 中的 sub-classes。调用 <code>super()</code> 时传递 props 的主要是为了在子类的构造器中访问 <code>this.props</code>。</p>
<p><strong>传递 props：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>); <span class="comment">// 打印 &#123; name: &#x27;John&#x27;, age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>不传递 props：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>); <span class="comment">// 打印 undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 但是 props 参数依然可以访问</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(props); <span class="comment">// 打印 &#123; name: &#x27;John&#x27;, age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 在 constructor 之外没有影响</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>); <span class="comment">// 打印 &#123; name: &#x27;John&#x27;, age: 42 &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码片段揭示了 <code>this.props</code> 仅在构造函数中有所不同。在构造函数外部表现将是相同的。</p>
<p>更多信息可以参考 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://overreacted.io/zh-hans/why-do-we-write-super-props/">为什么我们要写 super(props) ？</a></p>
<p>大多数场景中，我们建议使用受控组件来代替表单组件。</p>
<h2 id="41-协调（reconciliation）是什么？"><a href="#41-协调（reconciliation）是什么？" class="headerlink" title="41. 协调（reconciliation）是什么？"></a>41. 协调（reconciliation）是什么？</h2><p>当一个组件的 props 或 state 发生变化时，React 通过比较新返回的元素和之前渲染的元素来决定是否有必要进行实际的 DOM 更新。当它们不相等时，React 将更新 DOM。这个过程被称为 _协调（reconciliation）_。</p>
<h2 id="42-如何用一个动态键名来设置状态？"><a href="#42-如何用一个动态键名来设置状态？" class="headerlink" title="42. 如何用一个动态键名来设置状态？"></a>42. 如何用一个动态键名来设置状态？</h2><p>如果你使用 ES6 或 Babel 转码器来转换你的 JSX 代码，那么你可以用计算属性命名完成。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">handleInputChange</span>(<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; [event.<span class="property">target</span>.<span class="property">id</span>]: event.<span class="property">target</span>.<span class="property">value</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="43-每次组件渲染时，函数被调用的常见错误是什么？"><a href="#43-每次组件渲染时，函数被调用的常见错误是什么？" class="headerlink" title="43. 每次组件渲染时，函数被调用的常见错误是什么？"></a>43. 每次组件渲染时，函数被调用的常见错误是什么？</h2><p>你需要确保在传递函数作为参数时，没有调用该函数。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 错误❌： handleClick 被调用而不是作为引用被传入</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick()&#125;</span>&gt;</span>&#123;&#x27;Click Me&#x27;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取而代之的是传递函数本身，不加圆括号。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 正确：handleClick 是作为一个引用传递的!</span></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>&#123;&#x27;Click Me&#x27;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="44-lazy-函数是否支持命名导出？"><a href="#44-lazy-函数是否支持命名导出？" class="headerlink" title="44. lazy 函数是否支持命名导出？"></a>44. lazy 函数是否支持命名导出？</h2><p>不，目前 <code>React.lazy</code> 函数只支持默认出口。如果你想导入被命名导出的模块，你可以创建一个中间模块，将其作为默认出口。这也保证了摇树的工作，不会拉取未使用的组件。</p>
<p>让我们来看看一个导出多个命名组件的组件文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MoreComponents.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">SomeComponent</span> = <span class="comment">/* ... */</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title class_">UnusedComponent</span> = <span class="comment">/* ... */</span>;</span><br></pre></td></tr></table></figure>

<p>并在一个中间文件 <code>IntermediateComponent.js</code> 中重新导出 <code>MoreComponents.js</code> 组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IntermediateComponent.js</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="title class_">SomeComponent</span> <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./MoreComponents.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>现在你可以使用下面的 lazy 函数导入该模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; lazy &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="title class_">SomeComponent</span> = <span class="title function_">lazy</span>(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./IntermediateComponent.js&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="45-为什么-React-使用-className-而不是-class-属性？"><a href="#45-为什么-React-使用-className-而不是-class-属性？" class="headerlink" title="45. 为什么 React 使用 className 而不是 class 属性？"></a>45. 为什么 React 使用 <code>className</code> 而不是 <code>class</code> 属性？</h2><p><code>class</code> 是 JavaScript 的一个关键字，而 JSX 是 JavaScript 的一个扩展。这就是为什么 React 使用 <code>className</code> 而不是 <code>class</code> 的主要原因。传递一个字符串作为 <code>className</code> prop。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">span</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">menu</span> <span class="attr">navigation-menu</span>&#x27;&#125;&gt;</span>&#123;&#x27;Menu&#x27;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="46-片段（fragments）是什么？"><a href="#46-片段（fragments）是什么？" class="headerlink" title="46. 片段（fragments）是什么？"></a>46. 片段（fragments）是什么？</h2><p>这是 React 中常见的模式，用于一个组件返回多个元素。片段让你可以对一个 children 的列表进行分组，而无需在 DOM 中添加额外的节点。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildA</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildB</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildC</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里还有一个短语法可以用，但是很多工具不支持：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildA</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildB</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">ChildC</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="47-为什么片段（fragments）比-div-容器要好？"><a href="#47-为什么片段（fragments）比-div-容器要好？" class="headerlink" title="47. 为什么片段（fragments）比 div 容器要好？"></a>47. 为什么片段（fragments）比 div 容器要好？</h2><ol>
<li>片段的速度更快一些，并且由于没有创建额外的 DOM 节点而使用更少的内存。这只有在非常大和深的树上才会体现出真正的好处。</li>
<li>一些 CSS 机制，如 Flexbox 和 CSS Grid 有一个特殊的父子关系，在中间添加 div 会使其难以保持所需的布局。</li>
<li>DOM 检查器不那么杂乱。</li>
</ol>
<h2 id="48-什么是-React-中的传递门（Portal）？"><a href="#48-什么是-React-中的传递门（Portal）？" class="headerlink" title="48. 什么是 React 中的传递门（Portal）？"></a>48. 什么是 React 中的传递门（Portal）？</h2><p>传递门是一种推荐的方式，可以将子节点渲染到父组件的 DOM 层次结构之外的 DOM 节点中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(child, container);</span><br></pre></td></tr></table></figure>

<p>第一个参数是任何可渲染的 React children，比如一个元素、字符串或片段。第二个参数是一个 DOM 元素。</p>
<h2 id="49-什么是无状态组件"><a href="#49-什么是无状态组件" class="headerlink" title="49. 什么是无状态组件?"></a>49. 什么是无状态组件?</h2><p>如果行为是独立于其状态的，那么它可以是一个无状态组件。你可以使用函数或类来创建无状态组件。但除非你需要在你的组件中使用生命周期钩子，否则你应该选择函数组件。如果你决定在这里使用函数组件，会有很多好处；它们易于编写、理解和测试，速度稍快，而且你可以完全避免使用 <code>this</code> 关键字。</p>
<h2 id="50-什么是状态组件"><a href="#50-什么是状态组件" class="headerlink" title="50. 什么是状态组件?"></a>50. 什么是状态组件?</h2><p>如果一个组件的行为依赖于该组件的状态（state），那么它可以被称为有状态的组件。这些有状态的组件总是类组件，并且有一个在构造器（<code>constructor</code>）中被初始化的状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 也可以使用类字段语法</span></span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>React 16.8 更新：</strong></p>
<p>Hooks 让你在不写类的情况下使用状态和其他 React 功能。</p>
<p>等效的函数组件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123;useState&#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">App</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> [count, setCount] = <span class="title function_">useState</span>(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="comment">// JSX</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="51-如何在-React-中对-props-进行验证？"><a href="#51-如何在-React-中对-props-进行验证？" class="headerlink" title="51. 如何在 React 中对 props 进行验证？"></a>51. 如何在 React 中对 props 进行验证？</h2><p>当应用程序运行在开发模式时，React 会自动检查我们在组件上设置的所有 props，以确保它们具有正确的类型。如果类型不正确，React 会在控制台生成警告信息。由于对性能的影响，它在生产模式中被禁用。必需 props 是用 <code>isRequired</code> 定义的。</p>
<p>预定义的 props 类型集合。</p>
<ol>
<li><code>PropTypes.number</code></li>
<li><code>PropTypes.string</code></li>
<li><code>PropTypes.array</code></li>
<li><code>PropTypes.object</code></li>
<li><code>PropTypes.func</code></li>
<li><code>PropTypes.node</code></li>
<li><code>PropTypes.element</code></li>
<li><code>PropTypes.bool</code></li>
<li><code>PropTypes.symbol</code></li>
<li><code>PropTypes.any</code></li>
</ol>
<p>我们可以为 <code>User</code> 组件定义 <code>propTypes</code>，如下所示。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> propTypes = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequired</span>,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Welcome, $&#123;this.props.name&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;`Age, $&#123;this.props.age&#125;`&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：在 React v15.5 中，<code>PropTypes</code> 被从 <code>React.PropTypes</code> 移到 <code>prop-types</code>库中。</p>
</blockquote>
<p>等效的函数式组件：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">PropTypes</span> <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">User</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Welcome, $&#123;this.props.name&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;`Age, $&#123;this.props.age&#125;`&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">User</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="title class_">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="title class_">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequired</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="52-React-的优势是什么？"><a href="#52-React-的优势是什么？" class="headerlink" title="52. React 的优势是什么？"></a>52. React 的优势是什么？</h2><p>以下是 React的 主要优势。</p>
<ol>
<li>通过虚拟 DOM 提高应用程序的性能。</li>
<li>JSX 使代码易于阅读和编写。</li>
<li>它在客户端和服务器端都能进行渲染（SSR）。</li>
<li>易于与框架（Angular, Backbone）集成，因为它只是一个视图库。</li>
<li>使用 Jest 等工具容易编写单元和集成测试。</li>
</ol>
<h2 id="53-React-的局限性是什么？"><a href="#53-React-的局限性是什么？" class="headerlink" title="53. React 的局限性是什么？"></a>53. React 的局限性是什么？</h2><p>除了优点之外，React 也有一些限制。</p>
<ol>
<li>React 只是一个视图库，不是一个完整的框架。</li>
<li>对于刚接触网络开发的初学者来说，有一个学习曲线。</li>
<li>将 React 整合到传统的 MVC 框架中需要一些额外的配置。</li>
<li>代码的复杂性随着内联模板和 JSX 的增加而增加。</li>
<li>太多的小组件导致了过度工程化或模板化。</li>
</ol>
<h2 id="54-什么是-React-v16-中的错误边界（Error-Boundary）？"><a href="#54-什么是-React-v16-中的错误边界（Error-Boundary）？" class="headerlink" title="54. 什么是 React v16 中的错误边界（Error Boundary）？"></a>54. 什么是 React v16 中的错误边界（Error Boundary）？</h2><p>错误边界是指在其子组件树的任何地方捕获 JavaScript 错误的组件，记录这些错误，并显示一个后备 UI ，而不是崩溃的组件树。</p>
<p>如果一个类组件定义了一个新的生命周期方法 <code>componentDidCatch(error, info)</code> 或 <code>static getDerivedStateFromError()</code> ，它就成为一个错误边界。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidCatch</span>(<span class="params">error, info</span>) &#123;</span><br><span class="line">    <span class="comment">// 你也可以把错误记录到一个错误报告服务中去</span></span><br><span class="line">    <span class="title function_">logErrorToMyService</span>(error, info)。</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromError</span>(<span class="params">error</span>) &#123;</span><br><span class="line">    <span class="comment">// 更新状态，以便下次渲染时显示回退的用户界面。</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">hasError</span>) &#123;</span><br><span class="line">      <span class="comment">// 你可以渲染任何自定义的回退用户界面</span></span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#x27;Something went wrong.&#x27;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">children</span>。</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后把它作为一个普通的组件使用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">ErrorBoundary</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">MyWidget</span> /&gt;</span></span></span><br><span class="line">&lt;/<span class="title class_">ErrorBoundary</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="55-React-v15-中是如何处理错误边界的？"><a href="#55-React-v15-中是如何处理错误边界的？" class="headerlink" title="55. React v15 中是如何处理错误边界的？"></a>55. React v15 中是如何处理错误边界的？</h2><p>React v15 使用 <code>unstable_handleError</code> 方法为错误边界提供了非常基本的支持。在 React v16 中，它已经被重新命名为 <code>componentDidCatch</code>。</p>
<h2 id="56-静态类型检查的推荐方式是什么？"><a href="#56-静态类型检查的推荐方式是什么？" class="headerlink" title="56. 静态类型检查的推荐方式是什么？"></a>56. 静态类型检查的推荐方式是什么？</h2><p>通常我们使用 PropTypes 库（<code>React.PropTypes</code> 从 React v15.5 开始转移到 <code>prop-types</code> 包）来进行 React 应用中的类型检查。对于大型代码库，建议使用静态类型检查器，如 Flow 或 TypeScript，在编译时进行类型检查并提供自动补全功能。</p>
<h2 id="57-react-dom-包有什么用？"><a href="#57-react-dom-包有什么用？" class="headerlink" title="57. react-dom 包有什么用？"></a>57. <code>react-dom</code> 包有什么用？</h2><p><code>react-dom</code> 包提供了 DOM 特定的方法，可以在你的应用程序的顶层使用。大多数组件不需要使用此模块。这个包的一些方法是：</p>
<ol>
<li><code>render()</code></li>
<li><code>hydrate()</code></li>
<li><code>unmountComponentAtNode()</code></li>
<li><code>findDOMNode()</code></li>
<li><code>createPortal()</code></li>
</ol>
<h2 id="58-react-dom-的-render-方法的目的是什么？"><a href="#58-react-dom-的-render-方法的目的是什么？" class="headerlink" title="58. react-dom 的 render 方法的目的是什么？"></a>58. <code>react-dom</code> 的 render 方法的目的是什么？</h2><p>此方法用于将 React 元素渲染到提供的容器中的 DOM 中，并返回对组件的引用。如果 React 元素之前已渲染到容器中，它将对其执行更新，并且仅在必要时更改 DOM 以反映最新更改。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(element, container[, callback])</span><br></pre></td></tr></table></figure>

<p>如果提供了可选的回调，它将在组件渲染或更新后执行。</p>
<h2 id="59-什么是-ReactDOMServer？"><a href="#59-什么是-ReactDOMServer？" class="headerlink" title="59. 什么是 ReactDOMServer？"></a>59. 什么是 ReactDOMServer？</h2><p><code>ReactDOMServer</code> 对象使你能够将组件呈现为静态标记（通常用于节点服务器）。该对象主要用于服务器端渲染（SSR）。以下方法可用于服务器和浏览器环境：</p>
<ol>
<li><code>renderToString()</code></li>
<li><code>renderToStaticMarkup()</code></li>
</ol>
<p>例如，你通常运行基于 Node 的 Web 服务器（如 Express、Hapi 或 Koa），然后调用 <code>renderToString</code> 将根组件渲染为字符串，然后将其作为响应发送。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Express</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderToString &#125; <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">MyPage</span> <span class="keyword">from</span> <span class="string">&#x27;./MyPage&#x27;</span>;</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&#x27;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;My Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&#x27;&lt;div id=&quot;content&quot;&gt;&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="title function_">renderToString</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">MyPage</span> /&gt;</span></span>));</span><br><span class="line">  res.<span class="title function_">write</span>(<span class="string">&#x27;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>);</span><br><span class="line">  res.<span class="title function_">end</span>();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="60-如何在-React-中使用-innerHTML？"><a href="#60-如何在-React-中使用-innerHTML？" class="headerlink" title="60. 如何在 React 中使用 innerHTML？"></a>60. 如何在 React 中使用 innerHTML？</h2><p><code>dangerouslySetInnerHTML</code> 属性是 React 在浏览器 DOM 中使用 <code>innerHTML</code> 的替代品。就像 <code>innerHTML</code> 一样，考虑到跨站点脚本 (XSS) 攻击，使用此属性是有风险的。你只需要传递一个 <code>__html</code> 对象作为键和 HTML 文本作为值。</p>
<p>在这个例子中，MyComponent 使用 <code>dangerouslySetInnerHTML</code> 属性来设置 HTML 标记：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createMarkup</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">__html</span>: <span class="string">&#x27;First &amp;middot; Second&#x27;</span> &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">MyComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">dangerouslySetInnerHTML</span>=<span class="string">&#123;createMarkup()&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="61-如何在-React-使用样式？"><a href="#61-如何在-React-使用样式？" class="headerlink" title="61. 如何在 React 使用样式？"></a>61. 如何在 React 使用样式？</h2><p><code>style</code> 属性接受一个小驼峰命名法属性的 JavaScript 对象，而不是一个 CSS 字符串。这与 DOM 风格的 JavaScript 属性一致，更有效率，并能防止 XSS 安全漏洞。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divStyle = &#123;</span><br><span class="line">  <span class="attr">color</span>: <span class="string">&#x27;blue&#x27;</span>,</span><br><span class="line">  <span class="attr">backgroundImage</span>: <span class="string">`url(<span class="subst">$&#123;imgUrl&#125;</span>)`</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">HelloWorldComponent</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&#123;divStyle&#125;</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>样式键名是符合驼峰命名法的，以便与在 JavaScript 中访问 DOM 节点的属性相一致（例如 <code>node.style.backgroundImage</code>）。</p>
<h2 id="62-事件在-React-中有何不同？"><a href="#62-事件在-React-中有何不同？" class="headerlink" title="62. 事件在 React 中有何不同？"></a>62. 事件在 React 中有何不同？</h2><p>Handling events in React elements has some syntactic differences:</p>
<p>在 React 元素上处理事件有一些语法上的不同：</p>
<ol>
<li>React 事件处理程序使用小驼峰命名，而不是小写。</li>
<li>使用 JSX，你传递一个函数作为事件处理程序，而不是一个字符串。</li>
</ol>
<h2 id="63-如果你在构造函数中使用-setState-，会发生什么？"><a href="#63-如果你在构造函数中使用-setState-，会发生什么？" class="headerlink" title="63. 如果你在构造函数中使用 setState()，会发生什么？"></a>63. 如果你在构造函数中使用 <code>setState()</code>，会发生什么？</h2><p>当你使用 <code>setState()</code> 时，除了分配给对象的状态外，React 还重新渲染组件和它的所有子组件。你会得到这样的错误：只能更新一个已挂载或正在挂载的组件。所以我们需要使用 <code>this.state</code> 来初始化构造函数中的变量。</p>
<h2 id="64-索引作为键的影响是什么？"><a href="#64-索引作为键的影响是什么？" class="headerlink" title="64. 索引作为键的影响是什么？"></a>64. 索引作为键的影响是什么？</h2><p>键应该是稳定的、可预测的和唯一的，这样 React 就可以跟踪元素。</p>
<p>在下面的代码片段中，每个元素的键都是基于索引的，而不是与被表示的数据相联系。这限制了 React 可以做的优化。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos.<span class="title function_">map</span>(<span class="function">(<span class="params">todo, index</span>) =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Todo</span> &#123;<span class="attr">...todo</span>&#125; <span class="attr">key</span>=<span class="string">&#123;index&#125;</span> /&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你使用元素数据作为唯一键，假设 <code>todo.id</code> 在这个列表中是唯一的，并且是稳定的，React 将能够对元素进行重新排序，而不需要像以前那样重新计算它们。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  todos.<span class="title function_">map</span>(<span class="function"><span class="params">todo</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Todo</span> &#123;<span class="attr">...todo</span>&#125; <span class="attr">key</span>=<span class="string">&#123;todo.id&#125;</span> /&gt;</span></span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="65-在-componentWillMount-方法中使用-setState-真的好吗"><a href="#65-在-componentWillMount-方法中使用-setState-真的好吗" class="headerlink" title="65. 在 componentWillMount() 方法中使用 setState 真的好吗?"></a>65. 在 <code>componentWillMount()</code> 方法中使用 <code>setState</code> 真的好吗?</h2><p>是的，在 <code>componentWillMount()</code> 方法中使用 <code>setState()</code> 是安全的。但同时，建议避免在<code>componentWillMount()</code> 生命周期方法中进行异步初始化。<code>componentWillMount()</code> 在挂载发生前立即被调用。它在 <code>render()</code> 之前被调用，因此在这个方法中设置状态不会触发重新渲染。避免在这个方法中引入任何副作用或订阅。我们需要确保组件初始化的异步调用发生在 <code>componentDidMount()</code> 而不是 <code>componentWillMount()</code>。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  axios.<span class="title function_">get</span>(<span class="string">`api/todos`</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">messages</span>: [...result.<span class="property">data</span>]</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="66-如果你在初始状态下使用-props，会发生什么？"><a href="#66-如果你在初始状态下使用-props，会发生什么？" class="headerlink" title="66. 如果你在初始状态下使用 props，会发生什么？"></a>66. 如果你在初始状态下使用 props，会发生什么？</h2><p>如果组件上的 props 被改变而组件没有被刷新，新的 props 值将永远不会被显示，因为构造函数永远不会更新组件的当前状态。来自 props 的状态初始化只在组件第一次被创建时运行。</p>
<p>下面这个组件就不会显示更新的输入值。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">records</span>: [],</span><br><span class="line">      <span class="attr">inputValue</span>: <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">inputValue</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.state.inputValue&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 render 方法中使用 props 将更新数值。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">record</span>: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;this.props.inputValue&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="67-你如何有条件地渲染组件？"><a href="#67-你如何有条件地渲染组件？" class="headerlink" title="67. 你如何有条件地渲染组件？"></a>67. 你如何有条件地渲染组件？</h2><p>在某些情况下，你想根据一些状态来渲染不同的组件。JSX 不渲染 <code>false</code> 或 <code>undefined</code>，所以你可以使用条件性短路来渲染你的组件的某一部分，只有当某个条件为真时。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params">&#123; name, address &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;address &amp;&amp; <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;address&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>如果你需要一个 <code>if-else</code> 条件，则使用三元运算符。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">MyComponent</span> = (<span class="params">&#123; name, address &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;address ? <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;address&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span> : <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#x27;Address is not available&#x27;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="68-为什么我们在-DOM-元素上传递-props-时需要谨慎？"><a href="#68-为什么我们在-DOM-元素上传递-props-时需要谨慎？" class="headerlink" title="68. 为什么我们在 DOM 元素上传递 props 时需要谨慎？"></a>68. 为什么我们在 DOM 元素上传递 props 时需要谨慎？</h2><p>当我们传递 props 时，我们会遇到添加未知的 HTML 属性的风险，这是一个不好的做法。相反，我们可以使用带有 <code>...rest</code> 操作符的 prop 解构，所以它将只添加需要的 prop。</p>
<p>比如说。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentA</span> = (<span class="params"></span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">ComponentB</span> <span class="attr">isDisplay</span>=<span class="string">&#123;true&#125;</span> <span class="attr">className</span>=<span class="string">&#123;</span>&#x27;<span class="attr">componentStyle</span>&#x27;&#125; /&gt;</span></span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">ComponentB</span> = (<span class="params">&#123; isDisplay, ...domProps &#125;</span>) =&gt; (</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> &#123;<span class="attr">...domProps</span>&#125;&gt;</span>&#123;&#x27;ComponentB&#x27;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="69-如何在-React-中使用装饰器？"><a href="#69-如何在-React-中使用装饰器？" class="headerlink" title="69. 如何在 React 中使用装饰器？"></a>69. 如何在 React 中使用装饰器？</h2><p>你可以对你的类组件进行装饰，这与将组件传入一个函数是一样的。<strong>装饰器</strong>是修改组件功能的灵活和可读的方式。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@<span class="title function_">setTitle</span>(<span class="string">&#x27;Profile&#x27;</span>)</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Profile</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">title 是一个字符串，将被设置为文档标题。WrappedComponent 是我们的装饰器在以下情况下会收到的东西直接放在一个组件类上面时，我们的装饰器会收到这样的信息，如上面的例子所示</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">setTitle</span> = title =&gt; <span class="function"><span class="params">WrappedComponent</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">class</span> <span class="title class_">extends</span> <span class="title class_">React</span>.<span class="property">Component</span> &#123;</span><br><span class="line">    <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">title</span> = title;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">WrappedComponent</span> &#123;<span class="attr">...this.props</span>&#125; /&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 装饰器是一个没有进入 ES7 的功能，但目前是一个第二阶段的建议。</p>
<h2 id="70-如何-memo-化一个组件？"><a href="#70-如何-memo-化一个组件？" class="headerlink" title="70. 如何 memo 化一个组件？"></a>70. 如何 memo 化一个组件？</h2><p>有一些可用的缓存库，可以用于函数组件。</p>
<p>例如，<code>moize</code> 库可以在另一个组件中对组件进行 memo 化。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moize <span class="keyword">from</span> <span class="string">&#x27;moize&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">Component</span> <span class="keyword">from</span> <span class="string">&#x27;./components/Component&#x27;</span>; <span class="comment">// 本模块导出一个非 memo 组件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">MemoizedFoo</span> = moize.<span class="title function_">react</span>(<span class="title class_">Component</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Consumer</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#x27;I will memoize the following entry:&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">MemoizedFoo</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>更新：</strong> 从 React v16.6.0 开始，我们有一个 <code>React.memo</code>。它提供了一个更高阶的组件，除非 props 发生变化，否则会将组件缓存。要使用它，只需在使用前用 <code>React.memo</code> 包住组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MemoComponent</span> = <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="keyword">function</span> <span class="title function_">MemoComponent</span>(<span class="params">props</span>) &#123;</span><br><span class="line">  <span class="comment">/* render using props */</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">memo</span>(<span class="title class_">MyFunctionComponent</span>);</span><br></pre></td></tr></table></figure>

<h2 id="71-你如何实现服务器端渲染或SSR？"><a href="#71-你如何实现服务器端渲染或SSR？" class="headerlink" title="71. 你如何实现服务器端渲染或SSR？"></a>71. 你如何实现服务器端渲染或SSR？</h2><p>React 已经具备了在 Nod e服务器上处理渲染的能力。有一个特殊版本的 DOM 渲染器，它与客户端的模式相同。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">ReactDOMServer</span> <span class="keyword">from</span> <span class="string">&#x27;react-dom/server&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOMServer</span>.<span class="title function_">renderToString</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>)。</span><br></pre></td></tr></table></figure>

<p>这个方法将把常规的 HTML 输出为一个字符串，然后可以作为服务器响应的一部分放在页面主体内。在客户端，React 检测到预渲染的内容，并无缝地衔接该内容。</p>
<h2 id="72-如何在-React-中启用生产模式？"><a href="#72-如何在-React-中启用生产模式？" class="headerlink" title="72. 如何在 React 中启用生产模式？"></a>72. 如何在 React 中启用生产模式？</h2><p>你应该使用 Webpack 的 <code>DefinePlugin</code> 方法来设置 <code>NODE_ENV</code> 为 <code>production</code>，通过它来剥离诸如 propType 验证和额外警告的东西。除此之外，如果你对代码进行最小化处理，例如 Uglify 的无效代码消除法，剥离出只用于开发的代码和注释，这将极大地减少你的包的大小。</p>
<h2 id="73-什么是-CRA-以及它的好处？"><a href="#73-什么是-CRA-以及它的好处？" class="headerlink" title="73. 什么是 CRA 以及它的好处？"></a>73. 什么是 CRA 以及它的好处？</h2><p><code>create-react-app</code> CLI 工具允许你快速创建和运行React应用程序，无需配置步骤。</p>
<p>让我们使用 CRA 创建 Todo 应用程序。</p>
<figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g create-react-app</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建新项目</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">create-react-app todo-app</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> todo-app</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">构建、测试、运行</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm run build</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm run <span class="built_in">test</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm start</span></span><br></pre></td></tr></table></figure>

<p>它包括我们建立一个 React 应用程序所需要的一切。</p>
<ol>
<li>支持 React、JSX、ES6 和 Flow 语法。</li>
<li>超越 ES6 的语言额外功能，如对象传播操作者。</li>
<li>自动前缀的 CSS，所以你不需要 <code>-webkit-</code> 或其他前缀。</li>
<li>一个快速的交互式单元测试运行器，内置支持覆盖率报告。</li>
<li>一个实时的开发服务器，对常见的错误发出警告。</li>
<li>一个构建脚本，用于捆绑 JS、CSS 和图片，并提供哈希和源码图。</li>
</ol>
<h2 id="74-安装中的生命周期方法的顺序是什么？"><a href="#74-安装中的生命周期方法的顺序是什么？" class="headerlink" title="74. 安装中的生命周期方法的顺序是什么？"></a>74. 安装中的生命周期方法的顺序是什么？</h2><p>当一个组件的实例被创建并插入到 DOM 中时，生命周期方法按以下顺序被调用。</p>
<ol>
<li><code>constructor()</code></li>
<li><code>static getDerivedStateFromProps()</code></li>
<li><code>render()</code></li>
<li><code>componentDidMount()</code></li>
</ol>
<h2 id="75-在-React-v16-中，有哪些生命周期方法将被废弃？"><a href="#75-在-React-v16-中，有哪些生命周期方法将被废弃？" class="headerlink" title="75. 在 React v16 中，有哪些生命周期方法将被废弃？"></a>75. 在 React v16 中，有哪些生命周期方法将被废弃？</h2><p>以下生命周期方法将是不安全的编码做法，在异步渲染中会出现更多问题。</p>
<ol>
<li><code>componentWillMount()</code></li>
<li><code>componentWillReceiveProps()</code></li>
<li><code>componentWillUpdate()</code></li>
</ol>
<p>从 React v16.3 开始，这些方法被别名为 <code>UNSAFE_</code> 前缀，未加前缀的版本将在 React v17 中被移除。</p>
<h2 id="76-getDerivedStateFromProps-生命周期方法的目的是什么？"><a href="#76-getDerivedStateFromProps-生命周期方法的目的是什么？" class="headerlink" title="76. getDerivedStateFromProps() 生命周期方法的目的是什么？"></a>76. <code>getDerivedStateFromProps()</code> 生命周期方法的目的是什么？</h2><p>新的静态的 <code>getDerivedStateFromProps()</code> 生命周期方法在一个组件实例化后以及重新渲染前被调用。它可以返回一个对象来更新状态，也可以返回 <code>null</code> 来表示新的 props 不需要任何状态更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="title function_">getDerivedStateFromProps</span>(<span class="params">props, state</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个生命周期方法与 <code>componentDidUpdate()</code> 一起涵盖了 <code>componentWillReceiveProps()</code> 的所有用例。</p>
<h2 id="77-getSnapshotBeforeUpdate-生命周期方法的目的是什么？"><a href="#77-getSnapshotBeforeUpdate-生命周期方法的目的是什么？" class="headerlink" title="77. getSnapshotBeforeUpdate() 生命周期方法的目的是什么？"></a>77. <code>getSnapshotBeforeUpdate()</code> 生命周期方法的目的是什么？</h2><p>新的 <code>getSnapshotBeforeUpdate()</code> 生命周期方法会在 DOM 更新前被调用。这个方法的返回值将作为第三个参数传递给 <code>componentDidUpdate()</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个生命周期方法与 <code>componentDidUpdate()</code> 一起涵盖了 <code>componentWillUpdate()</code> 的所有用例。</p>
<h2 id="78-Hooks-是否取代了渲染-props-和高阶组件？"><a href="#78-Hooks-是否取代了渲染-props-和高阶组件？" class="headerlink" title="78. Hooks 是否取代了渲染 props 和高阶组件？"></a>78. Hooks 是否取代了渲染 props 和高阶组件？</h2><p>渲染 props 和高阶组件都只渲染一个 children，但在大多数情况下，Hooks 是一种更简单的方式，通过减少树中的嵌套来达到这个目的。</p>
<h2 id="79-推荐用什么方式来命名组件？"><a href="#79-推荐用什么方式来命名组件？" class="headerlink" title="79. 推荐用什么方式来命名组件？"></a>79. 推荐用什么方式来命名组件？</h2><p>建议通过引用来命名组件，而不是使用 <code>displayName</code>。</p>
<p>使用 <code>displayName</code> 来命名组件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="attr">displayName</span>: <span class="string">&#x27;TodoApp&#x27;</span>,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>推荐的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">TodoApp</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="80-建议在组件类中方法的排序是什么？"><a href="#80-建议在组件类中方法的排序是什么？" class="headerlink" title="80. 建议在组件类中方法的排序是什么？"></a>80. 建议在组件类中方法的排序是什么？</h2><p>建议从安装到渲染阶段的方法的排序。</p>
<ol>
<li><code>static</code> 方法</li>
<li><code>constructor()</code></li>
<li><code>getChildContext()</code></li>
<li><code>componentWillMount()</code></li>
<li><code>componentDidMount()</code></li>
<li><code>componentWillReceiveProps()</code></li>
<li><code>shouldComponentUpdate()</code></li>
<li><code>componentWillUpdate()</code></li>
<li><code>componentDidUpdate()</code></li>
<li><code>componentWillUnmount()</code></li>
<li>点击处理程序或事件处理程序，如 <code>onClickSubmit()</code> 或 <code>onChangeDescription()</code></li>
<li>渲染的 getter 方法，如 <code>getSelectReason()</code> 或 <code>getFooterContent()</code></li>
<li>可选的渲染方法，如 <code>renderNavigation()</code> 或 <code>renderProfilePicture()</code></li>
<li>render()</li>
</ol>
<h2 id="81-什么是切换组件？"><a href="#81-什么是切换组件？" class="headerlink" title="81. 什么是切换组件？"></a>81. 什么是切换组件？</h2><p>切换组件是一个渲染许多组件中的一个组件。我们需要使用对象来将 props 值映射到组件。</p>
<p>例如，一个切换组件可以根据 <code>page</code> props 显示不同的页面。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">HomePage</span> <span class="keyword">from</span> <span class="string">&#x27;./HomePage&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">AboutPage</span> <span class="keyword">from</span> <span class="string">&#x27;./AboutPage&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ServicesPage</span> <span class="keyword">from</span> <span class="string">&#x27;./ServicesPage&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">ContactPage</span> <span class="keyword">from</span> <span class="string">&#x27;./ContactPage&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="variable constant_">PAGES</span> = &#123;</span><br><span class="line">  <span class="attr">home</span>: <span class="title class_">HomePage</span>,</span><br><span class="line">  <span class="attr">about</span>: <span class="title class_">AboutPage</span>,</span><br><span class="line">  <span class="attr">services</span>: <span class="title class_">ServicesPage</span>,</span><br><span class="line">  <span class="attr">contact</span>: <span class="title class_">ContactPage</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Page</span> = props =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title class_">Handler</span> = <span class="variable constant_">PAGES</span>[props.<span class="property">page</span>] || <span class="title class_">ContactPage</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">Handler</span> &#123;<span class="attr">...props</span>&#125; /&gt;</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PAGES 对象的键可以在 props 类型中使用，以捕捉开发时间错误。</span></span><br><span class="line"><span class="title class_">Page</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">page</span>: <span class="title class_">PropTypes</span>.<span class="title function_">oneOf</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable constant_">PAGES</span>)).<span class="property">isRequired</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="82-为什么我们需要向-setState-传递一个函数？"><a href="#82-为什么我们需要向-setState-传递一个函数？" class="headerlink" title="82. 为什么我们需要向 setState() 传递一个函数？"></a>82. 为什么我们需要向 <code>setState()</code> 传递一个函数？</h2><p>这背后的原因是，<code>setState()</code> 是一个异步操作。出于性能的考虑，React 会对状态变化进行批处理，所以在调用 <code>setState()</code> 后，状态可能不会立即发生变化。这意味着你在调用 <code>setState()</code> 时不应该依赖当前的状态，因为你不能确定这个状态会是什么。解决办法是将一个函数传递给 <code>setState()</code>，并将之前的状态作为参数。通过这样做，你可以避免由于 <code>setState()</code> 的异步性而导致用户在访问时获得旧的状态值的问题。</p>
<p>假设初始计数值为 0。在连续三次递增操作后，该值将只递增一个。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设 this.state.count === 0</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">count</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">count</span> + <span class="number">1</span> &#125;);</span><br><span class="line"><span class="comment">// this.state.count === 1，而不是 3</span></span><br></pre></td></tr></table></figure>

<p>如果我们给 <code>setState()</code> 传递一个函数，计数就会被正确地递增。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">count</span>: prevState.<span class="property">count</span> + props.<span class="property">increment</span>,</span><br><span class="line">&#125;));</span><br><span class="line"><span class="comment">// this.state.count === 3</span></span><br></pre></td></tr></table></figure>

<h2 id="83-为什么在-setState-中首选函数而不是对象？"><a href="#83-为什么在-setState-中首选函数而不是对象？" class="headerlink" title="83. 为什么在 setState() 中首选函数而不是对象？"></a>83. 为什么在 <code>setState()</code> 中首选函数而不是对象？</h2><p>React 可以将多个 <code>setState()</code> 的调用批量化为一次更新，以提高性能。因为 <code>this.props</code> 和 <code>this.state</code> 可能被异步更新，你不应该依赖它们的值来计算下一个状态。</p>
<p>这个计数器的例子将无法按预期更新。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误❌</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">  <span class="attr">counter</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">counter</span> + <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">increment</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>首选的方法是用函数而不是对象调用 <code>setState()</code>。该函数将接收先前的状态作为第一个参数，并将应用更新时的 props 作为第二个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确✅</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function">(<span class="params">prevState, props</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">counter</span>: prevState.<span class="property">counter</span> + props.<span class="property">increment</span>,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="84-React-中的严格模式是什么？"><a href="#84-React-中的严格模式是什么？" class="headerlink" title="84. React 中的严格模式是什么？"></a>84. React 中的严格模式是什么？</h2><p><code>React.StrictMode</code> 是一个有用的组件，用于暴露应用程序中的潜在问题。就像 <code>&lt;Fragment&gt;</code>，<code>&lt;StrictMode&gt;</code>不会渲染任何额外的 DOM 元素。它为其后代激活了额外的检查和警告。这些检查只适用于开发模式。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ExampleApplication</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Header</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">ComponentOne</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">          <span class="tag">&lt;<span class="name">ComponentTwo</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">React.StrictMode</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;<span class="name">Footer</span> /&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，严格模式检查只适用于 <code>&lt;ComponentOne&gt;</code> 和 <code>&lt;ComponentTwo&gt;</code> 组件。</p>
<h2 id="85-为什么-isMounted-是一个反模式，正确的解决方案是什么？"><a href="#85-为什么-isMounted-是一个反模式，正确的解决方案是什么？" class="headerlink" title="85. 为什么 isMounted() 是一个反模式，正确的解决方案是什么？"></a>85. 为什么 <code>isMounted()</code> 是一个反模式，正确的解决方案是什么？</h2><p><code>isMounted()</code> 的主要用例是避免在组件被卸载后调用 <code>setState()</code>，因为它会发出警告。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">isMounted</span>()) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;...&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用 <code>setState()</code> 之前检查 <code>isMounted()</code> 确实可以消除警告，但这也违背了警告的目的。使用 <code>isMounted()</code> 是一种代码异味，因为你检查的唯一原因是你认为你可能在组件卸载后还持有一个引用。</p>
<p>一个最佳的解决方案是找到在组件卸载后可能调用 <code>setState()</code> 的地方，并修复它们。这种情况通常是由于回调引起的，当一个组件在等待一些数据时，在数据到达之前被卸载。理想情况下，任何回调都应该在 <code>componentWillUnmount()</code> 中取消（在解除挂载之前）。</p>
<blockquote>
<p>代码异味 (Code smell)：程序开发领域，代码中的任何可能导致深层次问题的症状都可以叫做代码异味。 通常，在对代码做简短的反馈迭代时，代码异味会暴露出一些深层次的问题，这里的反馈迭代，是指以一种小范围的、可控的方式重构代码。</p>
</blockquote>
<h2 id="86-React-中支持哪些指针事件？"><a href="#86-React-中支持哪些指针事件？" class="headerlink" title="86. React 中支持哪些指针事件？"></a>86. React 中支持哪些指针事件？</h2><p>指针事件提供了一个处理所有输入事件的统一方法。在过去，我们有一个鼠标和各自的事件监听器来处理它们，但现在我们有许多设备与拥有鼠标不相关，如带有触摸表面的手机或笔。我们需要记住，这些事件只能在支持 Pointer Events 规范的浏览器中工作。</p>
<p>以下事件类型现在在 React DOM 中可用。</p>
<ol>
<li><code>onPointerDown</code></li>
<li><code>onPointerMove</code></li>
<li><code>onPointerUp</code></li>
<li><code>onPointerCancel</code></li>
<li><code>onGotPointerCapture</code></li>
<li><code>onLostPointerCapture</code></li>
<li><code>onPointerEnter</code></li>
<li><code>onPointerLeave</code></li>
<li><code>onPointerOver</code></li>
<li><code>onPointerOut</code></li>
</ol>
<h2 id="87-为什么组件名称要以大写字母开头？"><a href="#87-为什么组件名称要以大写字母开头？" class="headerlink" title="87. 为什么组件名称要以大写字母开头？"></a>87. 为什么组件名称要以大写字母开头？</h2><p>如果你使用 JSX 渲染你的组件，该组件的名称必须以大写字母开头，否则 React 将抛出一个错误，即未识别的标签。这个惯例是因为只有 HTML 元素和 SVG 标签可以以小写字母开头。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SomeComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="comment">// 掘金不止，代码不停</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以定义名称以小写字母开头的组件类，但当它被导入时，它应该是大写字母。在这里，小写就可以了。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">myComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> myComponent;</span><br></pre></td></tr></table></figure>

<p>而当导入另一个文件时，它应该以大写字母开始。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">MyComponent</span> <span class="keyword">from</span> <span class="string">&#x27;./MyComponent&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="关于-React-组件的命名，有哪些例外情况？"><a href="#关于-React-组件的命名，有哪些例外情况？" class="headerlink" title="关于 React 组件的命名，有哪些例外情况？"></a>关于 React 组件的命名，有哪些例外情况？</h3><p>组件名称应以大写字母开头，但这一惯例也有少数例外。带点的小写标签名（属性访问器）仍被认为是有效的组件名。</p>
<p>例如，下面的标签可以被编译成一个有效的组件。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">return</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">obj.component</span> /&gt;</span></span> <span class="comment">// `React.createElement(obj.component)`</span></span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="88-React-v16-中支持自定义-DOM-属性吗？"><a href="#88-React-v16-中支持自定义-DOM-属性吗？" class="headerlink" title="88. React v16 中支持自定义 DOM 属性吗？"></a>88. React v16 中支持自定义 DOM 属性吗？</h2><p>是的，在过去，React 习惯于忽略未知的 DOM 属性。如果你写的 JSX 有一个 React 不认识的属性，React 会直接跳过它。</p>
<p>例如，让我们看一下下面的属性。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div mycustomattribute=&#123;<span class="string">&#x27;something&#x27;</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>用 React v15 渲染一个空的 div 到 DOM 上。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 React v16 中，任何未知的属性最终都会出现在 DOM 中。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">mycustomattribute</span>=<span class="string">&quot;something&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>这对于提供浏览器特定的非标准属性，尝试新的 DOM API，以及与有主见的第三方库集成是非常有用的。</p>
<h2 id="89-constructor-和-getInitialState-的区别是什么？"><a href="#89-constructor-和-getInitialState-的区别是什么？" class="headerlink" title="89. constructor 和 getInitialState 的区别是什么？"></a>89. constructor 和 getInitialState 的区别是什么？</h2><p>当使用 ES6 类时，你应该在构造函数中初始化状态，而当使用 <code>React.createClass()</code> 时，应该在 <code>getInitialState()</code> 方法中初始化状态。</p>
<p><strong>使用 ES6 类：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="comment">/* 初始化状态 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>React.createClass()</code>：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">MyComponent</span> = <span class="title class_">React</span>.<span class="title function_">createClass</span>(&#123;</span><br><span class="line">  <span class="title function_">getInitialState</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">/* 初始化状态 */</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> <code>React.createClass()</code> 在 React v16 中已被废弃并删除。请使用普通的 JavaScript 类来代替。</p>
<h2 id="90-你能在不调用-setState-的情况下强制一个组件重新渲染吗？"><a href="#90-你能在不调用-setState-的情况下强制一个组件重新渲染吗？" class="headerlink" title="90. 你能在不调用 setState 的情况下强制一个组件重新渲染吗？"></a>90. 你能在不调用 setState 的情况下强制一个组件重新渲染吗？</h2><p>默认情况下，当你的组件的状态或 props 改变时，你的组件会重新渲染。如果你的 <code>render()</code> 方法依赖于其他数据，你可以通过调用 <code>forceUpdate()</code> 告诉 React 该组件需要重新渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">component.<span class="title function_">forceUpdate</span>(callback);</span><br></pre></td></tr></table></figure>

<p>建议避免使用 <code>forceUpdate()</code>，只在 <code>render()</code> 中读取<code>this.props</code> 和 <code>this.state</code>。</p>
<h2 id="91-在-React-中使用-ES6-类的，super-和-super-props-之间有什么区别？"><a href="#91-在-React-中使用-ES6-类的，super-和-super-props-之间有什么区别？" class="headerlink" title="91. 在  React 中使用 ES6 类的，super() 和 super(props) 之间有什么区别？"></a>91. 在  React 中使用 ES6 类的，<code>super()</code> 和 <code>super(props)</code> 之间有什么区别？</h2><p>当你想在 <code>constructor()</code> 中访问 <code>this.props</code> 时，你应该把 props 传给 <code>super()</code> 方法。</p>
<p><strong>使用 <code>super(props)</code>：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>); <span class="comment">// &#123; name: &#x27;John&#x27;, ... &#125;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 <code>super()</code>：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>();</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">props</span>); <span class="comment">// undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>constructor()</code> 之外，两者都会显示相同的 <code>this.props</code> 的值。</p>
<h2 id="92-如何在-JSX-内循环？"><a href="#92-如何在-JSX-内循环？" class="headerlink" title="92. 如何在 JSX 内循环？"></a>92. 如何在 JSX 内循环？</h2><p>你可以简单地使用 <code>Array.prototype.map</code> 与 ES6 箭头函数语法。</p>
<p>例如，对象的 <code>items</code> 数组被映射成组件的数组。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;tbody&gt;</span><br><span class="line">  &#123;items.<span class="title function_">map</span>(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">key</span>=<span class="string">&#123;item.id&#125;</span> <span class="attr">name</span>=<span class="string">&#123;item.name&#125;</span> /&gt;</span></span></span><br><span class="line">  ))&#125;</span><br><span class="line">&lt;/tbody&gt;</span><br></pre></td></tr></table></figure>

<p>但你不能用 <code>for</code> 循环来迭代。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;tbody&gt;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; items.<span class="property">length</span>; i++) &#123;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">SomeComponent</span> <span class="attr">key</span>=<span class="string">&#123;items[i].id&#125;</span> <span class="attr">name</span>=<span class="string">&#123;items[i].name&#125;</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line">&lt;/tbody&gt;</span><br></pre></td></tr></table></figure>

<p>这是因为 JSX 标签被转换为函数调用，而且你不能在表达式中使用语句。这可能会改变，因为 <code>do</code> 表达式是第一阶段的建议。</p>
<h2 id="93-你如何在属性引号中访问-props？"><a href="#93-你如何在属性引号中访问-props？" class="headerlink" title="93. 你如何在属性引号中访问 props？"></a>93. 你如何在属性引号中访问 props？</h2><p>React（或 JSX）不支持属性值内的变量插值。下面的表示方法就不能用了。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img className=<span class="string">&quot;image&quot;</span> src=<span class="string">&quot;images/&#123;this.props.image&#125;&quot;</span> /&gt;</span><br></pre></td></tr></table></figure>

<p>但你可以把任何 JS 表达式放在大括号内作为整个属性值。所以下面的表达式是有效的。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img className=<span class="string">&quot;image&quot;</span> src=&#123;<span class="string">&#x27;images/&#x27;</span> + <span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">image</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<p>使用模板字符串也可以。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img className=<span class="string">&quot;image&quot;</span> src=&#123;<span class="string">`images/<span class="subst">$&#123;<span class="variable language_">this</span>.props.image&#125;</span>`</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>

<h2 id="94-什么是带-shape-的-React-原型数组？"><a href="#94-什么是带-shape-的-React-原型数组？" class="headerlink" title="94. 什么是带 shape 的 React 原型数组？"></a>94. 什么是带 shape 的 React 原型数组？</h2><p>如果你想把一个对象数组传递给一个具有特定 shape 的组件，那么使用 <code>React.PropTypes.shape()</code> 作为 <code>React.PropTypes.arrayOf()</code> 的一个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">ReactComponent</span>.<span class="property">propTypes</span> = &#123;</span><br><span class="line">  <span class="attr">arrayWithShape</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">arrayOf</span>(</span><br><span class="line">    <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="title function_">shape</span>(&#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">string</span>.<span class="property">isRequired</span>,</span><br><span class="line">      <span class="attr">fontSize</span>: <span class="title class_">React</span>.<span class="property">PropTypes</span>.<span class="property">number</span>.<span class="property">isRequired</span>,</span><br><span class="line">    &#125;),</span><br><span class="line">  ).<span class="property">isRequired</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="95-如何有条件地应用类属性？"><a href="#95-如何有条件地应用类属性？" class="headerlink" title="95. 如何有条件地应用类属性？"></a>95. 如何有条件地应用类属性？</h2><p>你不应该在引号内使用大括号，因为它将被计算为一个字符串。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=<span class="string">&quot;btn-panel &#123;this.props.visible ? &#x27;show&#x27; : &#x27;hidden&#x27;&#125;&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<p>相反，你需要把大括号移到外面（别忘了在类名之间包括空格）。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&#123;<span class="string">&#x27;btn-panel &#x27;</span> + (<span class="variable language_">this</span>.<span class="property">props</span>.<span class="property">visible</span> ? <span class="string">&#x27;show&#x27;</span> : <span class="string">&#x27;hidden&#x27;</span>)&#125;&gt;</span><br></pre></td></tr></table></figure>

<p>模板字符串也可以使用。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div className=&#123;<span class="string">`btn-panel <span class="subst">$&#123;<span class="variable language_">this</span>.props.visible ? <span class="string">&#x27;show&#x27;</span> : <span class="string">&#x27;hidden&#x27;</span>&#125;</span>`</span>&#125;&gt;</span><br></pre></td></tr></table></figure>

<h2 id="96-React-和-ReactDOM-之间有什么区别？"><a href="#96-React-和-ReactDOM-之间有什么区别？" class="headerlink" title="96. React 和 ReactDOM 之间有什么区别？"></a>96. React 和 ReactDOM 之间有什么区别？</h2><p><code>react</code> 包包含 <code>React.createElement()</code>、<code>React.Component</code>、<code>React.Children</code>, 以及其他与元素和组件类相关的帮助函数。你可以把这些看作是你构建组件所需要的同构或通用助手。<code>react-dom</code> 包包含 <code>ReactDOM.render()</code>，在 <code>react-dom/server</code> 中，我们有 <code>ReactDOMServer.renderToString()</code> 和 <code>ReactDOMServer.renderToStaticMarkup()</code> 的服务器端渲染支持。</p>
<h2 id="97-为什么-ReactDOM-要从-React-中分离出来？"><a href="#97-为什么-ReactDOM-要从-React-中分离出来？" class="headerlink" title="97. 为什么 ReactDOM 要从 React 中分离出来？"></a>97. 为什么 ReactDOM 要从 React 中分离出来？</h2><p>React 团队致力于将所有与 DOM 相关的功能提取到一个单独的库中，称为 ReactDOM。React v0.14 是第一个分割库的版本。通过查看一些包，<code>react-native</code>、<code>react-art</code>、<code>react-canvas</code>和 <code>react-three</code>，已经很清楚，React 的优秀和本质与浏览器或 DOM 无关。</p>
<p>为了建立更多 React 可以渲染的环境，React 团队计划将主 React 包分成两个：<code>react</code> 和 <code>react-dom</code>。这就为编写可以在网络版 React 和 React Native 之间共享的组件铺平了道路。</p>
<h2 id="98-如何使用-React-label-元素？"><a href="#98-如何使用-React-label-元素？" class="headerlink" title="98. 如何使用 React label 元素？"></a>98. 如何使用 React label 元素？</h2><p>如果你试图用标准的 <code>for</code> 属性渲染一个绑定在文本输入上的 <code>&lt;label&gt;</code> 元素，那么它产生的 HTML 会缺少该属性，并在控制台打印出警告。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;label <span class="keyword">for</span>=&#123;<span class="string">&#x27;user&#x27;</span>&#125;&gt;&#123;<span class="string">&#x27;User&#x27;</span>&#125;&lt;/label&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#123;</span>&#x27;<span class="attr">text</span>&#x27;&#125; <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">user</span>&#x27;&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>由于 <code>for</code> 在 JavaScript 中是一个保留关键字，我们可以使用 <code>htmlFor</code> 代替。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;label htmlFor=&#123;<span class="string">&#x27;user&#x27;</span>&#125;&gt;&#123;<span class="string">&#x27;User&#x27;</span>&#125;&lt;/label&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&#123;</span>&#x27;<span class="attr">text</span>&#x27;&#125; <span class="attr">id</span>=<span class="string">&#123;</span>&#x27;<span class="attr">user</span>&#x27;&#125; /&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="99-如何组合多个内联样式对象？"><a href="#99-如何组合多个内联样式对象？" class="headerlink" title="99. 如何组合多个内联样式对象？"></a>99. 如何组合多个内联样式对象？</h2><p>你可以在常规 React 中使用展开语法。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button style=&#123;&#123; ...styles.<span class="property">panel</span>.<span class="property">button</span>, ...styles.<span class="property">panel</span>.<span class="property">submitButton</span> &#125;&#125;&gt;</span><br><span class="line">  &#123;<span class="string">&#x27;Submit&#x27;</span>&#125;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<p>如果你使用的是 React Native，那么你可以使用数组符号。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button style=&#123;[styles.<span class="property">panel</span>.<span class="property">button</span>, styles.<span class="property">panel</span>.<span class="property">submitButton</span>]&#125;&gt;</span><br><span class="line">  &#123;<span class="string">&#x27;Submit&#x27;</span>&#125;</span><br><span class="line">&lt;/button&gt;</span><br></pre></td></tr></table></figure>

<h2 id="100-如何在浏览器调整大小时重新渲染视图？"><a href="#100-如何在浏览器调整大小时重新渲染视图？" class="headerlink" title="100. 如何在浏览器调整大小时重新渲染视图？"></a>100. 如何在浏览器调整大小时重新渲染视图？</h2><p>你可以在 <code>componentDidMount()</code> 中监听 <code>resize</code> 事件，然后更新尺寸（<code>width</code> 和 <code>height</code>）。你应该在 <code>componentWillUnmount()</code> 方法中移除监听器。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WindowDimensions</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">updateDimensions</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="variable language_">this</span>.<span class="property">updateDimensions</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">window</span>.<span class="title function_">removeEventListener</span>(<span class="string">&#x27;resize&#x27;</span>, <span class="variable language_">this</span>.<span class="property">updateDimensions</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateDimensions = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">width</span>: <span class="variable language_">window</span>.<span class="property">innerWidth</span>, <span class="attr">height</span>: <span class="variable language_">window</span>.<span class="property">innerHeight</span> &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.width&#125; x &#123;this.state.height&#125;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="101-setState-和-replaceState-方法之间的区别是什么？"><a href="#101-setState-和-replaceState-方法之间的区别是什么？" class="headerlink" title="101. setState() 和 replaceState() 方法之间的区别是什么？"></a>101. <code>setState()</code> 和 <code>replaceState()</code> 方法之间的区别是什么？</h2><p>当你使用 <code>setState()</code> 时，当前和之前的状态被合并。 <code>replaceState()</code> 抛出当前的状态，只用你提供的内容来替换它。通常 <code>setState()</code> 会被使用，除非你真的因为某些原因需要删除所有之前的键。你也可以在 <code>setState()</code> 中把状态设置为 <code>false</code>&#x2F;<code>null</code>，而不是使用 <code>replaceState()</code>。</p>
<h2 id="102-如何监听状态变化？"><a href="#102-如何监听状态变化？" class="headerlink" title="102. 如何监听状态变化？"></a>102. 如何监听状态变化？</h2><p>当状态发生变化时，<code>componentDidUpdate</code> 生命周期方法将被调用。你可以将提供的状态和 props 值与当前的状态和 props 进行比较，以确定是否有意义的变化。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(object prevProps, object prevState)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong> 以前的 ReactJS 版本也使用 <code>componentWillUpdate(object nextProps, object nextState)</code> 监听状态改变。在最新的版本中，它已被弃用。</p>
<h2 id="103-在-React-状态下，删除数组元素的推荐方法是什么？"><a href="#103-在-React-状态下，删除数组元素的推荐方法是什么？" class="headerlink" title="103. 在 React 状态下，删除数组元素的推荐方法是什么？"></a>103. 在 React 状态下，删除数组元素的推荐方法是什么？</h2><p>更好的方法是使用 <code>Array.prototype.filter()</code> 方法。</p>
<p>例如，让我们创建一个 <code>removeItem()</code> 方法来更新状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">removeItem</span>(<span class="params">index</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">data</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">item, i</span>) =&gt;</span> i !== index)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="104-有没有可能在不渲染-HTML-的情况下使用-React-呢？"><a href="#104-有没有可能在不渲染-HTML-的情况下使用-React-呢？" class="headerlink" title="104. 有没有可能在不渲染 HTML 的情况下使用 React 呢？"></a>104. 有没有可能在不渲染 HTML 的情况下使用 React 呢？</h2><p>在最新版本（&gt;&#x3D;16.2）中可以实现。以下是可用选项。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">React.Fragment</span>&gt;</span><span class="tag">&lt;/<span class="name">React.Fragment</span>&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;&gt;</span><span class="tag">&lt;/&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>返回 <code>undefined</code> 是不行的。</p>
<h2 id="105-如何用-React-打印漂亮的-JSON？"><a href="#105-如何用-React-打印漂亮的-JSON？" class="headerlink" title="105. 如何用 React 打印漂亮的 JSON？"></a>105. 如何用 React 打印漂亮的 JSON？</h2><p>我们可以使用 <code>&lt;pre&gt;</code> 标签，这样可以保留 <code>JSON.stringify()</code> 的格式。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">&#x27;John&#x27;</span>, <span class="attr">age</span>: <span class="number">42</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>&#123;JSON.stringify(data, null, 2)&#125;<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">React</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">User</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;container&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="106-为什么你不能在-React-中更新-props？"><a href="#106-为什么你不能在-React-中更新-props？" class="headerlink" title="106. 为什么你不能在 React 中更新 props？"></a>106. 为什么你不能在 React 中更新 props？</h2><p>React 的理念是，props 应该是<strong>不可变的</strong>和<strong>自上而下</strong>的。这意味着父组件可以向子组件发送任何 props 值，但子组件不能修改收到的 props。</p>
<h2 id="107-如何在页面加载时聚焦一个输入框？"><a href="#107-如何在页面加载时聚焦一个输入框？" class="headerlink" title="107. 如何在页面加载时聚焦一个输入框？"></a>107. 如何在页面加载时聚焦一个输入框？</h2><p>你可以通过为 <code>input</code> 元素创建 ref 并在 <code>componentDidMount()</code> 中使用它。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">nameInput</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">nameInput</span>.<span class="title function_">focus</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">defaultValue</span>=<span class="string">&#123;</span>&quot;<span class="attr">Won</span>&#x27;<span class="attr">t</span> <span class="attr">focus</span>&quot;&#125; /&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="language-xml">          <span class="attr">ref</span>=<span class="string">&#123;input</span> =&gt;</span> (this.nameInput = input)&#125;</span></span><br><span class="line"><span class="language-xml">          defaultValue=&#123;&#x27;Will focus&#x27;&#125;</span></span><br><span class="line"><span class="language-xml">        /&gt;</span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>));</span><br></pre></td></tr></table></figure>

<h2 id="108-更新状态中的对象的方式有哪些？"><a href="#108-更新状态中的对象的方式有哪些？" class="headerlink" title="108. 更新状态中的对象的方式有哪些？"></a>108. 更新状态中的对象的方式有哪些？</h2><ol>
<li><strong>合并状态和对象后调用 <code>setState()</code>：</strong></li>
</ol>
<ul>
<li>使用 <code>Object.assign()</code> 创建对象的拷贝：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">user</span>, &#123; <span class="attr">age</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; user &#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li>使用展开操作符：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> user = &#123; ...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">user</span>, <span class="attr">age</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; user &#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>调用 <code>setState()</code> 时传入函数：</strong></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="title function_">setState</span>(<span class="function"><span class="params">prevState</span> =&gt;</span> (&#123;</span><br><span class="line">  <span class="attr">user</span>: &#123;</span><br><span class="line">    ...prevState.<span class="property">user</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">42</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="109-我们如何在浏览器中查看运行时的-React-的版本？"><a href="#109-我们如何在浏览器中查看运行时的-React-的版本？" class="headerlink" title="109. 我们如何在浏览器中查看运行时的 React 的版本？"></a>109. 我们如何在浏览器中查看运行时的 React 的版本？</h2><p>你可以使用 <code>React.version</code> 来获取版本。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="variable constant_">REACT_VERSION</span> = <span class="title class_">React</span>.<span class="property">version</span>;</span><br><span class="line"></span><br><span class="line"><span class="title class_">ReactDOM</span>.<span class="title function_">render</span>(</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;`React version: $&#123;REACT_VERSION&#125;`&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;app&#x27;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h2 id="110-在-create-react-app-中包含-polyfills-的方法是什么？"><a href="#110-在-create-react-app-中包含-polyfills-的方法是什么？" class="headerlink" title="110. 在 create-react-app 中包含 polyfills 的方法是什么？"></a>110. 在 <code>create-react-app</code> 中包含 polyfills 的方法是什么？</h2><p>有一些方法可以在 create-react-app 中包含 polyfills。</p>
<ol>
<li><strong>手动从 <code>core-js</code> 引入：</strong></li>
</ol>
<p>创建一个名为（类似）<code>polyfills.js</code> 的文件并将其导入根 <code>index.js</code> 文件。运行 <code>npm install core-js</code> 或 <code>yarn add core-js</code> 并导入你所需要的特定功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js/fn/array/find&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js/fn/array/includes&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;core-js/fn/number/is-nan&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><strong>使用 Polyfill 服务：</strong></li>
</ol>
<p>使用 polyfill.io CDN，通过在 <code>index.html</code> 中添加这一行来检索自定义的、针对浏览器的 polyfills。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.polyfill.io/v2/polyfill.min.js?features=default,Array.prototype.includes&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上面的脚本中，我们必须明确请求 <code>Array.prototype.includes</code> 功能，因为它不包括在默认功能集中。</p>
<h2 id="111-如何在-create-react-app-中使用-https-而不是-http？"><a href="#111-如何在-create-react-app-中使用-https-而不是-http？" class="headerlink" title="111. 如何在 create-react-app 中使用 https 而不是 http？"></a>111. 如何在 create-react-app 中使用 https 而不是 http？</h2><p>你只需要是用 <code>HTTPS=true</code> 配置。你可以编辑 <code>package.json</code> scripts 部分：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"> <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;set HTTPS=true &amp;&amp; react-scripts start&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>或者运行 <code>set HTTPS=true &amp;&amp; npm start</code></p>
<h2 id="112-如何避免在-create-react-app-中使用相对路径导入？"><a href="#112-如何避免在-create-react-app-中使用相对路径导入？" class="headerlink" title="112. 如何避免在 create-react-app 中使用相对路径导入？"></a>112. 如何避免在 create-react-app 中使用相对路径导入？</h2><p>在项目里根目录创建一个叫 <code>.env</code> 的文件并写入导入的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NODE_PATH=src/app</span><br></pre></td></tr></table></figure>

<p>然后重启调试服务器。现在你应该能够在 <code>src/app</code> 目录下不使用相对路径导入任何东西。</p>
<h2 id="113-如何在-React-Router-中添加-Google-Analytics？"><a href="#113-如何在-React-Router-中添加-Google-Analytics？" class="headerlink" title="113. 如何在 React Router 中添加 Google Analytics？"></a>113. 如何在 React Router 中添加 Google Analytics？</h2><p>在 <code>history</code> 对象上添加一个监听器，以记录每个页面的浏览。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">history.<span class="title function_">listen</span>(<span class="keyword">function</span>(<span class="params">location</span>) &#123;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">ga</span>(<span class="string">&#x27;set&#x27;</span>, <span class="string">&#x27;page&#x27;</span>, location.<span class="property">pathname</span> + location.<span class="property">search</span>);</span><br><span class="line">  <span class="variable language_">window</span>.<span class="title function_">ga</span>(<span class="string">&#x27;send&#x27;</span>, <span class="string">&#x27;pageview&#x27;</span>, location.<span class="property">pathname</span> + location.<span class="property">search</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="114-如何每秒更新一次组件？"><a href="#114-如何每秒更新一次组件？" class="headerlink" title="114. 如何每秒更新一次组件？"></a>114. 如何每秒更新一次组件？</h2><p>你需要使用 <code>setInterval()</code> 来触发变化，但你也需要在组件卸载时清除计时器以防止错误和内存泄漏。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">interval</span> = <span class="built_in">setInterval</span>(<span class="function">() =&gt;</span> <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; <span class="attr">time</span>: <span class="title class_">Date</span>.<span class="title function_">now</span>() &#125;), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">componentWillUnmount</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">clearInterval</span>(<span class="variable language_">this</span>.<span class="property">interval</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="115-如何在-React-中对内联样式使用-CSS-厂商前缀？"><a href="#115-如何在-React-中对内联样式使用-CSS-厂商前缀？" class="headerlink" title="115. 如何在 React 中对内联样式使用 CSS 厂商前缀？"></a>115. 如何在 React 中对内联样式使用 CSS 厂商前缀？</h2><p>React 不会自动应用 CSS 厂商前缀。你需要手动添加 CSS 厂商前缀。</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div</span><br><span class="line">  style=&#123;&#123;</span><br><span class="line">    <span class="attr">transform</span>: <span class="string">&#x27;rotate(90deg)&#x27;</span>,</span><br><span class="line">    <span class="title class_">WebkitTransform</span>: <span class="string">&#x27;rotate(90deg)&#x27;</span>, <span class="comment">// 注意大写 &#x27;W&#x27;</span></span><br><span class="line">    <span class="attr">msTransform</span>: <span class="string">&#x27;rotate(90deg)&#x27;</span>, <span class="comment">// &#x27;ms&#x27; 是全小写</span></span><br><span class="line">  &#125;&#125;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>

<h2 id="116-如何使用-React-和-ES6-导入和导出组件？"><a href="#116-如何使用-React-和-ES6-导入和导出组件？" class="headerlink" title="116. 如何使用 React 和 ES6 导入和导出组件？"></a>116. 如何使用 React 和 ES6 导入和导出组件？</h2><p>你应该使用默认值来导出组件</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">User</span> <span class="keyword">from</span> <span class="string">&#x27;user&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">MyProfile</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">User</span> <span class="attr">type</span>=<span class="string">&quot;customer&quot;</span>&gt;</span>//...<span class="tag">&lt;/<span class="name">User</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了导出指定符，MyProfile 将成为成员并导出到这个模块，同样可以在其他组件中导入而不提及名称。</p>
<h2 id="117-为什么组件构造器只会被调用一次？"><a href="#117-为什么组件构造器只会被调用一次？" class="headerlink" title="117. 为什么组件构造器只会被调用一次？"></a>117. 为什么组件构造器只会被调用一次？</h2><p>React 的 reconciliation（协调） 算法假定，在没有任何相反信息的情况下，如果一个自定义组件在随后的渲染中出现在相同的地方，它就是之前的那个组件，所以 React 重用之前的实例而不是创建一个新的。</p>
<h2 id="118-如何在-React-中定义常量？"><a href="#118-如何在-React-中定义常量？" class="headerlink" title="118. 如何在 React 中定义常量？"></a>118. 如何在 React 中定义常量？</h2><p>你可以使用 ES7 的 <code>静态</code> 字段来定义常量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="variable constant_">DEFAULT_PAGINATION</span> = <span class="number">10</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>静态字段是类字段第三阶段提案的一部分。</p>
<h2 id="119-如何在-React-中以编程方式触发点击事件？"><a href="#119-如何在-React-中以编程方式触发点击事件？" class="headerlink" title="119. 如何在 React 中以编程方式触发点击事件？"></a>119. 如何在 React 中以编程方式触发点击事件？</h2><p>你可以使用 ref props 通过回调获得对底层 <code>HTMLInputElement</code> 对象的引用，将该引用存储为类属性，然后使用该引用从事件处理程序中使用 <code>HTMLElement.click</code> 方法触发点击。</p>
<p>这可以分两步进行。</p>
<ol>
<li>在 render 方法中创建 ref：</li>
</ol>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input ref=&#123;<span class="function"><span class="params">input</span> =&gt;</span> (<span class="variable language_">this</span>.<span class="property">inputElement</span> = input)&#125; /&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在你的事件处理程序中应用点击事件。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">this</span>.<span class="property">inputElement</span>.<span class="title function_">click</span>();</span><br></pre></td></tr></table></figure>

<h2 id="120-有可能在纯-React-中使用-async-await-吗？"><a href="#120-有可能在纯-React-中使用-async-await-吗？" class="headerlink" title="120. 有可能在纯 React 中使用 async&#x2F;await 吗？"></a>120. 有可能在纯 React 中使用 async&#x2F;await 吗？</h2><p>如果你想在 React 中使用 <code>async</code>&#x2F;<code>await</code>，你将需要 Babel 和 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://babeljs.io/docs/en/babel-plugin-transform-async-to-generator">transform-async-to-generator</a> 插件。React Native 已经包含了 Babel 和一系列的转换功能。</p>
<details class="folding-tag" green><summary> 121. React 的常见文件夹结构是什么？ </summary>
              <div class='content'>
              <p>React 项目文件结构有两种常见做法。</p><ol><li><strong>按特性或路由分组：</strong>*</li></ol><p>一种常见的项目结构方式是将 CSS、JS 和测试放在一起，按特性或路由分组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">common/</span><br><span class="line">├─ Avatar.js</span><br><span class="line">├─ Avatar.css</span><br><span class="line">├─ APIUtils.js</span><br><span class="line">└─ APIUtils.test.js</span><br><span class="line">feed/</span><br><span class="line">├─ index.js</span><br><span class="line">├─ Feed.js</span><br><span class="line">├─ Feed.css</span><br><span class="line">├─ FeedStory.js</span><br><span class="line">├─ FeedStory.test.js</span><br><span class="line">└─ FeedAPI.js</span><br><span class="line">profile/</span><br><span class="line">├─ index.js</span><br><span class="line">├─ Profile.js</span><br><span class="line">├─ ProfileHeader.js</span><br><span class="line">├─ ProfileHeader.css</span><br><span class="line">└─ ProfileAPI.js</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>按文件类型分组：</strong></li></ol><p>另一种流行的项目结构方式是将类似的文件分组。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">api/</span><br><span class="line">├─ APIUtils.js</span><br><span class="line">├─ APIUtils.test.js</span><br><span class="line">├─ ProfileAPI.js</span><br><span class="line">└─ UserAPI.js</span><br><span class="line">components/</span><br><span class="line">├─ Avatar.js</span><br><span class="line">├─ Avatar.css</span><br><span class="line">├─ Feed.js</span><br><span class="line">├─ Feed.css</span><br><span class="line">├─ FeedStory.js</span><br><span class="line">├─ FeedStory.test.js</span><br><span class="line">├─ Profile.js</span><br><span class="line">├─ ProfileHeader.js</span><br><span class="line">└─ ProfileHeader.css</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" green><summary> 122. 有哪些流行的动画包？ </summary>
              <div class='content'>
              <p>React Transition Group 和 React Motion 是 React 生态系统中流行的动画包。</p>
              </div>
            </details>

<details class="folding-tag" green><summary> 123. 样式模块的好处是什么？ </summary>
              <div class='content'>
              <p>我们建议避免在组件中硬编码样式值。任何可能在不同的 UI 组件中使用的值都应该被提取到它们自己的模块中。</p><p>例如，这些样式可以被提取到一个单独的组件中。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> colors = &#123;</span><br><span class="line">  white,</span><br><span class="line">  black,</span><br><span class="line">  blue,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> space = [<span class="number">0</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span>];</span><br></pre></td></tr></table></figure><p>然后在其他组件中单独导入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; space, colors &#125; <span class="keyword">from</span> <span class="string">&#x27;./styles&#x27;</span>;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" green><summary> 124. 有哪些流行的 React 专用 linter？ </summary>
              <div class='content'>
              <p>ESLint 是一个很流行的 JavaScript linter。有一些插件可以用来分析特定的代码风格。其中最常见的 React 插件是一个名为 <code>eslint-plugin-react</code> 的 npm 包。默认情况下，它将检查一些最佳实践，其规则是检查从迭代器中的键到一整套道具类型的东西。</p><p>另一个流行的插件是 <code>eslint-plugin-jsx-a11y</code>，它将帮助修复可访问性方面的常见问题。由于 JSX 提供了与常规 HTML 稍有不同的语法，例如 <code>alt</code> 文本和 <code>tabindex</code> 的问题将不会被常规插件发现。</p>
              </div>
            </details>

<details class="folding-tag" green><summary> 125. 如何进行 AJAX 调用，应该在哪个组件的生命周期方法中进行 AJAX 调用？ </summary>
              <div class='content'>
              <p>你可以使用 AJAX 库，如 Axios、jQuery AJAX，以及浏览器内置的 <code>fetch</code>。你应该在 <code>componentDidMount()</code> 生命周期方法中获取数据。这样你就可以在获取数据时使用 <code>setState()</code> 来更新你的组件。</p><p>例如，从 API 获取的雇员名单并设置本地状态。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyComponent</span> <span class="keyword">extends</span> <span class="title class_ inherited__">React.Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">employees</span>: [],</span><br><span class="line">      <span class="attr">error</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">componentDidMount</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="title function_">fetch</span>(<span class="string">&#x27;https://api.example.com/items&#x27;</span>)</span><br><span class="line">      .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> res.<span class="title function_">json</span>())</span><br><span class="line">      .<span class="title function_">then</span>(</span><br><span class="line">        <span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">            <span class="attr">employees</span>: result.<span class="property">employees</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123; error &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">      );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; error, employees &#125; = <span class="variable language_">this</span>.<span class="property">state</span>;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span>Error: &#123;error.message&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          &#123;employees.map(employee =&gt; (</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;employee.name&#125;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">              &#123;employee.name&#125;-&#123;employee.experience&#125;</span></span><br><span class="line"><span class="language-xml">            <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">          ))&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
              </div>
            </details>

<details class="folding-tag" green><summary> 126. 什么是 render props？ </summary>
              <div class='content'>
              <p><strong>render props</strong> 是一种简单的技术，使用一个 props 在组件之间共享代码，其值是一个函数。下面的组件使用渲染 props，它返回一个 React 元素。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="title class_">DataProvider</span> render=&#123;<span class="function"><span class="params">data</span> =&gt;</span> <span class="language-xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;`Hello $&#123;data.target&#125;`&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>&#125; /&gt;</span><br></pre></td></tr></table></figure><p>React Router 和 DownShift 等库正在使用这种模式。</p>
              </div>
            </details>
</div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div><div id="comment-switch"><span class="first-comment">Giscus</span><span class="switch-btn"></span><span class="second-comment">Livere</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div><div><div id="lv-container" data-id="city" data-uid="MTAyMC81NDMyMi8zMDc5Mw=="></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/07/17/K91TsgdoRabMtvw.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">紫竹</div><div class="author-info__description">怕什么真理无穷，进一寸有一寸的欢喜。</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">160</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">523</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">57</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/youngjuning"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/youngjuning/youngjuning.github.io" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:youngjuning@163.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="https://twitter.com/luozhu2021" rel="external nofollow noreferrer" target="_blank" title="推特"><i class="fab fa-twitter" style="color: #00acee;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content"><center><div style="font-size: 16px; font-weight: 600">Ask Me Anything</div><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cdn.jsdelivr.net/gh/youngjuning/images/202109211725265.png" alt="紫竹的微信" width="100%" /></center></div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/bf86f69dbf94/" title="忽略 incompatible engine node error"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/07/17/mnMagitJQlyNfHk.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="忽略 incompatible engine node error"/></a><div class="content"><a class="title" href="/bf86f69dbf94/" title="忽略 incompatible engine node error">忽略 incompatible engine node error</a><time datetime="2023-08-16T13:53:00.000Z" title="发表于 2023-08-16 21:53:00">2023-08-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/141618e1f8a1/" title="Antd form TextArea 隐藏右下角"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/07/17/mnMagitJQlyNfHk.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Antd form TextArea 隐藏右下角"/></a><div class="content"><a class="title" href="/141618e1f8a1/" title="Antd form TextArea 隐藏右下角">Antd form TextArea 隐藏右下角</a><time datetime="2023-08-05T07:00:00.000Z" title="发表于 2023-08-05 15:00:00">2023-08-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/18fc5bd5e9a2/" title="Antd Pro ModalFrom 使用记录"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/07/17/sHCFR6fanbPMwpD.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Antd Pro ModalFrom 使用记录"/></a><div class="content"><a class="title" href="/18fc5bd5e9a2/" title="Antd Pro ModalFrom 使用记录">Antd Pro ModalFrom 使用记录</a><time datetime="2023-08-04T07:00:00.000Z" title="发表于 2023-08-04 15:00:00">2023-08-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/e6c3e5bafb7d/" title="实现 sequelize 分页和条件查询"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/07/17/tjNbDh17cTQiJMB.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实现 sequelize 分页和条件查询"/></a><div class="content"><a class="title" href="/e6c3e5bafb7d/" title="实现 sequelize 分页和条件查询">实现 sequelize 分页和条件查询</a><time datetime="2023-08-02T04:30:00.000Z" title="发表于 2023-08-02 12:30:00">2023-08-02</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/a95721d19976/" title="Typescript 项目使用 Jest 入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/07/28/yn6xFzcPVOZjIDh.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Typescript 项目使用 Jest 入门"/></a><div class="content"><a class="title" href="/a95721d19976/" title="Typescript 项目使用 Jest 入门">Typescript 项目使用 Jest 入门</a><time datetime="2023-07-28T12:00:00.000Z" title="发表于 2023-07-28 20:00:00">2023-07-28</time></div></div></div></div><div class="card-widget ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-7962287588031867" data-ad-slot="1257383027" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><div class="card-widget card-categories"><div class="item-headline">
            <i class="fas fa-folder-open"></i>
            <span>分类</span>
            <a class="card-more-btn" href="/categories/" title="查看更多">
    <i class="fas fa-angle-right"></i></a>
            </div>
            <ul class="card-category-list" id="aside-cat-list">
            <li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Deno/"><span class="card-category-list-name">Deno</span><span class="card-category-list-count">2</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Golang/"><span class="card-category-list-name">Golang</span><span class="card-category-list-count">17</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Golang/Go-%E8%AF%AD%E8%A8%80%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/"><span class="card-category-list-name">Go 语言系列教程</span><span class="card-category-list-count">15</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Google/"><span class="card-category-list-name">Google</span><span class="card-category-list-count">8</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Google/Adsense/"><span class="card-category-list-name">Adsense</span><span class="card-category-list-count">7</span></a></li></ul></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Mac/"><span class="card-category-list-name">Mac</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/Rust/"><span class="card-category-list-name">Rust</span><span class="card-category-list-count">5</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/issues/"><span class="card-category-list-name">issues</span><span class="card-category-list-count">7</span></a><ul class="card-category-list child"><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/issues/GitHub/"><span class="card-category-list-name">GitHub</span><span class="card-category-list-count">1</span></a></li><li class="card-category-list-item "><a class="card-category-list-link" href="/categories/issues/antd/"><span class="card-category-list-name">antd</span><span class="card-category-list-count">3</span></a></li></ul></li>
            </ul></div><div class="card-widget card-tags"><div class="item-headline"><i class="fas fa-tags"></i><span>标签</span></div><div class="card-tag-cloud"><a href="/tags/SEO/" style="font-size: 1.15em; color: rgb(182, 77, 25)">SEO</a><a href="/tags/%E7%BD%91%E7%AB%99%E8%BF%90%E8%90%A5/" style="font-size: 1.15em; color: rgb(29, 181, 0)">网站运营</a><a href="/tags/%E5%8D%9A%E5%AE%A2%E5%8F%98%E7%8E%B0/" style="font-size: 1.15em; color: rgb(187, 33, 106)">博客变现</a><a href="/tags/JavaScript/" style="font-size: 1.42em; color: rgb(191, 152, 81)">JavaScript</a><a href="/tags/SPA/" style="font-size: 1.15em; color: rgb(193, 46, 181)">SPA</a><a href="/tags/%E7%8B%AC%E7%AB%8B%E7%AB%99/" style="font-size: 1.15em; color: rgb(35, 87, 139)">独立站</a><a href="/tags/%E8%B7%A8%E5%A2%83%E7%94%B5%E5%95%86/" style="font-size: 1.15em; color: rgb(3, 125, 73)">跨境电商</a><a href="/tags/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD/" style="font-size: 1.18em; color: rgb(42, 89, 6)">人工智能</a><a href="/tags/ChatGPT/" style="font-size: 1.15em; color: rgb(58, 165, 157)">ChatGPT</a><a href="/tags/%E6%8E%98%E9%87%91/" style="font-size: 1.35em; color: rgb(112, 139, 195)">掘金</a><a href="/tags/React-Native/" style="font-size: 1.45em; color: rgb(97, 74, 17)">React Native</a><a href="/tags/React/" style="font-size: 1.38em; color: rgb(34, 73, 56)">React</a><a href="/tags/%E7%BB%84%E4%BB%B6/" style="font-size: 1.18em; color: rgb(167, 0, 55)">组件</a><a href="/tags/nodejs/" style="font-size: 1.18em; color: rgb(26, 12, 175)">nodejs</a><a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 1.15em; color: rgb(113, 66, 40)">翻译</a><a href="/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%B8%88/" style="font-size: 1.18em; color: rgb(160, 73, 61)">信息系统项目管理师</a><a href="/tags/%E4%BF%A1%E6%81%AF%E5%8C%96/" style="font-size: 1.18em; color: rgb(186, 170, 121)">信息化</a><a href="/tags/%E4%BF%A1%E6%81%AF%E7%B3%BB%E7%BB%9F/" style="font-size: 1.18em; color: rgb(143, 115, 61)">信息系统</a><a href="/tags/%E8%BD%AF%E8%80%83%E9%AB%98%E9%A1%B9/" style="font-size: 1.18em; color: rgb(59, 63, 92)">软考高项</a><a href="/tags/TypeScript/" style="font-size: 1.32em; color: rgb(73, 1, 91)">TypeScript</a><a href="/tags/%E5%B9%B4%E4%B8%AD%E6%80%BB%E7%BB%93/" style="font-size: 1.18em; color: rgb(42, 147, 48)">年中总结</a><a href="/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/" style="font-size: 1.25em; color: rgb(1, 23, 178)">程序员</a><a href="/tags/%E6%9D%AD%E5%B7%9E/" style="font-size: 1.22em; color: rgb(80, 98, 73)">杭州</a><a href="/tags/%E7%B4%AB%E7%AB%B9%E7%9A%84%E5%8D%9A%E5%AE%A2/" style="font-size: 1.25em; color: rgb(154, 74, 97)">紫竹的博客</a><a href="/tags/%E7%B4%AB%E7%AB%B9/" style="font-size: 1.28em; color: rgb(148, 178, 17)">紫竹</a><a href="/tags/%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 1.22em; color: rgb(16, 160, 47)">前端开发</a><a href="/tags/%E8%B7%A8%E7%AB%AF%E5%BC%80%E5%8F%91/" style="font-size: 1.18em; color: rgb(166, 168, 52)">跨端开发</a><a href="/tags/Flutter/" style="font-size: 1.18em; color: rgb(133, 58, 128)">Flutter</a><a href="/tags/%E8%B7%A8%E7%AB%AF/" style="font-size: 1.18em; color: rgb(45, 108, 164)">跨端</a><a href="/tags/%E8%B7%A8%E5%B9%B3%E5%8F%B0/" style="font-size: 1.15em; color: rgb(188, 0, 64)">跨平台</a><a href="/tags/Adsense/" style="font-size: 1.22em; color: rgb(129, 52, 93)">Adsense</a><a href="/tags/%E5%86%85%E5%AE%B9%E5%8F%98%E7%8E%B0/" style="font-size: 1.15em; color: rgb(142, 142, 200)">内容变现</a><a href="/tags/%E8%B4%A6%E5%8F%B7%E6%B3%A8%E5%86%8C/" style="font-size: 1.15em; color: rgb(134, 134, 41)">账号注册</a><a href="/tags/%E4%B8%AD%E5%9B%BD/" style="font-size: 1.15em; color: rgb(120, 136, 58)">中国</a><a href="/tags/%E5%A4%A7%E9%99%86/" style="font-size: 1.18em; color: rgb(24, 145, 111)">大陆</a><a href="/tags/Google/" style="font-size: 1.22em; color: rgb(85, 169, 151)">Google</a><a href="/tags/google-adsense/" style="font-size: 1.18em; color: rgb(125, 5, 27)">google adsense</a><a href="/tags/hosts/" style="font-size: 1.15em; color: rgb(29, 84, 75)">hosts</a><a href="/tags/macos/" style="font-size: 1.15em; color: rgb(44, 124, 163)">macos</a><a href="/tags/chrome/" style="font-size: 1.15em; color: rgb(132, 172, 175)">chrome</a></div></div><div class="card-widget card-archives"><div class="item-headline"><i class="fas fa-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="fas fa-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><span class="card-archive-list-count">4</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><span class="card-archive-list-count">5</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><span class="card-archive-list-count">1</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/05/"><span class="card-archive-list-date">五月 2023</span><span class="card-archive-list-count">8</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/04/"><span class="card-archive-list-date">四月 2023</span><span class="card-archive-list-count">33</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/03/"><span class="card-archive-list-date">三月 2023</span><span class="card-archive-list-count">40</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/02/"><span class="card-archive-list-date">二月 2023</span><span class="card-archive-list-count">7</span></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/01/"><span class="card-archive-list-date">一月 2023</span><span class="card-archive-list-count">1</span></a></li></ul></div><div class="card-widget card-webinfo"><div class="item-headline"><i class="fas fa-chart-line"></i><span>网站资讯</span></div><div class="webinfo"><div class="webinfo-item"><div class="item-name">文章数目 :</div><div class="item-count">160</div></div><div class="webinfo-item"><div class="item-name">已运行时间 :</div><div class="item-count" id="runtimeshow" data-publishDate="2020-01-29T00:00:00.000Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总字数 :</div><div class="item-count">271.6k</div></div><div class="webinfo-item"><div class="item-name">本站访客数 :</div><div class="item-count" id="busuanzi_value_site_uv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">本站总访问量 :</div><div class="item-count" id="busuanzi_value_site_pv"><i class="fa-solid fa-spinner fa-spin"></i></div></div><div class="webinfo-item"><div class="item-name">最后更新时间 :</div><div class="item-count" id="last-push-date" data-lastPushDate="2023-09-12T14:50:42.373Z"><i class="fa-solid fa-spinner fa-spin"></i></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/youngjuning/images@main/1681097427413.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By 紫竹</div><div class="footer_custom_text"><a href="/rss2.xml" target="_blank">RSS2</a> | <a href="/privacy/" target="_blank">隐私政策</a> | <a href="/atom.xml" target="_blank">Atom</a><br/><a href="https://www.cnouyi.careers/join/54171828" rel="external nofollow noreferrer" nofollow target="_blank">欧易 - 注册开盲盒赢 BTC</a><br/><a href="https://sockboom.shop/auth/register?affid=552052" rel="external nofollow noreferrer" nofollow target="_blank">SockBoom - 稳定的科学上网梯子</a><br/><a href="https://www.pionex.com/zh-CN/sign/ref/0rcaD2ex9Om" rel="external nofollow noreferrer" nofollow target="_blank">Pionex 派网 - 网格交易| 量化交易</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>function panguFn () {
  if (typeof pangu === 'object') pangu.autoSpacingPage()
  else {
    getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
      .then(() => {
        pangu.autoSpacingPage()
      })
  }
}

function panguInit () {
  if (false){
    GLOBAL_CONFIG_SITE.isPost && panguFn()
  } else {
    panguFn()
  }
}

document.addEventListener('DOMContentLoaded', panguInit)</script><div class="js-pjax"><script>(() => {
  const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaid.length === 0) return
  const runMermaid = () => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    Array.from($mermaid).forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
      const mermaidID = 'mermaid-' + index
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)

      const renderV10 = () => {
        renderFn.then(({svg}) => {
          mermaidSrc.insertAdjacentHTML('afterend', svg)
        })
      }

      const renderV9 = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      typeof renderFn === 'string' ? renderV9(renderFn) : renderV10()
    })
  }

  const loadMermaid = () => {
    window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
  }

  btf.addModeChange('mermaid', runMermaid)

  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>function getGiscusTheme (theme) {
  return theme === 'dark' ? 'dark' : 'light'
}

function loadGiscus () {
  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'youngjuning/youngjuning.github.io',
    'data-repo-id': 'R_kgDOGFxZtw',
    'data-category-id': 'DIC_kwDOGFxZt84CUMwP',
    'data-mapping': 'pathname',
    'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },{"data-mapping":"og:title","data-lang":"zh-CN","data-input-position":"top"})

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme (theme) {
  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame')
    if (!iframe) return
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
  }

  sendMessage({
    setConfig: {
      theme: getGiscusTheme(theme)
    }
  });
}

btf.addModeChange('giscus', changeGiscusTheme)

if ('Giscus' === 'Giscus' || !true) {
  if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script><script>function loadLivere () {
  if (typeof LivereTower === 'object') {
    window.LivereTower.init()
  }
  else {
    (function(d, s) {
        var j, e = d.getElementsByTagName(s)[0];
        if (typeof LivereTower === 'function') { return; }
        j = d.createElement(s);
        j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
        j.async = true;
        e.parentNode.insertBefore(j, e);
    })(document, 'script');
  }
}

if ('Giscus' === 'Livere' || !true) {
  if (true) btf.loadComment(document.getElementById('lv-container'), loadLivere)
  else loadLivere()
}
else {
  function loadOtherComment () {
    loadLivere()
  }
}</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --></body></html>